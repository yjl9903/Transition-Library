# Start

```c++
#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define ms(a,b) memset(a,b,sizeof(a))
#define msn(a,n,b) for(int i=0;i<=n;i++)a[i]=b
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
#define fi first
#define se second
using namespace std;
mt19937 rng_32(chrono::steady_clock::now().time_since_epoch().count());
typedef long long ll;
typedef long double ld;
typedef pair<int,int> P;
const int mod=1e9+7;
const int seed=233;
const double PI=acos(-1.0);
const double eps=1e-7;
const int inf=0x3f3f3f3f;
const int max_n=100005;
namespace {
    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}
    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}
    inline int Mul(int x,int y) {return 1ll*x*y%mod;}
    inline int Pow(int x,int y=mod-2){if(x==0)return 0;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}
}
/**********************head************************/
```

# 输入输出挂

```c++
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
    char ch=nc();int sum=0;bool sign=false;
    while(!(ch>='0'&&ch<='9'))sign|=(ch=='-'),ch=nc();
    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
    return sign?-sum:sum;
}
inline void write(int x){
  static int stk[100], top = 0;
  if(x==0){putchar('0');return;}
  if(x<0){x=-x;putchar('-');}
  while(x){stk[++top]=x%10;x/=10;}
  while(top){putchar(stk[top--]+'0');}
}
```

# hashmap

```c++
template<template T>struct hashmap
{
    static const int max_n=100005;
    static const int seed=4000007;
    T a[max_n];
    int head[seed], next[max_n], size;
    void init () {
        memset (head, -1, sizeof head);
        size = 0;
    }
    int find (T val) {
        int tmp = (val%seed + seed)%seed;
        for (int i = head[tmp]; i != -1; i = next[i]) {
            if (val == a[i]) return i;
        }
        return -1;
    }
    void add (T val) {
        int tmp = (val%seed+seed)%seed;
        a[size] = val;
        next[size] = head[tmp];
        head[tmp] = size++;
    }
};
```

# 大数

```c++
// base and base_digits must be consistent
const int base = 1000000000;
const int base_digits = 9;

struct Bigint {
    vector<int> z;
    int sign;

    Bigint() :
        sign(1) {
    }

    Bigint(long long v) {
        *this = v;
    }

    Bigint(const string &s) {
        read(s);
    }

    void operator=(const Bigint &v) {
        sign = v.sign;
        z = v.z;
    }

    void operator=(long long v) {
        sign = 1;
        if (v < 0)
            sign = -1, v = -v;
        z.clear();
        for (; v > 0; v = v / base)
            z.push_back(v % base);
    }

    Bigint operator+(const Bigint &v) const {
        if (sign == v.sign) {
            Bigint res = v;

            for (int i = 0, carry = 0; i < (int) max(z.size(), v.z.size()) || carry; ++i) {
                if (i == (int) res.z.size())
                    res.z.push_back(0);
                res.z[i] += carry + (i < (int) z.size() ? z[i] : 0);
                carry = res.z[i] >= base;
                if (carry)
                    res.z[i] -= base;
            }
            return res;
        }
        return *this - (-v);
    }

    Bigint operator-(const Bigint &v) const {
        if (sign == v.sign) {
            if (abs() >= v.abs()) {
                Bigint res = *this;
                for (int i = 0, carry = 0; i < (int) v.z.size() || carry; ++i) {
                    res.z[i] -= carry + (i < (int) v.z.size() ? v.z[i] : 0);
                    carry = res.z[i] < 0;
                    if (carry)
                        res.z[i] += base;
                }
                res.trim();
                return res;
            }
            return -(v - *this);
        }
        return *this + (-v);
    }

    void operator*=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = 0, carry = 0; i < (int) z.size() || carry; ++i) {
            if (i == (int) z.size())
                z.push_back(0);
            long long cur = z[i] * (long long) v + carry;
            carry = (int) (cur / base);
            z[i] = (int) (cur % base);
            //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
        }
        trim();
    }

    Bigint operator*(int v) const {
        Bigint res = *this;
        res *= v;
        return res;
    }

    friend pair<Bigint, Bigint> divmod(const Bigint &a1, const Bigint &b1) {
        int norm = base / (b1.z.back() + 1);
        Bigint a = a1.abs() * norm;
        Bigint b = b1.abs() * norm;
        Bigint q, r;
        q.z.resize(a.z.size());

        for (int i = a.z.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.z[i];
            int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;
            int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;
            int d = ((long long) s1 * base + s2) / b.z.back();
            r -= b * d;
            while (r < 0)
                r += b, --d;
            q.z[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm);
    }

    friend Bigint sqrt(const Bigint &a1) {
        Bigint a = a1;
        while (a.z.empty() || a.z.size() % 2 == 1)
            a.z.push_back(0);

        int n = a.z.size();

        int firstDigit = (int) sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
        int norm = base / (firstDigit + 1);
        a *= norm;
        a *= norm;
        while (a.z.empty() || a.z.size() % 2 == 1)
            a.z.push_back(0);

        Bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];
        firstDigit = (int) sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
        int q = firstDigit;
        Bigint res;

        for(int j = n / 2 - 1; j >= 0; j--) {
            for(; ; --q) {
                Bigint r1 = (r - (res * 2 * base + q) * q) * base * base + (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);
                if (r1 >= 0) {
                    r = r1;
                    break;
                }
            }
            res *= base;
            res += q;

            if (j > 0) {
                int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;
                int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;
                int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;
                q = ((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2);
            }
        }

        res.trim();
        return res / norm;
    }

    Bigint operator/(const Bigint &v) const {
        return divmod(*this, v).first;
    }

    Bigint operator%(const Bigint &v) const {
        return divmod(*this, v).second;
    }

    void operator/=(int v) {
        if (v < 0)
            sign = -sign, v = -v;
        for (int i = (int) z.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = z[i] + rem * (long long) base;
            z[i] = (int) (cur / v);
            rem = (int) (cur % v);
        }
        trim();
    }

    Bigint operator/(int v) const {
        Bigint res = *this;
        res /= v;
        return res;
    }

    int operator%(int v) const {
        if (v < 0)
            v = -v;
        int m = 0;
        for (int i = z.size() - 1; i >= 0; --i)
            m = (z[i] + m * (long long) base) % v;
        return m * sign;
    }

    void operator+=(const Bigint &v) {
        *this = *this + v;
    }
    void operator-=(const Bigint &v) {
        *this = *this - v;
    }
    void operator*=(const Bigint &v) {
        *this = *this * v;
    }
    void operator/=(const Bigint &v) {
        *this = *this / v;
    }

    bool operator<(const Bigint &v) const {
        if (sign != v.sign)
            return sign < v.sign;
        if (z.size() != v.z.size())
            return z.size() * sign < v.z.size() * v.sign;
        for (int i = z.size() - 1; i >= 0; i--)
            if (z[i] != v.z[i])
                return z[i] * sign < v.z[i] * sign;
        return false;
    }

    bool operator>(const Bigint &v) const {
        return v < *this;
    }
    bool operator<=(const Bigint &v) const {
        return !(v < *this);
    }
    bool operator>=(const Bigint &v) const {
        return !(*this < v);
    }
    bool operator==(const Bigint &v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const Bigint &v) const {
        return *this < v || v < *this;
    }

    void trim() {
        while (!z.empty() && z.back() == 0)
            z.pop_back();
        if (z.empty())
            sign = 1;
    }

    bool isZero() const {
        return z.empty() || (z.size() == 1 && !z[0]);
    }

    Bigint operator-() const {
        Bigint res = *this;
        res.sign = -sign;
        return res;
    }

    Bigint abs() const {
        Bigint res = *this;
        res.sign *= res.sign;
        return res;
    }

    long long longValue() const {
        long long res = 0;
        for (int i = z.size() - 1; i >= 0; i--)
            res = res * base + z[i];
        return res * sign;
    }

    friend Bigint gcd(const Bigint &a, const Bigint &b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend Bigint lcm(const Bigint &a, const Bigint &b) {
        return a / gcd(a, b) * b;
    }

    void read(const string &s) {
        sign = 1;
        z.clear();
        int pos = 0;
        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-')
                sign = -sign;
            ++pos;
        }
        for (int i = s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for (int j = max(pos, i - base_digits + 1); j <= i; j++)
                x = x * 10 + s[j] - '0';
            z.push_back(x);
        }
        trim();
    }

    friend istream& operator>>(istream &stream, Bigint &v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream &stream, const Bigint &v) {
        if (v.sign == -1)
            stream << '-';
        stream << (v.z.empty() ? 0 : v.z.back());
        for (int i = (int) v.z.size() - 2; i >= 0; --i)
            stream << setw(base_digits) << setfill('0') << v.z[i];
        return stream;
    }

    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int) p.size(); i++)
            p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int) a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back(int(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int) cur);
        while (!res.empty() && res.back() == 0)
            res.pop_back();
        return res;
    }

    typedef vector<long long> vll;

    static vll karatsubaMultiply(const vll &a, const vll &b) {
        int n = a.size();
        vll res(n + n);
        if (n <= 32) {
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    res[i + j] += a[i] * b[j];
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        for (int i = 0; i < k; i++)
            a2[i] += a1[i];
        for (int i = 0; i < k; i++)
            b2[i] += b1[i];

        vll r = karatsubaMultiply(a2, b2);
        for (int i = 0; i < (int) a1b1.size(); i++)
            r[i] -= a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            r[i] -= a2b2[i];

        for (int i = 0; i < (int) r.size(); i++)
            res[i + k] += r[i];
        for (int i = 0; i < (int) a1b1.size(); i++)
            res[i] += a1b1[i];
        for (int i = 0; i < (int) a2b2.size(); i++)
            res[i + n] += a2b2[i];
        return res;
    }

    Bigint operator*(const Bigint &v) const {
        vector<int> a6 = convert_base(this->z, base_digits, 6);
        vector<int> b6 = convert_base(v.z, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while (a.size() < b.size())
            a.push_back(0);
        while (b.size() < a.size())
            b.push_back(0);
        while (a.size() & (a.size() - 1))
            a.push_back(0), b.push_back(0);
        vll c = karatsubaMultiply(a, b);
        Bigint res;
        res.sign = sign * v.sign;
        for (int i = 0, carry = 0; i < (int) c.size(); i++) {
            long long cur = c[i] + carry;
            res.z.push_back((int) (cur % 1000000));
            carry = (int) (cur / 1000000);
        }
        res.z = convert_base(res.z, 6, base_digits);
        res.trim();
        return res;
    }
};
```



# Math

## 组合数相关

```c++
ll f[max_n*2];
ll inv[max_n*2];
ll invn[max_n*2];
ll C(int n,int m)
{
    if(n<m||m<0)return 0;
    return f[n]*inv[n-m]%mod*inv[m]%mod;
}
ll S(int n,int m)
{
    // x_1 + x_2 + ... + x_n = m, x_i >= 0
    if(n==0&&m==0)return 1;
    return C(m+n-1,n-1);
}
ll solve(int n,int s,int m)//xi<m,xi>=0
{
    ll res=S(n,s);
    for(int i=1;i<=n;i++)
    {
        if(i&1)res=Sub(res,Mul(C(n,i),S(n,s-m*i)));
        else res=Add(res,Mul(C(n,i),S(n,s-m*i)));
    }
    return res;
}
void init(int n)
{
    f[0]=1;
    for(int i=1;i<=n;i++)f[i]=f[i-1]*i%mod;
    inv[n]=Pow(f[n]);
    for(int i=n-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;
    invn[1]=1;
    for(int i=2;i<=n;i++)invn[i]=invn[mod%i]*(mod-mod/i)%mod;
}
ll Lucas(ll n,ll m)
{
    if(n<m||m<0)return 0;
    if(m==0)return 1;
    return C(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
}
```



##开i次方精度较高

```c++
ll work(ll n,ll i)
{
    ll t=powl(n,1.0/i)-0.5;
    t=t+(powl(t+1,i)-0.5<=n);
    return t;
}
```

## 矩阵快速幂

```c++
struct mat
{
    int n,m;
    int a[3][3];
    mat(int _n=0,int _m=0){n=_n,m=_m;ms(a,0);}
    mat operator * (mat b)
    {
        mat c(n,b.m);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<b.m;j++)
            {
                c.a[i][j]=0;
                for(int k=0;k<m;k++)
                {
                    //(c.a[i][j]+=a[i][k]*b.a[k][j])%=mod;
                    c.a[i][j]=Add(c.a[i][j],Mul(a[i][k],b.a[k][j]));
                }
            }
        }
        return c;
    }
    void unit()
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)a[i][j]=(i==j);
        }
    }
};
mat quick_pow(mat a,ll n)
{
    mat c(a.n,a.m);
    c.unit();
    while(n)
    {
        if(n&1)c=c*a;
        a=a*a;
        n>>=1;
    }
    return c;
}
```



## fft

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=50005;
const double PI=acos(-1.0);
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r;i=_i;}
    Complex operator +(const Complex &b){return Complex(r+b.r,i+b.i);}
    Complex operator -(const Complex &b){return Complex(r-b.r,i-b.i);}
    Complex operator *(const Complex &b){return Complex(r*b.r-i*b.i,r*b.i+i*b.r);}
};
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)
        {
            j-=k;
            k/=2;
        }
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
```



## fft+原根

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=200005;
const double PI=acos(-1.0);
int n,p;
int a[max_n];
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r,i=_i;}
    Complex operator + (Complex &c){return Complex(r+c.r,i+c.i);}
    Complex operator - (Complex &c){return Complex(r-c.r,i-c.i);}
    Complex operator * (Complex &c){return Complex(r*c.r- i*c.i,r*c.i+i*c.r);}
}c[max_n*4];
int ip[max_n];
int pi[max_n];
int g;
int cnt[max_n];
ll ans[max_n];
ll quick_pow(ll a,ll b,ll p)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%p;
        b>>=1;
        a=a*a%p;
    }
    return res;
}
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=y[k+h/2]*w;
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
ll get_root(ll p)
{
	if(p==2)return 1;
    else
    {
        vector<ll> v;
        v.clear();
        int x=p-1;
        for(int i=2;1ll*i*i<=x;i++)
        {
            if(x%i==0)
            {
                v.push_back(i);
                while(x%i==0)x/=i;
            }
        }
        if(x!=1)v.push_back(x);
        ll t;
        bool flag;
        for(int i=2;i<p;i++)
        {
            flag=true;
            for(auto d:v)
            {
                t=(p-1)/d;
                if(quick_pow(i,t,p)==1)
                {
                    flag=false;
                    break;
                }
            }
            if(flag)return i;
        }
    }
    return -1;
}
void init(ll p)
{
    g=get_root(p);
    ip[0]=1;
    pi[1]=0;
    for(int i=1;i<p-1;i++)ip[i]=1ll*ip[i-1]*g%p,pi[ip[i]]=i;
}
```



## ntt,g=3

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const ll mod=998244353;
int n;
int w[max_n];
ll x1[max_n*4];
ll x2[max_n*4];
ll inv[max_n];
ll quick_pow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return res;
}
void change(ll y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void ntt(ll y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        ll wn=quick_pow(3,(mod-1)/h);
        if(on==-1)wn=quick_pow(wn,mod-2);
        for(int j=0;j<len;j+=h)
        {
            ll w=1;
            for(int k=j;k<j+h/2;k++)
            {
                ll u=y[k];
                ll t=y[k+h/2]*w%mod;
                y[k]=(u+t)%mod;
                y[k+h/2]=(u-t+mod)%mod;
                w=w*wn%mod;
            }
        }
    }
    if(on==-1)
    {
        ll rlen=quick_pow(len,mod-2);
        for(int i=0;i<len;i++)y[i]=y[i]*rlen%mod;
    }
}
```



## 任意模数fft

```c++
namespace {
    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}
	inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}
    inline int Mul(int x,int y) {return 1ll*x*y%mod;}
    inline int Pow(int x,int y=mod-2){int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}
}

int Tonelli_Shanks(int n,ll p)
{
    if(p==2) return (n&1)?1:-1;
    if(Pow(n,p>>1)!=1) return -1;
    if(p&2) return Pow(n,(p+1)>>2);
    int s=__builtin_ctzll(p^1);
    int q=p>>s,z=2;
    for(;Pow(z,p>>1)==1;++z);
    int c=Pow(z,q),r=Pow(n,(q+1)>>1),t=Pow(n,q),tmp;
    for(int m=s,i;t!=1;)
    {
        for(i=0,tmp=t;tmp!=1;++i) tmp=tmp*tmp%p;
        for(;i<--m;) c=c*c%p;
        r=r*c%p;c=c*c%p;t=t*c%p;
    }
    return r;
}


namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;

    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};


namespace poly
{
    int inv(int x) {return Pow(x,mod-2);}
    vector<int> fa,fb,fc,fd;
    vector<int> get_inv(vector<int> &a,int n)
    {
        assert(a[0]!=0);
        if(n==1)
        {
            fa.resize(1);
            fa[0]=inv(a[0]);
            return fa;
        }
        fa=get_inv(a,(n+1)>>1);
        fb=fft::multiply_mod(fa,fa,mod,1);
        fb=fft::multiply_mod(fb,a,mod);
        fa.resize(n);
        for(int i=0;i<n;i++)
        {
            fa[i]=Add(fa[i],fa[i]);
            fa[i]=Sub(fa[i],fb[i]);
        }
        return fa;
    }
    vector<int> get_sqrt(vector<int> &a,int n)
    {
        if(n==1)
        {
            fc.resize(1);
            int x=Tonelli_Shanks(a[0],mod);
            assert(x!=-1);
            fc[0]=x;return fc;
        }
        fd=get_sqrt(a,(n+1)>>1);
        fc=get_inv(fd,(n+1)>>1);
        fd=fft::multiply_mod(fd,fd,mod,1);
        for(int i=0;i<(n+1)/2;i++) fc[i]=1LL*fc[i]*((mod+1)/2)%mod;
        for(int i=0;i<n;i++) fd[i]=Add(fd[i],a[i]);
        fd=fft::multiply_mod(fd,fc,mod);
        fd.resize(n);return fd;
    }
    vector<int> diff(vector<int> &a)
    {
        for(int i=1;i<(int)a.size();i++) a[i-1]=1LL*a[i]*i%mod;
        if(a.size()>=1) a.resize((int)a.size()-1);
        return a;
    }
    vector<int> intg(vector<int> &a)
    {
        int sz=(int)a.size();
        a.resize(sz+1);
        static vector<int> Inv(sz+1);
        Inv[1]=1;
        for(int i=2;i<=sz;i++) Inv[i]=Sub(mod,1LL*Inv[mod%i]*(mod/i)%mod);
        for(int i=sz;i>=1;i--) a[i]=1LL*a[i-1]*Inv[i]%mod;
        a[0]=0;
        return a;
    }
};
```



## 多项式

```c++
const int inv2=(mod+1)>>1,mrt=31596;
const int fmaxn=21,Fmaxn=(1<<fmaxn)+5,G=3;
int nxtl[Fmaxn],nxtlim[Fmaxn],inv[Fmaxn];
namespace Solve {
    map<int,int>ins;
    inline int Solve2(int p) {
        static int j,res;
        if(p==0)
            return 0;
        j=1;
        for(int i=0;i<mrt;++i)
            ins[j]=i,j=Mul(j,G);
        res=0,j=Pow(j);
        for(int i=0;i<=mrt;++i) {
            if(ins.count(p)) {
                res=(res+ins[p])%(mod-1);
                if(res&1)
                    return -1;
                res=Pow(G,res/2);
                if(mod-res<res)
                    res=mod-res;
                return res;
            }
            p=Mul(p,j),res=(res+mrt)%(mod-1);
        }
        return -1;
    }
}
namespace Poly {
    static int root[fmaxn][Fmaxn],mx,rev[Fmaxn];
    inline void Rev(int l) {
        rev[0]=0;
        for(int i=1;i<(1<<l);++i)
            rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
    }
    inline void DFT(vector<int>&a,int bit) {
        if(mx<bit) {
            for(int i=mx;i<bit;++i) {
                int len=1<<i,w0=Pow(G,(mod-1)/(len<<1)),w=1;
                for(int j=0;j<len;++j)
                    root[i][j]=w,w=Mul(w,w0);
            }
            mx=bit;
        }
        for(int i=1;i<1<<bit;++i)
            if(i<rev[i])
                swap(a[i],a[rev[i]]);
        for(int i=0,len=1;i<bit;++i,len<<=1)
            for(int j=0;j<(1<<bit);j+=(len<<1))
                for(int k=0;k<len;++k) {
                    int x=a[j+k],y=Mul(a[j+k+len],root[i][k]);
                    a[j+k]=Add(x,y),a[j+k+len]=Sub(x,y);
                }
    }
    inline void IDFT(vector<int>&a,int bit) {
        int len=(1<<bit),inv=Pow(len);
        reverse(a.begin()+1,a.end());
        DFT(a,bit);
        for(int i=0;i<len;++i)
            a[i]=Mul(a[i],inv);
    }
    inline void FFT(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=la+lb-1,l=nxtl[lc],lim=nxtlim[lc];
        a.resize(lim),b.resize(lim),c.resize(lim);
        Rev(l),DFT(a,l),DFT(b,l);
        for(int i=0;i<lim;++i)
            c[i]=Mul(a[i],b[i]);
        IDFT(c,l);
        c.resize(lc);
        while(!c.back())
        	c.pop_back();
    }
    inline void AddPoly(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=max(la,lb);
        c.resize(lc);
        for(int i=0;i<lc;++i) {
            if(i<la)
                c[i]=Add(c[i],a[i]);
            if(i<lb)
                c[i]=Add(c[i],b[i]);
        }
    }
    inline void SubPoly(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=max(la,lb);
        c.resize(lc);
        for(int i=0;i<lc;++i) {
            if(i<la)
                c[i]=Add(c[i],a[i]);
            if(i<lb)
                c[i]=Sub(c[i],b[i]);
        }
    }
    inline void Inv(vector<int>f,vector<int>&g,int len) {
        g.clear();
        int lim=nxtlim[len];
        f.resize(lim),g.resize(lim);
        g[0]=Pow(f[0]);
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i<<1),l(i<<1),o(i<<1);
            for(int j=0;j<i;++j)
                h[j]=f[j];
            for(int j=0;j<i>>1;++j)
                l[j]=g[j];
            Rev(p+1),DFT(h,p+1),DFT(l,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(h[j],Mul(l[j],l[j]));
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=Sub(Mul(2,g[j]),o[j]);
        }
        g.resize(len);
    }
    inline void Ln(vector<int>f,vector<int>&g,int len) {
        g.clear();
        vector<int>h(len,0);
        for(int i=1;i<len;++i)
            h[i-1]=Mul(f[i],i);
        h[len-1]=0;
        Inv(f,g,len);
        FFT(g,h,g);
        for(int i=len-1;i;--i)
            g[i]=Mul(g[i-1],::inv[i]);
        g[0]=0;
        g.resize(len);
    }
    inline void Exp(vector<int>f,vector<int>&g,int len,int init) {
        int lim=nxtlim[len];
        if(init)
           g.clear(),g.push_back(1);
        f.resize(lim),g.resize(lim);
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i<<1),l,o(i<<1,0);
            for(int j=0;j<i>>1;++j)
                h[j]=g[j];
            Ln(h,l,i);
            for(int j=0;j<i;++j)
                l[j]=Sub(f[j]+(!j),l[j]),l.push_back(0);
            Rev(p+1),DFT(h,p+1),DFT(l,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(h[j],l[j]);
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=o[j];
        }
        g.resize(len);
    }
    inline void Pow(vector<int>f,vector<int>&g,int len,ll k) {
        g.clear();
        vector<int>h;
        Ln(f,h,len);
        int o=k%mod;
        for(int i=0;i<len;++i)
            h[i]=Mul(h[i],o);
        g.push_back(::Pow(f[0],(int)(k%(mod-1))));
        Exp(h,g,len,0);
    }
    inline void Sqrt(vector<int>f,vector<int>&g,int len) {
        g.clear();
        g.push_back(Solve::Solve2(f[0]));
        int lim=nxtlim[len];
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i),l,o(i<<1,0);
            g.resize(i<<1);
            for(int j=0;j<i;++j)
                h[j]=g[j];
            Inv(h,l,i);
            l.resize(i<<1);
            for(int j=0;j<min(i,(int)f.size());++j)
                o[j]=f[j];
            Rev(p+1),DFT(g,p+1),DFT(l,p+1),DFT(o,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(Add(g[j],Mul(l[j],o[j])),inv2);
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=o[j];
            g.resize(i);
        }
        g.resize(len);
    }
}
void init()
{
    nxtl[1]=0,nxtlim[1]=1,inv[1]=1;
    for(int i=1;i<Fmaxn-1;++i) {
        nxtl[i+1]=nxtl[i],nxtlim[i+1]=nxtlim[i];
        if(i==(i&-i))
            ++nxtl[i+1],nxtlim[i+1]<<=1;
    }
    for(int i=2;i<Fmaxn;++i)
        inv[i]=Mul(inv[mod%i],(mod-mod/i));
}
```

## fwt_mod

```c++
int quick_pow(int a,int b)
{
    if(a==0)return 0;
    int res=1;
    while(b)
    {
        if(b&1)res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
void fwt_xor(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                int tmp=a[j+k];
                a[j+k]=(tmp+a[j+k+i])%mod;
                a[j+k+i]=(tmp+mod-a[j+k+i])%mod;
            }
        }
    }
    if(opt==-1)
    {
        int inv=quick_pow(l,mod-2);
        for(int i=0;i<l;i++)a[i]=1ll*a[i]*inv%mod;
    }
}


void fwt_or(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k+i]=(a[j+k+i]+a[j+k])%mod;
                else a[j+k+i]=(a[j+k+i]+mod-a[j+k])%mod;
            }
        }
    }
}
void fwt_and(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k]=(a[j+k]+a[j+k+i])%mod;
                else a[j+k]=(a[j+k]+mod-a[j+k+i])%mod;
            }
        }
    }
}
```

## fwt

```c++
void fwt_xor(ll* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                ll tmp=a[j+k];
                a[j+k]+=a[j+k+i];
                a[j+k+i]=tmp-a[j+k+i];
                if(opt==-1)a[j+k]/=2,a[j+k+i]/=2;
            }
        }
    }
}
```



## 线性基

```c++
template<typename T>struct linear_base
{
    static const int max_log=61;//can't be too large
    T a[max_log],b[max_log];
    T pos[max_log];
    bool zero;
    int cnt;
    linear_base(){cnt=0;zero=false;ms(a,0);ms(pos,0);ms(b,0);}
    void init(){cnt=0;zero=false;ms(a,0);ms(pos,0);ms(b,0);}
    void insert(T x,T id=0)
    {
        for(int i=max_log-1;i>=0;i--)
        {
            if(x>>i&1)
            {
                if(a[i])
                {
                    if(id>pos[i])swap(id,pos[i]),swap(x,a[i]);
                    x^=a[i];
                }
                else
                {
                    cnt++;
                    a[i]=x;
                    pos[i]=id;
                    return;
                }
            }
        }
        zero=true;
    }
    bool check(T x)
    {
        for(int i=max_log-1;i>=0;i--)
        {
            if(x>>i&1)
            {
                if(a[i])x^=a[i];
                else return false;
            }
        }
        return true;
    }
    T qmax(T x)
    {
        T res=x;
        for(int i=max_log-1;i>=0;i--)
        {
            if((res^a[i])>res)res^=a[i];
        }
        return res;
    }
    void work()//to make a[] standard , can be done outside to lower time complexity
    {
        int tc=0;
        for(int i=0;i<max_log;i++)
        {
            if(a[i]==0)continue;
            for(int j=i-1;j>=0;j--)if((a[i]>>j)&1)a[i]^=a[j];
            b[tc++]=a[i];
        }
    }
    T query(T k)
    {
        if(zero)k--;//note
        T res=0;
        for(int i=0;i<cnt;i++)if(k>>i&1)res^=b[i],k^=(T)1<<i;
        if(k)return -1;//k is bigger than max value
        return res;
    }
};
```



## 扩展欧几里得

```c++
void extgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0)
    {
        x=1,y=0;
        return;
    }
    extgcd(b,a%b,x,y);
    ll t=x;
    x=y,y=t-a/b*y;
}
bool solve(ll a,ll b,ll c,ll &x,ll &y)//smallest positive x
{
    ll d=__gcd(a,b);
    if(c%d)return 0;
    a/=d,b/=d,c/=d;
    extgcd(a,b,x,y);
    x*=c,y*=c;
    x=(x%b+b)%b;
    if(x==0)x+=b;
    y=(c-a*x)/b;
    return 1;
}
bool mod_inv(ll a,ll m,ll &x)
{
    ll y;
    if(solve(a,m,1,x,y))return 1;
    return 0;
}
```



## 欧拉降幂

```c++
#include<bits/stdc++.h>
#define Mod(a,b) a<b?a:a%b+b
//this Mod is important
using namespace std;
typedef long long ll;
const int max_n=100005;
int n,mod;
int a[max_n];
int q;
unordered_map<int,int> phi;
ll quick_pow(ll a,ll b,ll mod)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=Mod(res*a,mod);//Mod
        b>>=1;
        a=Mod(a*a,mod);
    }
    return res;
}
int Phi(int n)
{
    if(phi[n])return phi[n];
    int res=n,x=n;//int x=n is a good haibit
    for(int i=2;i<=sqrt(x);i++)
    {
        if(x%i==0)
        {
            while(x%i==0)x/=i;
            res=res/i*(i-1);
        }
    }
    if(x!=1)res=res/x*(x-1);
    return phi[n]=res;
}
ll solve(int l,int r,ll mod)//Mod
{
    if(l==r||mod==1)return Mod(a[l],mod);
    return quick_pow(a[l],solve(l+1,r,Phi(mod)),mod);
}
int main()
{
    scanf("%d%d",&n,&mod);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    scanf("%d",&q);
    int l,r;
    for(int i=1;i<=q;i++)
    {
        scanf("%d%d",&l,&r);
        printf("%lld\n",solve(l,r,mod)%mod);//need %mod
    }
    return 0;
}
```

## 高斯消元

### 实数版

```c++
int n;
double a[max_n][max_n],ans[max_n];
bool gauss()
{
    for(int i=1;i<=n;i++)
    {
        int r=i;
        for(int j=i+1;j<=n;j++)if(abs(a[j][i])>abs(a[r][i]))r=j;
        if(abs(a[r][i])<eps)return false;
        swap(a[r],a[i]);
        double inv=a[i][i];
        for(int j=i;j<=n+1;j++)a[i][j]/=inv;
        for(int j=i+1;j<=n;j++)
        {
            double inv=a[j][i];
            for(int k=i;k<=n+1;k++)a[j][k]-=inv*a[i][k];
        }
    }
    for(int i=n;i>=1;i--)
    {
        ans[i]=a[i][n+1];
        for(int j=i+1;j<=n;j++)ans[i]-=a[i][j]*ans[j];
    }
    return true;
}
```

### 取模版

```c++
int n;
int a[max_n][max_n],ans[max_n];
bool gauss()
{
    for(int i=1;i<=n;i++)
    {
        int r=i;
        for(int j=i+1;j<=n;j++)if(a[j][i]>a[r][i])r=j;
        if(a[r][i]==0)return false;
        int inv=Pow(a[i][i]);
        for(int j=i;j<=n+1;j++)a[i][j]=1ll*a[i][j]*inv%mod;
        for(int j=i+1;j<=n;j++)
        {
            int inv=a[j][i];
            for(int k=i;k<=n+1;k++)a[j][k]+=mod-1ll*inv*a[i][k]%mod,a[j][k]%=mod;
        }
    }
    for(int i=n;i>=1;i--)
    {
        ans[i]=a[i][n+1];
        for(int j=i+1;j<=n;j++)ans[i]+=mod-1ll*ans[j]*a[i][j]%mod,ans[i]%=mod;
    }
    return true;
}
```

## 拉格朗日插值

```c++
namespace Lagrange
{
    int x[max_n],y[max_n],n;
    int inv[max_n];
    int pre[max_n],suf[max_n];
    void init(int* _x,int* _y,int _n)
    {
        n=_n;
        for(int i=1;i<=n;i++)x[i]=_x[i],y[i]=_y[i];
        int res=1;
        for(int i=1;i<=n;i++)res=1ll*res*i%mod;
        inv[n]=Pow(res);
        for(int i=n-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    }
    int cal(int m)//O(n^2)
    {
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1,ty=1;
            for(int j=1;j<=n;j++)
            {
                if(j==i)continue;
                tx=1ll*tx*(m+mod-x[j])%mod;
                ty=1ll*ty*(x[i]+mod-x[j])%mod;
            }
            tx=1ll*tx*Pow(ty)%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
    int qcal(int m)//O(n)
    {
        pre[0]=suf[n+1]=1;
        for(int i=1;i<=n;i++)pre[i]=1ll*pre[i-1]*(m+mod-x[i])%mod;
        for(int i=n;i>=1;i--)suf[i]=1ll*suf[i+1]*(m+mod-x[i])%mod;
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1ll*pre[i-1]*suf[i+1]%mod;
            int ty=1ll*inv[i-1]*inv[n-i]%mod;
            if((n-i)&1)ty=mod-ty;
            tx=1ll*tx*ty%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
}
```





## 积性函数

### min_25筛递归版

```c++
int Sqr;
ll n;
int cnt;
bool p[max_n];
int pri[max_n];
int m;
ll w[max_n*2];
int id1[max_n*2],id2[max_n*2];
ll pre[max_n];
ll g[max_n*2],h[max_n*2],s[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i,pre[cnt]=(pre[cnt-1]+i)%mod;//decided
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
void init()
{
    Sqr=sqrt(n);
    m=0;
    ll i,j;
    for(i=1;i<=n;i=j+1)
    {
        w[++m]=n/i;
        g[m]=(w[m]+1)%mod*(w[m]%mod)%mod;//decided by f(x)
        if(g[m]&1)g[m]+=mod;
        g[m]/=2,g[m]--;
        h[m]=(w[m]-1)%mod;
        j=n/(n/i);
        if(w[m]<=Sqr)id1[w[m]]=m;
        else id2[n/w[m]]=m;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=(w[j]/pri[i]<=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];
            g[j]=g[j]+mod-1ll*pri[i]*(g[k]+mod-pre[i-1])%mod,g[j]%=mod;
            h[j]=h[j]+mod-(h[k]+mod-(i-1)),h[j]%=mod;//decided by f(x)
        }
    }
}
ll S(ll x,ll y)
{
    if(x<=1||x<pri[y])return 0;
    int k=x<=Sqr?id1[x]:id2[n/x];
    ll res=g[k]-pre[y-1]+mod-(h[k]-(y-1));//decided by f(x)
    res%=mod;
    if(y==1)res+=2;//decided by details
    for(int i=y;i<=cnt&&1ll*pri[i]*pri[i]<=x;i++)
    {
        ll t1=pri[i],t2=1ll*pri[i]*pri[i];
        for(int e=1;t2<=x;e++,t1=t2,t2*=pri[i])
        {
            res+=(pri[i]^e)*S(x/t1,i+1)%mod+(pri[i]^(e+1));//decided by f(x)
            res%=mod;
        }
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init();
    printf("%lld\n",(1+S(n,1))%mod);
    return 0;
}
```

### min_25筛非递归版

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const int mod=998244353;
ll n;
int Sqr,m;
int ID(ll x){return x<=Sqr?m+1-x:n/x;}

bool p[max_n];
int pri[max_n];
int cnt;
ll w[max_n*2],g[max_n*2],f[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i;
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
ll F(ll e)
{
    if(e==1)return mod-2;
    else if(e==2)return 1;
    else return 0;
}
void init(ll n)
{
    Sqr=sqrt(n);
    m=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        w[++m]=n/l;
        g[m]=(w[m]-1)%mod;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=ID(w[j]/pri[i]);
            g[j]=g[j]+mod-(g[k]+mod-(i-1))%mod,g[j]%=mod;
        }
    }
    for(int i=cnt;i;i--)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            ll t1=pri[i],t2=1ll*pri[i]*pri[i];
            for(int e=1;t2<=w[j];e++,t1=t2,t2*=pri[i])
            {
                if(e>=3)break;
                int k=ID(w[j]/t1);
                f[j]+=F(e)*(f[k]+mod-2*(g[k]+mod-i)%mod)%mod+F(e+1),f[j]%=mod;
            }
        }
    }
    for(int j=1;j<=m;j++)f[j]+=mod-g[j]*2%mod,f[j]%=mod;
}
ll solve(ll n)
{
    ll res=0;
    ll ps=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        int k=ID(r);
        ll ns=f[k]+1;
        ll tmp=n/l%mod;
        tmp=tmp*tmp%mod;
        res+=tmp*(ns+mod-ps)%mod,res%=mod;
        ps=ns;
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init(n);
    printf("%lld\n",solve(n));
}
```



# 字符串

## 字符串哈希

```c++
char s[max_n];
ll hs[max_n];
ll hp[max_n];
void iniths(char *s,ll hs[])//s is 1 based
{
    hs[0]=0;
    int len=strlen(s+1);
    for(int i=1;i<=len;i++)hs[i]=hs[i-1]*seed+s[i],hs[i]%=mod;
}
ll geths(int l,int r,ll hs[])//get hs of s[l...r]
{
    return (hs[r]+mod-hs[l-1]*hp[r-l+1]%mod)%mod;
}
void init(int n)
{
    hp[0]=1;
    for(int i=1;i<=n;i++)hp[i]=hp[i-1]*seed%mod;
}
int main()
{
    scanf("%s",s+1);
    iniths(s,hs);
}
```

## 最小表示法

```c++
int get_mins(char *s)
{
    int len=strlen(s);
    int i,j,k;
    i=0,j=1,k=0;
    while(i<len&&j<len&&k<len)
    {
        int d=s[(i+k)%len]-s[(j+k)%len];
        if(!d)k++;
        else
        {
            if(d>0)i+=k+1;
            else j+=k+1;
            if(i==j)j++;
            k=0;
        }
    }
    return i<j?i:j;
}
```



## kmp

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=1000005;
char s1[max_n];
char s2[max_n];
int nex[max_n];
void get_next(char *s)
{
    int i=0,j;
    nex[0]=j=-1;
    int len=strlen(s);
    while(i<len)
    {
        if(j==-1||s[i]==s[j])nex[++i]=++j;
        else j=nex[j];
    }
}
void kmp(char *s1,char *s2)
{
    int i=0,j=0;
    int len1=strlen(s1),len2=strlen(s2);
    while(i<len1)
    {
        if(j==-1||s1[i]==s2[j])++i,++j;
        else j=nex[j];
        if(j==len2)
        {
            printf("%d\n",i-(len2-1));
            j=nex[j];
        }
    }
}
int main()
{
    scanf(" %s %s",s1,s2);
    len1=strlen(s1);
    len2=strlen(s2);
    get_next(s2);
    kmp(s1,s2);
    printf("%d",nex[1]);
    for(int i=2;i<=len2;i++)printf(" %d",nex[i]);
    printf("\n");
    return 0;
}
```

## Extend KMP

```c++
int exnex[max_n];
int extend[max_n];
void exkmp(char *s1,char *s2,int *exnex,int *extend)
{
    int i,a,p,j;
    int len1=strlen(s1);
    int len2=strlen(s2);
    for(int i=0;i<len1;i++,j--)
    {
        if(i<=1)j=-1;//to make sure that exnex[i-a] is a known value
        if(j<0||i+exnex[i-a]>=p)
        {
            if(j<0)j=0,p=i;
            while(p<len1&&j<len2&&s1[p]==s2[j])++p,++j;
            extend[i]=j,a=i;
        }
        else extend[i]=exnex[i-a];
    }
}
```



## AC自动机

### 含有的模式串的个数

```c++
#include<bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int max_n=1000005;
int n;
char s[max_n];
queue<int> q;
struct auto_ac
{
    int c[max_n][26],val[max_n],fail[max_n],cnt,vis[max_n];
    auto_ac(){while(!q.empty())q.pop();}
    void insert(char *s)
    {
        int len=strlen(s);
        int p=0;
        for(int i=0;i<len;i++)
        {
            int nc=s[i]-'a';
            if(!c[p][nc])c[p][nc]=++cnt;
            p=c[p][nc];
        }
        val[p]++;
    }
    void get_fail()
    {
        for(int i=0;i<26;i++)
        {
            if(c[0][i])
            {
                fail[c[0][i]]=0;
                q.push(c[0][i]);
            }
        }
        int p;
        while(!q.empty())
        {
            p=q.front();
            q.pop();
            for(int i=0;i<26;i++)
            {
                if(c[p][i])
                {
                    fail[c[p][i]]=c[fail[p]][i];
                    q.push(c[p][i]);
                }
                else c[p][i]=c[fail[p]][i];
            }
        }
    }
    int query(char *s)
    {
        int ans=0;
        int p=0;
        int len=strlen(s);
        ms(vis,0);
        for(int i=0;i<len;i++)
        {
            int nc=s[i]-'a';
            p=c[p][nc];
            int tmp=p;
            while(tmp)
            {
                if(!vis[tmp])ans+=val[tmp],vis[tmp]=true;
                else break;
                tmp=fail[tmp];
            }
        }
        return ans;
    }
}AC;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf(" %s",s);
        AC.insert(s);
    }
    AC.get_fail();
    scanf(" %s",s);
    printf("%d\n",AC.query(s));
    return 0;
}
```



### 出现次数最多的模式串

```c++
#include<bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
const int max_n=1000005;
int n;
char s[max_n];
queue<int> q;
char ss[155][80];
int res[155];
struct auto_ac
{
    int c[max_n][26],val[max_n],fail[max_n],last[max_n],cnt,vis[max_n];
    void init(){ms(c,0),ms(val,0),ms(fail,0),cnt=0;}
    void insert(char *s,int id)
    {
        int len=strlen(s);
        int p=0;
        for(int i=0;i<len;i++)
        {
            int nc=s[i]-'a';
            if(!c[p][nc])c[p][nc]=++cnt;
            p=c[p][nc];
        }
        val[p]++;
        last[p]=id;
    }
    void get_fail()
    {
        for(int i=0;i<26;i++)
        {
            if(c[0][i])
            {
                fail[c[0][i]]=0;
                q.push(c[0][i]);
            }
        }
        int p;
        while(!q.empty())
        {
            p=q.front();
            q.pop();
            for(int i=0;i<26;i++)
            {
                if(c[p][i])
                {
                    fail[c[p][i]]=c[fail[p]][i];
                    q.push(c[p][i]);
                }
                else c[p][i]=c[fail[p]][i];
            }
        }
    }
    void query(char *s)
    {
        int p=0;
        int len=strlen(s);
        //for(int i=0;i<=cnt;i++)vis[i]=false;
        ms(res,0);
        for(int i=0;i<len;i++)
        {
            int nc=s[i]-'a';
            p=c[p][nc];
            int tmp=p;
            while(tmp)
            {
                res[last[tmp]]+=val[tmp];
                tmp=fail[tmp];
            }
        }
        int ans=0;
        for(int i=0;i<n;i++)ans=max(ans,res[i]);
        printf("%d\n",ans);
        if(ans)for(int i=0;i<n;i++)if(res[i]==ans)printf("%s\n",ss[i]);
    }
}AC;
int main()
{
    while(~scanf("%d",&n)&&n)
    {
        AC.init();
        for(int i=0;i<n;i++)
        {
            scanf(" %s",ss[i]);
            AC.insert(ss[i],i);
        }
        AC.get_fail();
        scanf(" %s",s);
        AC.query(s);
    }
    return 0;
}
```



## Manacher

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=11000005;
char s[max_n];
char cs[max_n*2];
int p[max_n*2];//回文半径
void manacher(char *s)
{
    int mid,mx;
    mid=0,mx=0;
    int len=strlen(s);
    for(int i=1;i<len;i++)
    {
        if(i<mx)p[i]=min(p[mid*2-i],mx-i);
        else p[i]=1;
        while(s[i-p[i]]==s[i+p[i]])p[i]++;
        if(mx<i+p[i])mid=i,mx=i+p[i];
        //cnt[(i+1)/2]++,cnt[(i+p[i]-1)/2+1]--;
    }
    /*
    cnt[0]=0;
    for(int i=1;i<=len/2-1;i++)cnt[i]+=cnt[i-1];
    以i（string 1 base)为右端点的回文串的个数
    */
}
int main()
{
    scanf(" %s",s);
    int len=strlen(s);
    cs[0]='#';//一个特殊字符，使得向2边扩的时候总会终止
    for(int i=1;i<=len*2+1;i++)
    {
        if(i&1)cs[i]='$';
        else cs[i]=s[i/2-1];
    }
    cs[len*2+2]=0;
    manacher(cs);
    return 0;
}
```



## 后缀数组

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=1000005;
int n,m;
char s[max_n];
int sa[max_n],rk[max_n],x[max_n],y[max_n],c[max_n],height[max_n];
/*整数的时候对数组离散化
int p[max_n];
int cs[max_n];
bool cmp(int x,int y){return s[x]<s[y];}
void change(int *s)
{
    for(int i=1;i<=n;i++)p[i]=i;
    sort(p+1,p+n+1,cmp);
    int x=1;
    cs[p[1]]=1;
    for(int i=2;i<=n;i++)cs[p[i]]=s[p[i]]==s[p[i-1]]?x:++x;
}
*/
void get_sa(char *s)
{
    n=strlen(s+1);
    m=122;
    for(int i=1;i<=m;i++)c[i]=0;
    for(int i=1;i<=n;i++)++c[x[i]=s[i]];
    for(int i=2;i<=m;i++)c[i]+=c[i-1];
    for(int i=n;i>=1;i--)sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1)
    {
        int num=0;
        for(int i=n-k+1;i<=n;i++)y[++num]=i;
        for(int i=1;i<=n;i++)if(sa[i]>k)y[++num]=sa[i]-k;
        for(int i=1;i<=m;i++)c[i]=0;
        for(int i=1;i<=n;i++)c[x[i]]++;
        for(int i=2;i<=m;i++)c[i]+=c[i-1];
        for(int i=n;i>=1;i--)sa[c[x[y[i]]]--]=y[i],y[i]=0;
        swap(x,y);
        x[sa[1]]=1,num=1;
        for(int i=2;i<=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
        if(num==n)break;
        m=num;
    }
}
void get_height(char *s)
{
    int k=0;
    for(int i=1;i<=n;i++)rk[sa[i]]=i;
    height[1]=0;
    for(int i=1;i<=n;i++)
    {
        if(rk[i]==1)continue;
        if(k)k--;
        int j=sa[rk[i]-1];
        while(j+k<=n&&i+k<=n&&s[j+k]==s[i+k])k++;
        height[rk[i]]=k;
    }
}
int main()
{
    scanf(" %s",s+1);
    get_sa(s);
    for(int i=1;i<=n;i++)printf("%d%c",sa[i],i==n?'\n':' ');
    return 0;
}
```



# 数据结构

## RMQ

```c++
template <class T>
struct RMQ {
    vector<vector<T> > rmq;
    // vector<T> rmq[20]; or T[100002][20] if need speed
    //T kInf = numeric_limits<T>::max(); // if need return a value when the interval fake
    void init(const vector<T>& a) { //note:0 base
        int n = (int)a.size(), base = 1, depth = 1;
        while (base < n)
            base <<= 1, ++depth;
        rmq.assign((unsigned)depth, a);
        for (int i = 0; i < depth - 1; ++i)
            for (int j = 0; j < n; ++j) {
                rmq[i + 1][j] = min(rmq[i][j],
                                    rmq[i][min(n - 1, j + (1 << i))]);
            }
    }
    T q(int l, int r) { // [l, r)
        if(l>=r)return 0x3f3f3f3f;
        int dep = 31 - __builtin_clz(r - l); // log(b - a)
        return min(rmq[dep][l], rmq[dep][r - (1 << dep)]);
    }
};
```

## 单调队列

```c++
deque<ll> q;
ll ans[max_n];
//maxque,intervel<=k,ans[i] represents maxvaue ending with i
void solve(ll a[],int k)//a[] is 1 base
{
    while(!q.empty())q.pop_back();
    ll mv;
    for(int i=1;i<=n;i++)
    {
        while(!q.empty()&&a[q.back()]<=a[i])q.pop_back();
        while(!q.empty()&&i-q.front()+1>k)q.pop_front();
        q.push_back(i);
        mv=q.empty()?0:a[q.front()];
        ans[i]=mv;
    }
}
```



##线段树

```c++
struct Seg//min 
{
    int d[1<<20],lazy[1<<20];
    void pushup(int rt)
    {
        d[rt]=min(d[rt<<1],d[rt<<1|1]);
    }
    void pushdown(int rt,int ln=1,int rn=1)
    {
        if(lazy[rt])
        {
            d[rt<<1]+=lazy[rt]*ln;
            d[rt<<1|1]+=lazy[rt]*rn;
            lazy[rt<<1]+=lazy[rt];
            lazy[rt<<1|1]+=lazy[rt];
            lazy[rt]=0;
        }
    }
    void init(int l,int r,int rt)
    {
        d[rt]=INT_MAX,lazy[rt]=0;
        if(l==r)return;
        int mid=l+r>>1;
        init(lson),init(rson);
    }
    void ins(int x,int c,int l,int r,int rt)
    {
        if(l==r)
        {
            d[rt]=c;
            return;
        }
        int mid=l+r>>1;
        pushdown(rt);
        if(x<=mid)ins(x,c,lson);
        else ins(x,c,rson);
        pushup(rt);
    }
    void update(int L,int R,int C,int l,int r,int rt)
    {
        if(l>=L&&r<=R)
        {
            d[rt]+=C;
            lazy[rt]+=C;
            return;
        }
        int mid=l+r>>1;
        pushdown(rt);
        if(mid>=L)update(L,R,C,lson);
        if(mid<R)update(L,R,C,rson);
        pushup(rt);
    }
    int query(int L,int R,int l,int r,int rt)
    {
        if(L>R||L>r||R<l)return INT_MAX;
        if(l>=L&&r<=R)return d[rt];
        int mid=l+r>>1;
        pushdown(rt);
        return min(query(L,R,lson),query(L,R,rson));
    }
};
```



### 1.合并

```c++
int mege(int u,int v)
{
    if(!u)return v;
    if(!v)return u;
    int rt=++SZ;
    sum[rt]=sum[u]+sum[v];
    ls[rt]=mege(ls[u],ls[v]);
    rs[rt]=mege(rs[u],rs[v]);
    return rt;
}
```



## 主席树

```c++
//未离散化，且浪费空间版，但易写（动态开点+合并）
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=200005;
const int inf=0x3f3f3f3f;
int SZ,rt[max_n];
int sum[max_n*40],ls[max_n*40],rs[max_n*40];
int a[max_n];
int n,m;
int mege(int u,int v)
{
    if(!u)return v;
    if(!v)return u;
    int rt=++SZ;
    sum[rt]=sum[u]+sum[v];
    ls[rt]=mege(ls[u],ls[v]);
    rs[rt]=mege(rs[u],rs[v]);
    return rt;
}
void update(int &rt,int l,int r,int x)
{
    if(!rt)rt=++SZ;
    sum[rt]++;
    if(l==r)return;
    int mid=l+r>>1;
    if(x<=mid)update(ls[rt],l,mid,x);
    else update(rs[rt],mid+1,r,x);
}
int query(int L,int R,int l,int r,int k)
{
    if(l==r)return l;
    int mid=l+r>>1;
    if(k<=sum[ls[R]]-sum[ls[L]])return query(ls[L],ls[R],l,mid,k);
    else return k-=sum[ls[R]]-sum[ls[L]],query(rs[L],rs[R],mid+1,r,k);
}
int main()
{
    scanf("%d%d",&n,&m);
    int maxv=-inf,minv=inf;
    for(int i=1;i<=n;i++)scanf("%d",a+i),maxv=max(maxv,a[i]),minv=min(minv,a[i]);
    for(int i=1;i<=n;i++)a[i]+=minv+1;
    maxv+=minv+1;
    for(int i=1;i<=n;i++)
    {
        update(rt[i],1,maxv,a[i]);
        rt[i]=mege(rt[i],rt[i-1]);
    }
    int l,r,k;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d",&l,&r,&k);
        printf("%d\n",query(rt[l-1],rt[r],1,maxv,k)-minv-1);
    }
    return 0;
}
```

```c++
struct MSeg
{
    int SZ,rt[max_n];
    int sz[max_n*40],ls[max_n*40],rs[max_n*40];
    ll sum[max_n*40];
    int h[max_n];
    int tot;
    int getv(int x){return h[x];}
    void build(int &rt,int l,int r)
    {
        if(!rt)rt=++SZ;
        sz[rt]=sum[rt]=0;
        if(l==r)return;
        int mid=l+r>>1;
        build(ls[rt],l,mid);
        build(rs[rt],mid+1,r);
    }
    int update(int rt,int l,int r,int x)
    {
        int o=++SZ;
        ls[o]=ls[rt],rs[o]=rs[rt],sz[o]=sz[rt]+1,sum[o]=sum[rt]+getv(x);
        if(l==r)return o;
        int mid=l+r>>1;
        if(x<=mid)ls[o]=update(ls[o],l,mid,x);
        else rs[o]=update(rs[o],mid+1,r,x);
        return o;
    }
    int query1(int L,int R,int l,int r,int k)
    {
        if(L>=R)return 0;//note
        if(l==r)return getv(l);
        int mid=l+r>>1;
        if(k<=sz[ls[R]]-sz[ls[L]])return query1(ls[L],ls[R],l,mid,k);
        else return k-=sz[ls[R]]-sz[ls[L]],query1(rs[L],rs[R],mid+1,r,k);
    }
    ll query2(int L,int R,int l,int r,int k)
    {
        if(k<=0)return 0;
        if(L>=R)return 0;
        if(l==r)return 1ll*getv(l)*k;
        int mid=l+r>>1;
        if(k<=sz[ls[R]]-sz[ls[L]])return query2(ls[L],ls[R],l,mid,k);
        else return k-=sz[ls[R]]-sz[ls[L]],sum[ls[R]]-sum[ls[L]]+query2(rs[L],rs[R],mid+1,r,k);
    }
    void init(int *a,int n)
    {
        for(int i=1;i<=n;i++)h[i]=a[i];
        sort(h+1,h+n+1);
        tot=unique(h+1,h+n+1)-h-1;
        for(int i=1;i<=n;i++)a[i]=lower_bound(h+1,h+tot+1,a[i])-h;
        build(rt[0],1,tot);
        for(int i=1;i<=n;i++)rt[i]=update(rt[i-1],1,tot,a[i]);
    }
    void ins(int i,int x){rt[i]=update(rt[i-1],1,tot,x);}
    int K_min(int L,int R,int k){return query1(rt[L-1],rt[R],1,tot,k);}
    ll K_sum(int L,int R,int k){return query2(rt[L-1],rt[R],1,tot,k);}
};
```

## 平衡树set

```c++
set<int> s;
int Next(int x,int f)//circle
{
    bool flag=false;
    if(s.find(x)!=s.end())flag=true;
    s.insert(x);
    auto it=s.find(x);
    if(f==0)
    {
        if(it==s.begin())it=s.end();
        it--;
    }
    else
    {
        it++;
        if(it==s.end())it=s.begin();
    }
    if(!flag)s.erase(x);
    return *it;
}
```



## Splay

```c++
struct Node
{
    int ch[2];
    int fa;
    int cnt;
    int val;
    int sz;
    int lazy;
    void init(int x,int ff)
    {
        val=x,fa=ff;
        ch[0]=ch[1]=0;
        cnt=sz=1;
        lazy=0;
    }
};
struct Splay
{
    int rt,total;
    int n,a[max_n];
    Node t[max_n];
    void pushup(int u)
    {
        t[u].sz=t[t[u].ch[0]].sz+t[t[u].ch[1]].sz+t[u].cnt;
    }
    void pushdown(int u)
    {
        if(t[u].lazy)
        {
            swap(t[u].ch[0],t[u].ch[1]);
            t[t[u].ch[0]].lazy^=1;
            t[t[u].ch[1]].lazy^=1;
            t[u].lazy=0;
        }
    }
    void rotate(int x)
    {
        int y=t[x].fa;
        int z=t[y].fa;
        int k=x==t[y].ch[1];
        t[z].ch[y==t[z].ch[1]]=x,t[x].fa=z;
        t[y].ch[k]=t[x].ch[k^1],t[t[x].ch[k^1]].fa=y;
        t[x].ch[k^1]=y,t[y].fa=x;
        pushup(y),pushup(x);
    }
    void splay(int x,int goal)
    {
        while(t[x].fa!=goal)
        {
            int y=t[x].fa;
            int z=t[y].fa;
            if(z!=goal)(x==t[y].ch[1])^(y==t[z].ch[1])?rotate(x):rotate(y);
            rotate(x);
        }
        if(goal==0)rt=x;
    }
    void insert(int x)
    {
        int u=rt,fa=0;
        while(u&&t[u].val!=x)
        {
            fa=u;
            u=t[u].ch[x>t[u].val];
        }
        if(u)t[u].cnt++;
        else
        {
            u=++total;
            if(fa)t[fa].ch[x>t[fa].val]=u;
            t[u].init(x,fa);
        }
        splay(u,0);
    }
    int K_th(int x)
    {
        x++;//because of insert of -inf
        int u=rt;
        if(t[u].sz<x)return inf;//any impossible value
        while(1)
        {
            pushdown(u);
            int ls=t[u].ch[0];
            if(x<=t[ls].sz)u=ls;
            else if(x>t[ls].sz+t[u].cnt)x-=t[ls].sz+t[u].cnt,u=t[u].ch[1];
            else return u;//return pos
        }
    }
    int K_val(int x)
    {
        int u=K_th(x);
        return t[u].val;
    }
    void work(int l,int r)
    {
        l=K_th(l-1);
        r=K_th(r+1);
        splay(l,0),splay(r,l);
        t[t[r].ch[0]].lazy^=1;
    }
    void write(int u)
    {
        pushdown(u);
        if(t[u].ch[0])write(t[u].ch[0]);
        if(t[u].val>=1&&t[u].val<=n)printf("%d ",a[t[u].val]);
        if(t[u].ch[1])write(t[u].ch[1]);
    }
    int find(int x)
    {
        if(!rt)return 1;//if none,x is min
        int u=rt;
        while(t[u].ch[x>t[u].val]&&x!=t[u].val)u=t[u].ch[x>t[u].val];//x may not exist in tree
        splay(u,0);
        return t[t[u].ch[0]].sz+(x>t[u].val?t[u].cnt:0);//because of -inf ,rank--
    }
    int Next(int x,int f)//0:last 1:next
    {
        find(x);
        int u=rt;
        if(t[u].val>x&&f||t[u].val<x&&!f)return u;
        u=t[u].ch[f];
        while(t[u].ch[f^1])u=t[u].ch[f^1];
        return u;//return pos
    }
    int Next_val(int x,int f)
    {
        int u=Next(x,f);
        return t[u].val;
    }
    void Delete(int x)//not truly delete , like create points dynamically
    {
        int last=Next(x,0);
        int next=Next(x,1);
        splay(last,0),splay(next,last);
        int del=t[next].ch[0];
        if(t[del].cnt>1)
        {
            t[del].cnt--;
            splay(del,0);//keep size right
        }
        else t[next].ch[0]=0;
    }
    void init(int* b,int k)
    {
        rt=total=0,n=k;
        insert(-inf),insert(inf);
        for(int i=1;i<=n;i++)insert(i);
        for(int i=1;i<=n;i++)a[i]=b[i];
    }
    void init()
    {
        rt=total=0;
        insert(-inf),insert(inf);
    }
    void print()
    {
        write(rt);
        printf("\n");
    }
}ST;
```

## ODT

```C++
struct Node
{
    ll l,r;
    mutable ll v;
    Node(ll _l,ll _r=-1,ll _v=0):l(_l),r(_r),v(_v){}
    bool operator <(const Node& o)const {return l<o.l;}
};
namespace ODT
{
    ll pow(ll a,ll b,ll mod){a%=mod;ll res=1;while(b){if(b&1)res=res*a%mod;b>>=1;a=a*a%mod;}return res;}
    #define IT set<Node>::iterator
    set<Node> s;
    IT split(ll pos)
    {
        IT it=s.lower_bound(Node(pos));
        if(it!=s.end()&&it->l==pos)return it;
        it--;
        ll l=it->l,r=it->r,v=it->v;
        s.erase(it);
        s.insert(Node(l,pos-1,v));
        return s.insert(Node(pos,r,v)).first;
    }
    void assign_val(ll l,ll r,ll v)
    {
        IT itr=split(r+1),itl=split(l);
        s.erase(itl,itr);
        s.insert(Node(l,r,v));
    }
    void add(ll l,ll r,ll v)
    {
        IT itr=split(r+1),itl=split(l);
        for(;itl!=itr;itl++)itl->v+=v;
    }
    ll sumc(ll l,ll r,ll v)
    {
        IT itr=split(r+1),itl=split(l);
        ll res=0;
        for(;itl!=itr;itl++)if(itl->v==v)res+=itl->r-itl->l+1;
        return res;
    }
    ll K_th(ll l,ll r,ll k)
    {
        vector<pair<ll,ll> > vp;
        IT itr=split(r+1),itl=split(l);
        vp.clear();
        for(;itl!=itr;itl++)vp.push_back(pair<ll,ll>(itl->v,itl->r-itl->l+1));
        sort(vp.begin(),vp.end());
        for(vector<pair<ll,ll> >::iterator it=vp.begin();it!=vp.end();it++)
        {
            k-=it->second;
            if(k<=0)return it->first;
        }
        return -1ll;//k is too big
    }
    ll sum(ll l,ll r)
    {
        IT itr=split(r+1),itl=split(l);
        ll res=0;
        for(;itl!=itr;itl++)res+=(itl->r-itl->l+1)*itl->v;
        return res;
    }
    ll sump(ll l,ll r,ll ex,ll mod)
    {
        IT itr=split(r+1),itl=split(l);
        ll res=0;
        for(;itl!=itr;itl++)res=res+(itl->r-itl->l+1)*pow(itl->v,ex,mod)%mod,res%=mod;//may flow
        return res;
    }
}
```



# Tree

##树的直径，中心

```c++
vector<int> G[max_n];
int n,m;
bool vis[max_n];
int d[max_n];
int par[max_n];
int id1,id2;
vector<P> center;
vector<int> v;
void dfs(int u,int fa,int &id)
{
    d[u]=d[fa]+1;
    if(d[u]>d[id])id=u;
    vis[u]=true;
    par[u]=fa;
    for(auto v:G[u])
    {
        if(v==fa)continue;
        dfs(v,u,id);
    }
}
void treed(int rt)
{
    id1=id2=0;
    dfs(rt,0,id1);
    dfs(id1,0,id2);
    v.clear();
    int now=id2;
    while(now)
    {
        v.push_back(now);
        now=par[now];
    }
    center.push_back(P(v.size(),v[(v.size()-1)/2]));
}
```



## 树链剖分

```c++
#include<bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
typedef long long ll;
const int max_n=100005;
struct edge
{
    int u,v,next;
}G[max_n*2];
int head[max_n];
int total;
void add_edge(int u,int v)
{
    G[total].u=u;
    G[total].v=v;
    G[total].next=head[u];
    head[u]=total++;
}
ll sum[max_n<<2],lazy[max_n<<2];
int n,m,rt;
ll mod;
ll val[max_n];
int cnt;
int sz[max_n],fa[max_n],dep[max_n],son[max_n],id[max_n],tid[max_n],top[max_n];
void dfs1(int u,int f)
{
    sz[u]=1,fa[u]=f,dep[u]=dep[f]+1;
    int v;
    for(int i=head[u];~i;i=G[i].next)
    {
        v=G[i].v;
        if(v==f)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]]<sz[v])son[u]=v;
    }
}
void dfs2(int u,int tp)
{
    id[u]=++cnt,tid[cnt]=u,top[u]=tp;
    if(!son[u])return;
    dfs2(son[u],tp);
    int v;
    for(int i=head[u];~i;i=G[i].next)
    {
        v=G[i].v;
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
void pushup(int rt)
{
    sum[rt]=(sum[rt<<1]+sum[rt<<1|1])%mod;
}
void pushdown(int rt,int ln,int rn)
{
    if(lazy[rt])
    {
        sum[rt<<1]+=1ll*ln*lazy[rt]%mod,sum[rt<<1]%=mod;
        sum[rt<<1|1]+=1ll*rn*lazy[rt]%mod,sum[rt<<1|1]%=mod;
        lazy[rt<<1]+=lazy[rt],lazy[rt<<1]%=mod;
        lazy[rt<<1|1]+=lazy[rt],lazy[rt<<1|1]%=mod;
        lazy[rt]=0;
    }
}
void build(int l,int r,int rt)
{
    sum[rt]=lazy[rt]=0;
    if(l==r)
    {
        sum[rt]=val[tid[l]];
        return;
    }
    int mid=l+r>>1;
    build(lson);
    build(rson);
    pushup(rt);
}
void update(int L,int R,ll C,int l,int r,int rt)
{
    if(l>=L&&r<=R)
    {
        sum[rt]+=1ll*(r-l+1)*C%mod,sum[rt]%=mod;
        lazy[rt]+=C,lazy[rt]%=mod;
        return;
    }
    int mid=l+r>>1;
    pushdown(rt,mid-l+1,r-mid);
    if(mid>=L)update(L,R,C,lson);
    if(mid<R)update(L,R,C,rson);
    pushup(rt);
}
ll query(int L,int R,int l,int r,int rt)
{
    if(l>=L&&r<=R)return sum[rt];
    int mid=l+r>>1;
    pushdown(rt,mid-l+1,r-mid);
    ll res=0;
    if(mid>=L)res+=query(L,R,lson);
    if(mid<R)res+=query(L,R,rson);
    res%=mod;
    return res;
}
void updates(int x,int y,ll C)
{
    ll fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(dep[fx]>=dep[fy])
        {
            update(id[fx],id[x],C,1,n,1);
            x=fa[fx],fx=top[x];
        }
        else
        {
            update(id[fy],id[y],C,1,n,1);
            y=fa[fy],fy=top[y];
        }
    }
    if(id[x]<=id[y])update(id[x],id[y],C,1,n,1);
    else update(id[y],id[x],C,1,n,1);
}
ll querys(int x,int y)
{
    int fx=top[x],fy=top[y];
    ll res=0;
    while(fx!=fy)
    {
        if(dep[fx]>=dep[fy])
        {
            res+=query(id[fx],id[x],1,n,1),res%=mod;
            x=fa[fx],fx=top[x];
        }
        else
        {
            res+=query(id[fy],id[y],1,n,1),res%=mod;
            y=fa[fy],fy=top[y];
        }
    }
    if(id[x]<=id[y])res+=query(id[x],id[y],1,n,1),res%=mod;
    else res+=query(id[y],id[x],1,n,1),res%=mod;
    return res;
}
int main()
{
    scanf("%d%d%d%lld",&n,&m,&rt,&mod);
    ms(head,-1);
    for(int i=1;i<=n;i++)scanf("%lld",val+i);
    int u,v;
    for(int i=1;i<=n-1;i++)
    {
        scanf("%d%d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    dfs1(rt,0);
    dfs2(rt,rt);
    build(1,n,1);
    int opt,x,y;
    ll z;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&opt);
        if(opt==1)
        {
            scanf("%d%d%lld",&x,&y,&z);
            updates(x,y,z%mod);
        }
        else if(opt==2)
        {
            scanf("%d%d",&x,&y);
            printf("%lld\n",querys(x,y));
        }
        else if(opt==3)
        {
            scanf("%d%lld",&x,&z);
            update(id[x],id[x]+sz[x]-1,z%mod,1,n,1);
        }
        else if(opt==4)
        {
            scanf("%d",&x);
            printf("%lld\n",query(id[x],id[x]+sz[x]-1,1,n,1));
        }
    }
    return 0;
}
```





## LCA

### 1.倍增

```c++
int id[max_n],tid[max_n];
int cnt=0;
namespace LCA{
    const int max_log=21;
    int par[max_log][max_n];
    int dep[max_n];
    ll d[max_n];
    void dfs(int u,int fa)
    {
        id[u]=++cnt;
        tid[cnt]=u;
        for(int i=head[u];~i;i=G[i].next)
        {
            int v=G[i].v;
            if(v==fa)continue;
            d[v]=d[u]+G[i].w;
            dep[v]=dep[u]+1;
            par[0][v]=u;
            dfs(v,u);
        }
    }
    void init(int n)
    {
        d[1]=dep[1]=par[0][1]=0;
        dfs(1,0);
        for(int i=1;i<max_log;i++)
        {
            for(int u=1;u<=n;u++)par[i][u]=par[i-1][par[i-1][u]];
        }
    }
    int lca(int u,int v)
    {
        if(dep[u]>dep[v])swap(u,v);
        for(int i=max_log-1;i>=0;i--)if((dep[v]-dep[u])>>i&1)v=par[i][v];
        if(u==v)return u;
        for(int i=max_log-1;i>=0;i--)if(par[i][u]!=par[i][v])u=par[i][u],v=par[i][v];
        return par[0][u];
    }
    ll dis(int u,int v)
    {
        return d[u]+d[v]-2*d[lca(u,v)];
    }
}
```

### 2.targan离线

```c++
#include<bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
const int max_n=500005;
struct edge
{
    int u,v,next;
}G[max_n*2];
int total;
int head[max_n];
void add_edge(int u,int v)
{
    G[total].u=u;
    G[total].v=v;
    G[total].next=head[u];
    head[u]=total++;
}

struct query
{
    int u,v,next,id;
}Q[max_n*2];
int tt;
int h[max_n];
int ans[max_n];
void add_query(int u,int v,int id)
{
    Q[tt].u=u;
    Q[tt].v=v;
    Q[tt].id=id;
    Q[tt].next=h[u];
    h[u]=tt++;
}

int par[max_n];
int findpar(int x){return x==par[x]?x:par[x]=findpar(par[x]);}
void unite(int x,int y){x=findpar(x);y=findpar(y);if(x!=y)par[x]=y;}

bool visit[max_n];
void targan(int u,int fa)
{
    int v;
    for(int i=head[u];~i;i=G[i].next)
    {
        v=G[i].v;
        if(visit[v]||v==fa)continue;
        targan(v,u);
        unite(v,u);//notes 
    }
    visit[u]=true;
    for(int i=h[u];~i;i=Q[i].next)
    {
        v=Q[i].v;
        if(visit[v])ans[Q[i].id]=findpar(v);
    }
}
int n,q,s;
void init(){for(int i=0;i<=n;i++)par[i]=i;total=tt=0;ms(head,-1);ms(h,-1);ms(visit,0);}

int u,v;
int main()
{
    scanf("%d%d%d",&n,&q,&s);
    init();
    for(int i=0;i<n-1;i++)
    {
        scanf("%d%d",&u,&v);
        add_edge(u,v);
        add_edge(v,u);
    }
    for(int i=0;i<q;i++)
    {
        scanf("%d%d",&u,&v);
        add_query(u,v,i);
        add_query(v,u,i);
    }
    targan(s,-1);
    for(int i=0;i<q;i++)printf("%d\n",ans[i]);
    return 0;
}
```



## dsu on tree

```c++
/*
每个点会被轻儿子调用，复杂度为logn,对于调用他的重儿子，一条重链上只会有一个，复杂度为logn
所以综合复杂度为nlogn
*/
int n;
vector<int> G[max_n];
int color[max_n];
int cnt[max_n];
int sz[max_n];
bool big[max_n];
ll ans[max_n];
void dfs1(int u,int fa)
{
    sz[u]=1;
    for(auto v:G[u])
    {
        if(v==fa)continue;
        dfs1(v,u);
        sz[u]+=sz[v];//SB fault
    }
}
ll maxs,maxc;
void add(int u,int fa,int val)
{
    /*cnt[color[u]]+=val;
    if(cnt[color[u]]>maxc)maxc=cnt[color[u]],maxs=color[u];
    else if(cnt[color[u]]==maxc)maxs+=color[u];*/
    //do something you need
    for(auto v:G[u])
    {
        if(v==fa||big[v])continue;
        add(v,u,val);
    }
}
void dfs(int u,int fa,bool keep)
{
    int mx=-1,son=-1;
    for(auto v:G[u])
    {
        if(v==fa)continue;
        if(sz[v]>mx)mx=sz[v],son=v;
    }
    for(auto v:G[u])
    {
        if(v==fa||v==son)continue;
        dfs(v,u,0);
    }
    if(~son)dfs(son,u,1),big[son]=1;
    add(u,fa,1);
    //ans[u]=maxs;
    //now do something you want
    if(~son)big[son]=0;
    if(!keep)add(u,fa,-1),maxs=maxc=0;
}
```



# 图论

## 最短路

### 1.dijkstra

```c++
typedef pair<ll,int> P;
const ll inf=0x3f3f3f3f3f3f3f3f;


struct edge
{
    int u,v,next;
    ll w;
}G[max_n*2];
int head[max_n];
int tot;
void add_edge(int u,int v,ll w=1)
{
    G[tot].u=u;
    G[tot].v=v;
    G[tot].w=w;
    G[tot].next=head[u];
    head[u]=tot++;
}
void init()
{
    memset(head,-1,sizeof(head));
    tot=0;
}

ll d[max_n];
void dijkstra(int s)
{
    priority_queue<P,vector<P>,greater<P> > q;
    memset(d,0x3f,sizeof(d));
    d[s]=0;
    q.push(P(0,s));
    P p;
    int u,v;
    while(!q.empty())
    {
        p=q.top();
        q.pop();
        u=p.second;
        if(d[u]<p.first)continue;
        for(int i=head[u];~i;i=G[i].next)
        {
            v=G[i].v;
            if(d[v]>d[u]+G[i].w)
            {
                d[v]=d[u]+G[i].w;
                q.push(P(d[v],v));
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    int u,v;
    ll w;
    ms(head,-1);
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%lld",&u,&v,&w);
        add_edge(u,v,w);
        add_edge(v,u,w);
    }
    dijkstra(1);
    return 0;
}
```

## 最小生成树

### Kruskal

```c++
/*
1.定义路径距离为路径上的边的最大权值，则涉及最短路问题等价于其图的最小生成树考虑
2.最小生成树的权值序列排序后字典序最小
3.定义路径距离为路径上的边的最大权值，则对任意一个点集，点集中的任意一点距离点集中的其他点的最远距离均相等，值等于任意一点距离点集中的点的最远距离
*/
struct edge
{
    int u,v,w;
    bool operator < (edge e){return w<e.w;}
}es[max_n];
int par[max_n];
int findpar(int x){return x==par[x]?x:par[x]=findpar(par[x]);}
bool same(int x,int y){x=findpar(x),y=findpar(y);return x==y;}
void unite(int x,int y){x=findpar(x),y=findpar(y);if(x!=y)par[x]=y;}
int n,m;
void Kruskal()
{
    for(int i=1;i<=n;i++)par[i]=i;
    sort(es+1,es+m+1);
    for(int i=1;i<=m;i++)
    {
        edge e=es[i];
        int u=e.u,v=e.v;
        u=findpar(u),v=findpar(v);
        if(u==v)continue;
        par[u]=v;
    }
}
```

## 网络流

### 最大流SAP

```c++
 struct Edge{
    int v,cap,next;
}edge[maxn];
int n,m,ne,nv;
int head[maxn],pre[maxn],level[maxn],gap[maxn],cur[maxn];
void addEdge(int u,int v,int cap){
    edge[ne].v=v;
    edge[ne].cap=cap;
    edge[ne].next=head[u];
    head[u]=ne++;
 
    edge[ne].v=u;
    edge[ne].cap=0;
    edge[ne].next=head[v];
    head[v]=ne++;
}
void bfs(int vt){
    memset(level,-1,sizeof(level));
    memset(gap,0,sizeof(gap));
    level[vt]=0;
    gap[level[vt]]++;
    queue<int>q;
    q.push(vt);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=edge[i].next){
            int v=edge[i].v;
            if(level[v]!=-1){
                continue;
            }
            level[v]=level[u]+1;
            gap[level[v]]++;
            q.push(v);
        }
    }
}
int SAP(int vs,int vt){
    bfs(vt);
    memset(pre,-1,sizeof(pre));
    memcpy(cur,head,sizeof(head));
    pre[vs]=vs;
    gap[0]=nv;
    int u=vs,max_flow=0,flow=inf;
    while(level[vs]<nv){
        bool flag=false;
        for(int &i=cur[u];i!=-1;i=edge[i].next){
            int v=edge[i].v;
            if(edge[i].cap&&level[u]==level[v]+1){
                flag=true;
                pre[v]=u;
                u=v;
                flow=min(flow,edge[i].cap);
                if(v==vt){
                    max_flow+=flow;
                    for(u=pre[v];v!=vs;v=u,u=pre[u]){
                        edge[cur[u]].cap-=flow;
                        edge[cur[u]^1].cap+=flow;
                    }
                    flow=inf;
                }
                break;
            }
        }
        if(flag){
            continue;
        }
        int ml=nv;
        for(int i=head[u];i!=-1;i=edge[i].next){
            int v=edge[i].v;
            if(edge[i].cap&&level[v]<ml){
                ml=level[v];
                cur[u]=i;
            }
        }
        if(--gap[level[u]]==0){
            break;
        }
        level[u]=ml+1;
        gap[level[u]]++;
        u=pre[u];
    }
    return max_flow;
}
int main(){
    while(~scanf("%d%d",&m,&nv)){
        memset(head,-1,sizeof(head));
        ne=0;
        for(int i=1;i<=m;i++){
            int u,v,cap;
            scanf("%d%d%d",&u,&v,&cap);
            addEdge(u,v,cap);
        }
        printf("%d\n",SAP(1,nv));
    }
    return 0;
}

```

### 最小费用最大流

```c++
struct edge{
	int to,next,cap,flow,cost;
}e[max_m*2];
int head[max_n],tot;
int pre[max_n],dis[max_n];
bool vis[max_n];
void init(){
	tot = 1;
	memset(head,0,sizeof(head));
}
void addedge(int u,int v,int cap,int cost){
	e[++tot].to = v;
	e[tot].cap = cap;
	e[tot].flow = 0;
	e[tot].cost = cost;
	e[tot].next = head[u];
	head[u] = tot;
	e[++tot].to = u;
	e[tot].cap = 0;
	e[tot].flow = 0;
	e[tot].cost = -cost;
	e[tot].next = head[v];
	head[v] = tot;
}
int spfa(int s,int t){
	queue<int>q;
	for(int i = 0;i<=t;i++){
		dis[i] = inf;
		vis[i] = 0;
		pre[i] = -1;
	}
	dis[s] = 0;
	vis[s] = 1;
	q.push(s);
	while(!q.empty()){
		int u = q.front();q.pop();
		vis[u] = 0;
		for(int i = head[u];i;i = e[i].next){
			int v = e[i].to;
			if(e[i].cap > e[i].flow && dis[v] > dis[u] + e[i].cost){
				dis[v] = dis[u] + e[i].cost;
				pre[v] = i;
				if(!vis[v]){
					vis[v] = 1;
					q.push(v);
				}
			}
		}
	}
	return pre[t] != -1;
}
int MCMF(int s,int t,int &cost){
	int flow = 0;
	cost = 0;
	while(spfa(s,t)){
		int Min = inf;
		for(int i = pre[t];i!=-1;i=pre[e[i^1].to]){
			if(Min > e[i].cap - e[i].flow)
				Min = e[i].cap - e[i].flow;
		}
		for(int i = pre[t];i!=-1;i=pre[e[i^1].to]){
			e[i].flow += Min;
			e[i^1].flow -= Min;
			cost += e[i].cost * Min;
		}
		flow += Min;
	}
	return flow;
}
```

## 二分图匹配

```c++
int match[max_n*2];
bool used[max_n*2];
bool dfs(int u)
{
    used[u]=true;
    for(int i=head[u];~i;i=G[i].next)
    {
        int v=G[i].v,w=match[v];
        if(w<0||!used[w]&&dfs(w))
        {
            match[u]=v;
            match[v]=u;
            return true;
        }
    }
    return false;
}
```





