# 图论

[TOC]

## LCA

### 倍增

```c++
int head[maxn], to[maxn * 2], nxt[maxn * 2], d[maxn * 2], tot;
void add(int x, int y, int w) {
    to[++tot] = y; nxt[tot] = head[x]; d[tot] = w; head[x] = tot;
}

int n, m;

int dp[maxn][20], dep[maxn], dis[maxn];
void dfs(int u, int fa) {
    dp[u][0] = fa; dep[u] = dep[fa] + 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == fa) continue;
        dis[v] = dis[u] + d[i];
        dfs(v, u);
    }
}
void init() {
    ms(dp, 0); dep[0] = dis[0] = 0;
    dfs(1, 0); 
    for (int j = 1; j < 20; j++) 
        for (int i = 1; i <= n; i++) 
            dp[i][j] = dp[dp[i][j - 1]][j - 1];
}
int lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    int tmp = dep[x] - dep[y];
    for (int i = 0; tmp; i++, tmp >>= 1)
        if (tmp & 1) x = dp[x][i];
    if (x == y) return x;
    for (int i = 19; i >= 0; i--) {
        if (dp[x][i] != dp[y][i]) {
            x = dp[x][i]; y = dp[y][i];
        }
    }
    return dp[x][0];
}
```

### 树链剖分

```c++
namespace hld {
    struct edge{int to, nxt, w;}g[maxn];
    int head[maxn], tot = 0; 
    void add(int x, int y, int w) {
        g[++tot] = {y, head[x], w}; head[x] = tot;
    }

    void init() {
        ms(son, 0); dfs(1, 1, 0); dfs(1, 1);
    }

    int siz[maxn], dep[maxn], fa[maxn], son[maxn], top[maxn];
    void dfs(int p, int d, int old) {
        dep[p] = d; fa[p] = old; siz[p] = 1;
        int m = -1;
        for (int i = head[p]; i; i = g[i].nxt) {
            int v = g[i].to;
            if (v == fa[p]) continue;
            dfs(v, d + 1, p);
            siz[p] += siz[v];
            if (siz[v] > m) son[p] = v, m = siz[v];
        }
    }
    void dfs(int p, int tp) {
        top[p] = tp;
        if (!son[p]) return;
        dfs(son[p], tp);
        for (int i = head[p]; i; i = g[i].nxt) {
            int v = g[i].to;
            if (v == fa[p] || v == son[p]) continue;
            dfs(v, v);
        }
    }

    int qlca(int x, int y) {
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) swap(x, y);
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) swap(x, y);
        return x;
    }
}
```

### 维护联通子图距离

```c++
const int mod = 998244353;
const int maxn = 100000 + 5;

vector<PII> edge[maxn];
int n, q, dfn[maxn], id[maxn], tot;

namespace LCA {
    int fa[maxn][20], dep[maxn];
    ll dis[maxn];
    void dfs(int u, int f) {
        dfn[u] = ++tot; id[tot] = u;
        fa[u][0] = f; dep[u] = dep[f] + 1;
        for (auto& x: edge[u]) {
            int v = x.first;
            if (v == f) continue;
            dis[v] = dis[u] + x.second;
            dfs(v, u);
        }
    }
    void init() {
        dfs(1, 0);
        for (int j = 1; j < 20; j++) for (int i = 1; i <= n; i++) 
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
    }
    int qlca(int u, int v) {
        if (dep[u] < dep[v]) swap(u, v);
        int tmp = dep[u] - dep[v];
        for (int i = 0; tmp; i++, tmp >>= 1) if (tmp & 1) u = fa[u][i];
        if (u == v) return u;
        for (int i = 19; i >= 0; i--) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
        return fa[u][0];
    }
    ll qdis(int u, int v) {
        return dis[u] + dis[v] - 2ll * dis[qlca(u, v)];
    }
}

int main(){
    scanf("%d", &n);
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        edge[u].push_back({v, w});
        edge[v].push_back({u, w});
    } LCA::init();
    scanf("%d", &q);
    char op[3]; int x; ll ans = 0; set<int> st;
    while (q--) {
        scanf("%s", op);
        if (op[0] == '+') {
            scanf("%d", &x);
            st.insert(dfn[x]);
            auto it = st.find(dfn[x]);
            auto l = it, r = it; r++;
            if (l == st.begin()) l = --st.end();
            else l--;
            if (r == st.end()) r = st.begin();
            ans += LCA::qdis(id[*l], x) + LCA::qdis(x, id[*r]) - LCA::qdis(id[*l], id[*r]);
        }
        if (op[0] == '-') {
            scanf("%d", &x);
            auto it = st.find(dfn[x]);
            auto l = it, r = it; r++;
            if (l == st.begin()) l = --st.end();
            else l--;
            if (r == st.end()) r = st.begin();
            ans -= LCA::qdis(id[*l], x) + LCA::qdis(x, id[*r]) - LCA::qdis(id[*l], id[*r]);
            st.erase(it);
        }
        if (op[0] == '?') {
            printf("%lld\n", ans / 2);
        }
    }
    return 0;
}
```

## Dijkstra

```c++
struct edge{int to, nxt, d;}f[maxn * 2];
int head[maxn], tot;
void add(int x, int y, int d) {
    f[++tot] = {y, head[x], d};
    head[x] = tot;
}

bool vis[maxn]; ll dis[maxn];
struct node{
    int to, d;
    bool operator< (const node& b)const{
        return d > b.d;
    }
};

int dijkstra(int s) {
    for (int i = 0; i <= n; i++) 
    		dis[i] = 1ll << 60;
  	ms(vis, 0); dis[s] = 0;
    priority_queue<node> q;
    q.push({1, 0}); 
    while (!q.empty()) {
        node t = q.top(); q.pop();
        if (vis[t.to]) continue;
        vis[t.to] = 1;
        for (int i = head[t.to]; i; i = f[i].nxt) {
            int v = f[i].to;
            if (vis[v]) continue;
            if (dis[v] > dis[t.to] + f[i].d) {
                dis[v] = dis[t.to] + f[i].d;
                q.push({v, dis[v]});
            }
        }
    }
    int ans = 1 << 30;
    for (int i = 0; i <= k; i++) {
        ans = min(ans, dis[i][n]);
    }
    return ans;
}
```

## SPFA

一般用于计算差分约束

最大值 $x-y\le k$  从y到x权值为k的边 求最短路 注意$x-y<k$   转化成 $x-y\le k-1$ 
最小值 $x-y\ge k$  从y到x权值为k的边 求最长路 
注意设置的源点要能到图里所有点！

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e4+5,M=1e5+5;
const ll inf=1e18;
int T,n,m;
struct edge{
	int to,l,nxt;
}e[M*2];
int head[N],cnt;

void init(){
	memset(head,-1,sizeof(head));
	cnt=0;
}

void add_edge(int u, int v, int l){
	e[cnt].to=v;
	e[cnt].l=l;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}

queue<int> que;
ll dis[N];
int counts[N];
bool vis[N];

int spfa(int s){
	for(int i=0; i<=n; i++){
		vis[i]=0;
		counts[i]=0;
		dis[i]=inf;//最大值模式，最小值改-inf
	}
	while(!que.empty()) que.pop();
	dis[s]=0;
	que.push(s);
	int u,v,l;
	while(!que.empty()){
		u=que.front();
		que.pop();
		vis[u]=0;
		for(int i=head[u]; i!=-1; i=e[i].nxt){
			v=e[i].to;
			l=e[i].l;
			if(dis[u]+l<dis[v]){//最大值模式，最小值改减号
				dis[v]=dis[u]+l;
				if(vis[v]) continue;
				vis[v]=1;
				counts[v]++;
				que.push(v);
				if(counts[v]==n) return 1;
			}
		}
	}
	return 0;
}
//最大值 x-y<=k 从y到x权值为k的边 求最短路 注意x-y<k =>x-y<=k-1 
//最小值 x-y>=k 从y到x权值为k的边 求最长路 
//设置的源点要能到图里所有点！
int main(){
    scanf("%d",&T);
    int cas=1;
    while(T--){
        int x;
        scanf("%d%d%d",&n,&m,&x);
	    init();
        while(m--){
            int a,b,c,d;
            scanf("%d%d%d%d",&a,&b,&c,&d);
            if(a==b&&c==d){
                add_edge(a,c,x);add_edge(c,a,-x);
                //add_edge(c,a,-x);add_edge(a,c,x);
            }
            else if(a==b&&d==c+1){
                add_edge(a,c,x-1);add_edge(c+1,a,-x-1);
                //add_edge(c,a,-x+1);add_edge(a,c+1,x+1);
            }
            else if(b==a+1&&c==d){
                add_edge(a+1,c,x-1);add_edge(c,a,-x-1);
                //add_edge(c,a+1,-x+1);add_edge(a,c,x+1);
            }
            else {
                add_edge(a+1,c,x-2);add_edge(c+1,a,-x-2);
                //add_edge(c,a+1,-x+2);add_edge(a,c+1,x+2);
            }
        }
        for(int i=1;i<=n-1;i++){
            add_edge(i+1,i,-1);
            //add_edge(i,i+1,1);
        }
        printf("Case #%d: ",cas++);
        bool f=!spfa(n);
        if(!f)printf("IMPOSSIBLE\n");
        else{
            for(int i=1;i<=n;i++)if(dis[i]==inf)dis[i]=0;
            for(int i=2;i<=n;i++)if(dis[i]-dis[i-1]>2000000000)f=false;
            if(!f)printf("IMPOSSIBLE\n");
            else {
                for(int i=1;i<n;i++)printf("%lld%c",dis[i+1]-dis[i],i==n-1?'\n':' ');
            }
        }
    }
	return 0;
}
```



## K短路

```c++
int n, m, s, e, k, t;
vector<PII> edge[maxn], edge1[maxn];

int vis[maxn], dis[maxn];
int dijkstra(int beg = 1) {
    ms(vis, 0);
    for (int i = 1; i <= n; i++) dis[i] = inf;
    dis[beg] = 0; 
    priority_queue<PII, vector<PII>, greater<PII> > q; q.emplace(0, beg);
    while (!q.empty()) {
        PII t = q.top(); q.pop();
        int u = t.second;
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &x : edge1[u]) {
            int v = x.first;
            if (vis[v]) continue;
            if (dis[v] > dis[u] + x.second) {
                dis[v] = dis[u] + x.second;
                q.emplace(dis[v], v);
            }
        }
    }
    return 0;
}

struct node{
    int to, f, g;
    node() {}
    node(int tt, int ff, int gg): to(tt), f(ff), g(gg) {}
    bool operator < (const node &t) const{
        if(t.f == f) return t.g < g;
        return t.f < f;
    }
};

int astar() {
    priority_queue<node> q; q.emplace(s, dis[s], 0);
    int cnt = 0;
    if (dis[s] == inf) return inf;
    while (!q.empty()) {
        node t = q.top(); q.pop();
        if (t.to == e) cnt++;
        if (cnt == k) return t.g;
        for (auto &x : edge[t.to]) {
            q.emplace(x.first, t.g + x.second + dis[x.first], t.g + x.second);
        }
    }
    return inf;
}

int main() {
    while (~scanf("%d%d", &n, &m)) {
        scanf("%d%d%d%d", &s, &e, &k, &t);
        for (int i = 0; i <= n; i++) edge[i].clear(), edge1[i].clear();
        while (m--) {
            int u, v, w; scanf("%d%d%d", &u, &v, &w);
            edge[u].emplace_back(v, w);
            edge1[v].emplace_back(u, w);
        }
        dijkstra(e);
        int ans = astar();
        if (ans <= t) puts("yareyaredawa");
        else puts("Whitesnake!");
    }
    return 0;
}
```

## Kruskal

```c++
struct edge{char x, y; int d;};
bool cmp(const edge& a, const edge& b) {
    return a.d < b.d;
}
vector<edge> v;

int n, pre[maxn];
void init() {
    for (int i = 0; i < maxn; i++) pre[i] = i;
}
int find(int x) {return x == pre[x] ? x : pre[x] = find(pre[x]);}
void join(int x, int y) {
    x = find(x), y = find(y);
    pre[x] = y;
}
int kruskal() {
    sort(v.begin(), v.end(), cmp);
    int ans = 0;
    for (int i = 0, a, b; i < v.size(); i++) {
        a = find(v[i].x - 'A'), b = find(v[i].y - 'A');
        if (a == b) continue;
        join(a, b); ans += v[i].d;
    }   
    return ans;
}
```

## 斯坦纳树

```c++
const ll inf = 1ll << 60;
const int mod = 998244353;
const int maxn = 1010 + 5;

bool vis[1 << 6][maxn];
struct node{
    int to; ll d;
    bool operator< (const node& b)const{
        return d > b.d;
    }
};

vector<PII> edge[maxn];
int n, m, p, a[maxn];
ll dp[1 << 6][maxn];

int main() {
    while (scanf("%d%d%d", &n, &m, &p) == 3) {
        ms(vis, 0);
        for (int i = 0; i <= n + m; i++) edge[i].clear();
        for (int i = 1; i <= n + m; i++) {
            scanf("%d", a + i);
            edge[0].push_back({i, a[i]});
            edge[i].push_back({0, a[i]});
        }
        for (int i = 1, u, v, w; i <= p; i++) {
            scanf("%d%d%d", &u, &v, &w);
            edge[u].push_back({v, w});
            edge[v].push_back({u, w});
        }
        int ss = 1 << (n + 1);
        for (int s = 1; s < ss; s++) for (int u = 0; u <= n + m; u++) dp[s][u] = inf;
        for (int u = 0; u <= n; u++) dp[1 << u][u] = 0;
        priority_queue<node> pq;
        for (int s = 1; s < ss; s++) {
            for (int u = 0; u <= n + m; u++) {
                for (int t = s; t; t = (t - 1) & s) {
                    dp[s][u] = min(dp[s][u], dp[t][u] + dp[s ^ t][u]);
                }
            }
            for (int u = 0; u <= n + m; u++) if (dp[s][u] != inf) pq.push({u, dp[s][u]});
            while (!pq.empty()) {
                node tp = pq.top(); pq.pop();
                if (vis[s][tp.to]) continue;
                vis[s][tp.to] = 1;
                for (auto& x: edge[tp.to]) {
                    if (dp[s][x.first] > dp[s][tp.to] + x.second) {
                        dp[s][x.first] = dp[s][tp.to] + x.second;
                        pq.push({x.first, dp[s][x.first]});
                    }
                }
            }
        }
        ll ans = inf;
        for (int i = 0; i <= n + m; i++) ans = min(ans, dp[ss - 1][i]);
        printf("%lld\n", ans);
    }
    return 0;
}
```

## 拓扑排序

```c++
vector<int> edge[maxn], v;
int ind[maxn], n, m;

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        ms(ind, 0); v.clear(); for (int i = 1; i <= n; i++) edge[i].clear();
        while (m--) {
            int x, y; scanf("%d%d", &x, &y);
            edge[y].push_back(x); ind[x]++;
        }
        priority_queue<int, vector<int>, less<int> > pq;
        for (int i = 1; i <= n; i++) if (!ind[i]) pq.push(i);
        while (!pq.empty()) {
            int t = pq.top(); pq.pop();
            v.push_back(t);
            for (int i = 0; i < edge[t].size(); i++) {
                ind[edge[t][i]]--;
                if (!ind[edge[t][i]]) pq.push(edge[t][i]);
            }
        }
        reverse(v.begin(), v.end());
        for (int i = 0; i < v.size(); i++) {
            if (i) putchar(' ');
            printf("%d", v[i]);
        }
        puts("");
    }
    return 0;
}
```

## Hierholzer

```c++
void dfs(int u) {
    for (int i = 0; i < edge[u].size(); i++) {
        int v = edge[u][i];
        if (vis[u][i]) continue;
        vis[u][i] = 1;
        dfs(v);
    }
    ans.push_back(u); // 逆序存放答案
}
```

## 二分图

### 概念

1. 最小顶点覆盖 = 最大匹配数：选择最少的顶点来覆盖所有的边。
2. 最大独立集 = 顶点数 - 最小顶点覆盖：选出最多的顶点，使得这些顶点两两不相邻。
3. 最大团 = 补图最大独立集：选出最多的顶点，使得这些顶点两两之间都有边。

### 匈牙利算法

```c++
int line[maxn][maxn], k, m, n, vis[maxn], nxt[maxn];

int find(int p) {
    for (int i = 1; i <= n; i++) {
        if (line[p][i] && !vis[i]) {
            vis[i] = 1;
            if (!nxt[i] || find(nxt[i])) {
                nxt[i] = p;
                return true;
            }
        }
    }
    return false;
}
int match() {
    int sum = 0;
    for (int i = 1; i <= m; i++) {
        ms(vis, 0);
        if (find(i)) sum++;
    }
    return sum;
}
```

### HK 算法

```c++
struct HK {
    int n, ans;
    int dx[maxn], dy[maxn];
    int linkx[maxn], linky[maxn];
    int head[maxn], to[maxm], nxt[maxm], ecnt;
 
    void clear(int N) {
        n = N; ecnt = ans = 0;
        ms(linkx, 0xff); ms(linky, 0xff);
    }
    void add(int u, int v) {
        to[++ecnt] = v; nxt[ecnt] = head[u]; head[u] = ecnt;
        if(linkx[u] == -1 && linky[v] == -1) {
            linkx[u] = v;
            linky[v] = u;
            ans++;
        }
    }
    bool bfs() {
        bool res = 0;
        static int q[maxn], l, r;
 
        ms(dx, 0); ms(dy, 0);
        l = r = 0;
        for (int i = 0; i < n; i++) 
            if(linkx[i] == -1) q[r++] = i;
 
        while(l < r) {
            int x = q[l++];
            for (int i = head[x]; i; i = nxt[i]) {
                if(!dy[to[i]]) {
                    dy[to[i]] = dx[x] + 1;
                    if(linky[to[i]] == -1) res = 1;
                    else dx[q[r++] = linky[to[i]]] = dy[to[i]] + 1;
                }
            }
        }
        return res;
    }
    bool dfs(int u) {
        for (int i = head[u]; i; i = nxt[i]) {
            if(dx[u] + 1 == dy[to[i]]) {
                dy[to[i]] = 0;
                if(linky[to[i]] == -1 || dfs(linky[to[i]])) {
                    linky[to[i]] = u;
                    linkx[u] = to[i];
                    return true;
                }
            }
        }
        return false;
    }
    int match() {
        // 0 ~ n
        while(bfs()) {
            for (int i = 0; i < n; i++) {
                if(linkx[i] == -1) ans += dfs(i);
            }
        }
        return ans;
    }

    bool visx[maxn], visy[maxn];
    void mark(int u) {
        if (visx[u]) return ;
        visx[u] = true;
        for (int i = head[u]; i; i = nxt[i]) {
            if (to[i] == linkx[u]) continue;
            visy[to[i]] = true;
            assert(linky[to[i]] != -1);
            mark(linky[to[i]]);
        }
    }
} f;
```

#### 独立集 / 点覆盖方案

```c++
for (int i = 0; i < (int)bag[0].size(); i++) {
    if (f.linkx[i] == -1) {
        f.mark(i);
    }
}
vector<int> plan;
// 独立集
for (int i = 0; i < (int)bag[0].size(); i++) if (f.visx[i]) plan.push_back(bag[0][i]);
for (int i = 0; i < (int)bag[1].size(); i++) if (!f.visy[i]) plan.push_back(bag[1][i]);
```

### KM算法

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105;
const float INF=1e5;
float dbx[MAXN],dby[MAXN],slack[MAXN],C[MAXN][MAXN];
int linky[MAXN],pre[MAXN];
bool vis[MAXN];
int nx,ny;

void bfs(int k)
{
	int px,py=0,yy=0;
	float d;
	memset(pre,0,sizeof pre);
	for(int i=0; i<=ny; i++) slack[i]=INF;
	linky[py]=k;

	do
	{
		px=linky[py],d=INF,vis[py]=1;
		for(int i=1;i<=ny;i++)
			if(vis[i]==0)
			{
				if(slack[i]>dbx[px]+dby[i]-C[px][i])
					slack[i]=dbx[px]+dby[i]-C[px][i],pre[i]=py;
				if(slack[i]<d) d=slack[i],yy=i;
			}
		for(int i=0;i<=ny;i++)
			if(vis[i]) dbx[linky[i]]-=d,dby[i]+=d;
			else slack[i]-=d;
		py=yy;
	}while(linky[py]!=0);
	while(py) linky[py]=linky[pre[py]],py=pre[py];
}
float km()
{
	memset(dbx,0,sizeof dbx);
	memset(dby,0,sizeof dby);
	memset(linky,0,sizeof linky);
	for(int i=1;i<=nx;i++)
		memset(vis,0,sizeof vis),bfs(i);
	float ans=0;
	for(int i=1; i<=ny; i++){
		if(linky[i]) ans+=dbx[linky[i]]+dby[i];
	}
	return ans;
}


int main(){
	int n;
	scanf("%d",&n);
	nx=ny=n;
	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){
			scanf("%f",&C[i][j]);
			C[i][j]=log(C[i][j]);
		}
	}
	km();
	for(int i=1; i<=n; i++){
		printf("%d%c",linky[i],i==n?'\n':' ');
	}
}
//https://codeforces.com/gym/102346/problem/G
```

## 网络流

### 最大权闭合子图

闭合子图：子图中每个点的出边指向的结点也在子图内。

有 $n$ 个商品，$m$ 个物资，生产一个商品需要某些物资，商品有价值，物资有费用（出现时只算一次），求最大利益。

建一个超级源点 $S$ 指向所有商品，容量为商品权值，建一个超级汇点 $T$，所有物资指向 $T$，容量为物资费用。

对于依赖关系，建一条容量为无穷大的边。

最大权闭合子图为商品正权值之和减去最大流（最小割）。

最大权闭合子图为最后所有与超级源点相连的点。

### Dinic

```c++
int to[maxn * 2], nxt[maxn * 2], flow[maxn * 2], head[maxn], tot = 1;
void add(int x, int y, int w) {
    to[++tot] = y; nxt[tot] = head[x]; flow[tot] = w;
    head[x] = tot;
    to[++tot] = x; nxt[tot] = head[y]; flow[tot] = 0;
    head[y] = tot;
}
void init() {
    ms(head, 0); tot = 1;
}

int dep[maxn], tag;
int bfs(int s, int t) {
    queue<int> q;
    ms(dep, 0);
    dep[s] = 1; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (flow[i] && dep[v] == 0) {
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }
    return dep[t];
}
int dfs(int u, int fl) {
    if (u == tag) return fl;
    int f = 0;
    for (int i = head[u]; i && fl; i = nxt[i]) {
        int v = to[i];
        if (dep[v] == dep[u] + 1 && flow[i]) {
            int x = dfs(v, min(fl, flow[i]));
            flow[i] -= x; flow[i ^ 1] += x;
            fl -= x; f += x;
        }
    }
    if (!f) dep[u] = -2;
    return f;
}
int dinic(int s, int t) {
    int ans = 0; tag = t;
    while (bfs(s, t)) {
        ans += dfs(s, inf);
    }
    return ans;
}
```

### SAP

```C++
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;

const int maxn = 100010;//点数的最大值
const int maxm = 400010;//边数的最大值
struct edge {
	int to, next, cap, flow;
}e[maxm];
int tol;
int head[maxn];
int gap[maxn], dep[maxn], cur[maxn];
void init() {
	tol = 0;
	memset(head, -1, sizeof(head));
}
void addedge(int u, int v, int w, int rw = 0) {
	e[tol].to = v; e[tol].cap = w; e[tol].flow = 0;
	e[tol].next = head[u]; head[u] = tol++;
	e[tol].to = u; e[tol].cap = rw; e[tol].flow = 0;
	e[tol].next = head[v]; head[v] = tol++;
}
int Q[maxn];
void bfs(int s, int t) {
	memset(dep, -1, sizeof(dep));
	memset(gap, 0, sizeof(gap));
	gap[0] = 1;
	int front = 0, rear = 0;
	dep[t] = 0;
	Q[rear++] = t;
	while (front != rear) {
		int u = Q[front++];
		for (int i = head[u]; i != -1; i = e[i].next) {
			int v = e[i].to;
			if (dep[v] != -1)continue;
			Q[rear++] = v;
			dep[v] = dep[u] + 1;
			gap[dep[v]]++;
		}
	}
}
int S[maxn];
int sap(int s, int t, int N) {
	bfs(s, t);
	memcpy(cur, head, sizeof(head));
	int top = 0;
	int u = s;
	int ans = 0;
	while (dep[s] < N) {
		if (u == t) {
			int Min = INF;
			int inser;
			for (int i = 0; i < top; i++)
				if (Min > e[S[i]].cap - e[S[i]].flow) {
					Min = e[S[i]].cap - e[S[i]].flow;
					inser = i;
				}
			for (int i = 0; i < top; i++) {
				e[S[i]].flow += Min;
				e[S[i] ^ 1].flow -= Min;
			}
			ans += Min;
			top = inser;
			u = e[S[top] ^ 1].to;
			continue;
		}
		bool flag = false;
		int v;
		for (int i = cur[u]; i != -1; i = e[i].next) {
			v = e[i].to;
			if (e[i].cap - e[i].flow && dep[v] + 1 == dep[u]) {
				flag = true;
				cur[u] = i;
				break;
			}
		}
		if (flag) {
			S[top++] = cur[u];
			u = v;
			continue;
		}
		int Min = N;
		for (int i = head[u]; i != -1; i = e[i].next)
			if (e[i].cap - e[i].flow && dep[e[i].to] < Min) {
				Min = dep[e[i].to];
				cur[u] = i;
			}
		gap[dep[u]]--;
		if (!gap[dep[u]])return ans;
		dep[u] = Min + 1;
		gap[dep[u]]++;
		if (u != s) u = e[S[--top] ^ 1].to;
	}
	return ans;
}

int main(){
	int T;
	scanf("%d",&T);
	int n,m,u,v,w,s,t,minx,maxx,x,y;
	while(T--){
		scanf("%d%d",&n,&m);
		init();
		minx=1000000; maxx=-1000000;
		for(int i=1; i<=n; i++){
			scanf("%d%d",&x,&y);
			if(x<minx){
				minx=x;
				s=i;
			}
			if(maxx<x){
				maxx=x;
				t=i;
			}
		}
		for(int i=1; i<=m; i++){
			scanf("%d%d%d",&u,&v,&w);
			addedge(u,v,w);
			addedge(v,u,w);
		}
		printf("%d\n",sap(s,t,n));
	}
	return 0;
} 
```

### 最小费用最大流

```c++
const int maxn = 5000 + 5;
const int maxm = 100000 + 5;

int head[maxn], tot = 1;
struct edge{
    int to, nxt, flow, cost;
}g[maxm];
void add(int x, int y, int f, int c) {
    g[++tot] = edge{y, head[x], f, c};
    head[x] = tot;
    g[++tot] = edge{x, head[y], 0, -c};
    head[y] = tot;
}
void init() {
    ms(head, 0); tot = 1;
}

int vis[maxn], cost[maxn], pre[maxn], flow[maxn], last[maxn], mf, mc;
bool spfa(int s, int t) {
    ms(cost, 0x7f); ms(flow, 0x7f); ms(vis, 0);
    queue<int> q; q.push(s); vis[s] = 1; cost[s] = 0; pre[t] = -1;
    while (!q.empty()) {
        int now = q.front(); q.pop(); vis[now] = 0;
        for (int i = head[now]; i; i = g[i].nxt) {
            int v = g[i].to;
            if (g[i].flow > 0 && cost[v] > cost[now] + g[i].cost) {
                cost[v] = cost[now] + g[i].cost;
                pre[v] = now; last[v] = i;
                flow[v] = min(flow[now], g[i].flow);
                if (!vis[v]) {
                    vis[v] = 1; q.push(v);
                }
            }
        }
    }
    return pre[t] != -1;
}

int s, t;
void mcmf() {
    mc = mf = 0;
    while (spfa(s, t)) {
        int now = t;
        mf += flow[t]; mc += flow[t] * cost[t];
        while (now != s) {
            g[last[now]].flow -= flow[t];
            g[last[now] ^ 1].flow += flow[t];
            now = pre[now];
        }
    }
}
```

#### Dijkstra 优化

```c++
struct MCMF {
    struct edge {
        int to, flow, cost, rev;
        edge() {}
        edge(int to, int f, int cost, int r): to(to), flow(f), cost(cost), rev(r) {}
    };
    int V, H[maxn + 5], dis[maxn + 5], preV[maxn + 5], preE[maxn + 5];
    vector<edge> G[maxn + 5];
    void init(int n) {
        V = n;
        for (int i = 0; i <= V; ++i) G[i].clear();
    }
    void add(int from, int to, int cap, int cost) {
        G[from].push_back(edge(to, cap, cost, (int)G[to].size()));
        G[to].push_back(edge(from, 0, -cost, (int)G[from].size() - 1));
    }
    int getmin(int s, int t, int f, int& flow) {
        int ans = 0; 
        fill(H, H + 1 + V, 0);
        while (f) {
            priority_queue<PII,vector<PII>,greater<PII> > q;
            fill(dis, dis + 1 + V, inf);
            dis[s] = 0; q.push({0, s});
            while (!q.empty()) {
                PII now = q.top(); q.pop();
                int v = now.second;
                if (dis[v] < now.first) continue;
                for (int i = 0; i < G[v].size(); ++i) {
                    edge& e = G[v][i];
                    if (e.flow > 0 && dis[e.to] > dis[v] + e.cost + H[v] - H[e.to]) {
                        dis[e.to] = dis[v] + e.cost + H[v] - H[e.to];
                        preV[e.to] = v;
                        preE[e.to] = i;
                        q.push({dis[e.to], e.to});
                    }
                }
            }
            if (dis[t] == inf) break;
            for (int i = 0; i <= V; ++i) H[i] += dis[i];
            int d = f;
            for (int v = t; v != s; v = preV[v]) d = min(d, G[preV[v]][preE[v]].flow);
            f -= d; flow += d; ans += d * H[t];
            for (int v = t; v != s; v = preV[v]) {
                edge& e = G[preV[v]][preE[v]];
                e.flow -= d;
                G[v][e.rev].flow += d;
            }
        }
        return ans;
    }
} f;

// f.getmin(s, t, inf, flow);
```

## Tarjan

```c++
namespace Tarjan {
    vector<int> st;
    int id, dfn[maxn], low[maxn], vis[maxn];
    int cnt, bel[maxn], ind[maxn], oud[maxn], mn[maxn];
    void dfs(int u) {
        dfn[u] = low[u] = ++id;
        vis[u] = 1; st.push_back(u);
        for (int i = 0; i < edge[u].size(); i++) {
            int v = edge[u][i];
            if (!dfn[v]) {
                dfs(v); low[u] = min(low[u], low[v]);
            } else if (vis[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            cnt++; int t = 0;
            do {
                t = st.back(); st.pop_back();
                bel[t] = cnt;
                vis[t] = 0;
            } while (t != u);
        }
    }
    void clear() { 
        ms(dfn, 0); ms(vis, 0);
        ms(ind, 0); ms(oud, 0);
        st.clear(); 
        cnt = id = 0; 
    }
}
```

### 边双联通分量 BCC 缩点

```c++
int cnt, bel[maxn]; // important!
namespace Tarjan {
    int tot, dfn[maxn], low[maxn], st[maxn], top, vis[maxn];
    void clear(int n) {
        tot = top = cnt = 0;
        for (int i = 1; i <= n; i++) {
            edge[i].clear(); dfn[i] = vis[i] = bel[i] = 0;
        }
    }
    void dfs(int u, int f) {
        dfn[u] = low[u] = ++tot;
        st[++top] = u; vis[u] = 1;
        int k = 0;
        for (int& v: edge[u]) {
            if (v == f && !k) {
                k++; continue;
            } 
            if (!dfn[v]) {
                dfs(v, u); low[u] = min(low[u], low[v]);
            } else if (vis[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            cnt++; int t = 0;
            do {
                t = st[top--];
                bel[t] = cnt;
                vis[t] = 0;
            } while (t != u);
        }
    }
    void scc(int n, vector<int> * g) {
        for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan::dfs(i, 0);
        for (int i = 1; i <= n; i++) g[i].clear();
        for (int i = 1; i <= n; i++) {
            int u = bel[i];
            for (int& x: edge[i]) {
                int v = bel[x];
                if (u != v) {
                    g[u].push_back(v);
                }
            }
        }
    }
}
```

### 桥

```c++
struct edge{int to, nxt;}f[4 * maxn];
int head[maxn], cnt;
void add(int x, int y) {
    f[++cnt].to = y; f[cnt].nxt = head[x]; head[x] = cnt;
}

int n, m, q;
int tot = 0, dfn[maxn], low[maxn], dep[maxn], fa[maxn];
int cut[maxn], br;

void dfs(int p, int old) {
    dfn[p] = low[p] = ++tot;
    dep[p] = dep[old] + 1;
    for (int i = head[p]; i; i = f[i].nxt) {
        int v = f[i].to;
        if (v == old) continue;
        if (!dfn[v]) {
            fa[v] = p; dfs(v, p);
            low[p] = min(low[p], low[v]);
            if (low[v] > dfn[p]) {
                cut[v] = 1;
                br++;
            }
        }
        else low[p] = min(low[p], dfn[v]);
    }
}
```

### 2-SAT

```c++
vector<int> edge[maxn], ans;
int n, m, bel[maxn];

bool dfs(int x) {
    if (bel[x]) return bel[x] % 2;
    bel[x] = 1; bel[x ^ 1] = 2;
    ans.push_back(x);
    for (auto& v : edge[x]) {
        if (!dfs(v)) return false;
    }
    return true;
}

bool cal() {
    ms(bel, 0);
    for (int i = 0; i < 2 * n; i++) {
        if (bel[i]) continue;
        ans.clear();
        if (!dfs(i)) {
            for (int& x : ans) bel[x] = bel[x ^ 1] = 0;
            if (!dfs(i ^ 1)) return false;
        }
    }
    return true;
}
```

## 一般图最大独立集

### 最大团

```c++
struct Max_Clique {
	static const int N = 100;
	vector<int> sol;
	int el[N][N / 30 + 1], s[N][N / 30 + 1];
	int n, ans, dp[N];
	void init(int _n) {
		n = _n;
		for(int i = 0; i <= n; i++) {
			dp[i] = 0;
			ms(el[i], 0);
		}
	}
	/* Zero Base */
	void add_edge(int a,int b) {
		if(a > b) swap(a, b);
		if(a == b) return;
		el[a][b / 32] |= (1 << (b % 32));
	}
	bool dfs(int x,int k) {
		int c = 0, d = 0;
		for(int i = 0; i < (n + 31) / 32; i++) {
			s[k][i] = el[x][i];
			if (k != 1) s[k][i] &= s[k - 1][i];
			c += __builtin_popcount(s[k][i]);
		}
		if (c == 0) {
			if(k > ans) {
				ans = k;
				sol.clear();
				sol.push_back(x);
				return 1;
			}
			return 0;
		}
		for (int i = 0; i < (n + 31) / 32; i++) {
			for (int a = s[k][i]; a; d++) {
				if (k + (c - d) <= ans) return 0;
				int lb = a & (-a), lg = 0;
				a ^= lb;
				while (lb!=1) {
					lb = (unsigned int)(lb) >> 1;
					lg++;
				}
				int u = i * 32 + lg;
				if (k + dp[u] <= ans) return 0;
				if (dfs(u, k + 1)) {
					sol.push_back(x);
					return 1;
				}
			}
		}
		return 0;
	}
	int solve() {
		ans = 0;
		for(int i = n - 1; i >= 0; i--) {
			dfs(i,1);
			dp[i] = ans;
		}
		return ans;
	}
} mcp;
```

### 随机化

```c++
const int maxn = 100 + 5;

int n, m, p[maxn], vis[maxn], G[maxn][maxn];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; i++) {
        scanf("%d%d", &u, &v);
        G[u][v] = G[v][u] = 1;
    }
    for (int i = 1; i <= n; i++) p[i] = i;
    int T = 10000, ans = 0;
    vector<int> rec;
    while (T--) {
        random_shuffle(p + 1, p + 1 + n);
        ms(vis, 0);
        vector<int> v; 
        int res = 1; vis[1] = 1;
        v.push_back(p[1]);
        for (int i = 2; i <= n; i++) {
            int flag = 1;
            for (int j = 1; j < i; j++) {
                if (vis[j] && G[p[i]][p[j]]) {
                    flag = 0; break;
                }
            }
            if (flag) {
                v.push_back(p[i]);
                vis[i] = 1; res++;
            }
        }
        if (res > ans) {
            ans = res; rec = v;
        }
    }
    printf("%d\n", ans);
    for (int i = 0; i < (int)rec.size(); i++) {
        if (i) putchar(' ');
        printf("%d", rec[i]);
    }
    return 0;
}
```

## Erdos-Gallai 定理

$n+1$ 个点的图，给出前 $n$ 个点的度数序列，问第 $n+1$ 个点的所有可能取值。

根据握手定理可以知道最后一点度数的奇偶性，并且如果度数可以取到 $x,y(x < y)$，那么 $[ x, y ]$ 中都可以很容易构造出来。

因此可以二分上下界。

对于一个点的度数是否可行，可以应用 [Erdos-Gallai Theorem](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem) 判定。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
const int maxn = 500000 + 5;

bool cmp(int x, int y) { return x > y; }
int n, a[maxn], b[maxn];
ll sum = 0;

int check(int x) {
    for (int i = 1; i <= n; i++) b[i] = a[i]; b[n + 1] = x;
    sort(b + 1, b + n + 2, cmp);
    int p = 0; for (int i = 1; i <= n + 1; i++) if (b[i] == x) p = i;
    ll sum = 0, s2 = 0; int j = n + 1;
    for (int i = 1; i <= n + 1; i++) {
        sum += b[i];
        while (j > i && b[j] <= i) s2 += b[j--];
        if (j < i) s2 -= b[i];
        if (sum > 1ll * i * (i - 1) + s2 + 1ll * i * max(j - i, 0)) {
            if (b[i] > x) return -1;
            else return 1;
        }
    }
    return 0;
}

int main(){
    scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", a + i), sum += a[i];
    sort(a + 1, a + 1 + n, cmp);
    sum %= 2;
    int l = 0, r = (n - sum) / 2, u = -1, d = -1;
    while (l <= r) {
        int m = l + r >> 1;
        if (check(2 * m + sum) == -1) l = m + 1;
        else r = m - 1, d = m;
    }
    l = d, r = (n - sum) / 2;
    while (l <= r) {
        int m = l + r >> 1;
        if (check(2 * m + sum) == 1) r = m - 1;
        else l = m + 1, u = m;
    }
    // cout << u << ' ' << d << endl;
    if (u == -1 || d == -1) return puts("-1"), 0;
    for (int i = d; i <= u; i++) printf("%d ", 2 * i + sum);
    return 0;
}
```

## 同构图

```c++
struct edge{int x, y;};
using G = vector<edge>;
 
inline G read(int m) {
    G a;
    for (int i = 0; i < m; i++) {
        int x, y; scanf("%d%d", &x, &y);
        a.push_back(edge {x, y});
    }
    return a;
}
inline int count(const G& b, const G& a) {
    ms(vis, 0);
    for (int i = 0; i < a.size(); i++) 
        vis[a[i].x][a[i].y] = vis[a[i].y][a[i].x] = 1;
    for (int i = 0; i <= n; i++) f[i] = i;
    int res = 0;
    do{
        bool flag = true;
        for (int i = 0; i < b.size(); i++) {
            if (!vis[f[b[i].x]][f[b[i].y]]) {
                flag = false; break;
            }
        }
        if (flag) res++;
    } while (next_permutation(f + 1, f + 1 + n));
    return res;
}
```

## 线段树优化建图

```c++
const int mod = 998244353;
const int maxn = 500000 + 5;

vector<int> edge[maxn];
int n, b[maxn], a[maxn], pos[maxn], id[maxn], deg[maxn];

void build(int l, int r, int rt) {
    pos[rt] = -1;
    if (l == r) {
        id[l] = rt; pos[rt] = l;
        return ;
    }
    int m = (l + r) >> 1;
    edge[rt << 1].push_back(rt);
    edge[rt << 1 | 1].push_back(rt);
    deg[rt] += 2;
    build(lson); build(rson);
}
void link(int L, int R, int p, int l, int r, int rt) {
    if (L <= l && r <= R) {
        edge[rt].push_back(p); 
        deg[p]++;
        return ;
    }
    int m = (l + r) >> 1;
    if (L <= m) link(L, R, p, lson);
    if (R > m) link(L, R, p, rson);
}

int main(){
    scanf("%d", &n); 
    for (int i = 0; i < n; i++) scanf("%d", b + i);
    build(0, n - 1, 1);
    for (int i = 0; i < n; i++) {
        if (b[i] % n == i) continue;
        int s = b[i] % n;
        if (s < i) link(s, i - 1, id[i], 0, n - 1, 1);
        else {
            link(s, n - 1, id[i], 0, n - 1, 1);
            if (i) link(0, i - 1, id[i], 0, n - 1, 1);
        }
    }
    int last = 0;
    priority_queue<PII,vector<PII>,greater<PII> > pq;
    for (int i = 0; i < n; i++) {
        if (deg[id[i]] == 0) pq.push({b[i], id[i]});
    }
    while (!pq.empty()) {
        PII t = pq.top(); pq.pop();
        if (t.first != -1) a[last++] = t.first;
        for (int& v: edge[t.second]) {
            deg[v]--;
            if (deg[v] == 0) {
                if (pos[v] == -1) pq.push({-1, v});
                else pq.push({b[pos[v]], v});
            }
        }
    }
    for (int i = 0; i < n; i++) printf("%d%c", a[i], " \n"[i == n - 1]);
    return 0;
}
```

## 树

### 虚树

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
const int mod = 998244353;
const int inf = 1 << 30;
const int maxn = 300000 + 5;

int n, q, dfn[maxn], key[maxn], tot;
vector<PII> edge[maxn];

namespace LCA {
    int fa[maxn][20], dep[maxn], mn[maxn][20];
    void dfs(int u, int f) {
        dfn[u] = ++tot; fa[u][0] = f; dep[u] = dep[f] + 1;
        for (int i = 1; i < 20; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            mn[u][i] = min(mn[u][i - 1], mn[fa[u][i - 1]][i - 1]);
        }
        for (auto& x: edge[u]) {
            int v = x.first;
            if (v == f) continue;
            mn[v][0] = x.second;
            dfs(v, u);
        }
    }
    PII qlca(int u, int v) {
        int d = inf;
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 19; i >= 0; i--) if (dep[fa[u][i]] >= dep[v]) {
            d = min(d, mn[u][i]); u = fa[u][i];
        }
        if (u == v) return { u, d };
        for (int i = 19; i >= 0; i--) {
            if (fa[u][i] == fa[v][i]) continue;
            d = min(d, min(mn[u][i], mn[v][i]));
            u = fa[u][i]; v = fa[v][i];
        }
        return { fa[u][0], d };
    }
}

ll f[maxn];
void dp(int u, int ff) {
    f[u] = 0;
    for (auto& x: edge[u]) {
        int v = x.first;
        if (v == ff) continue;
        dp(v, u);
        if (key[v]) f[u] += x.second;
        else f[u] += min(1ll * x.second, f[v]);
    }
}
namespace VT {
    int stk[maxn], top;
    void build(vector<int>& vec) {
        sort(vec.begin(), vec.end(), [](int a, int b) { return dfn[a] < dfn[b]; });
        stk[top = 1] = 1; edge[1].clear();
        for (int x: vec) {
            if (x == 1) continue;
            int l = LCA::qlca(stk[top], x).first;
            if (l != stk[top]) {
                while (dfn[l] < dfn[stk[top - 1]]) {
                    int w = LCA::qlca(stk[top], stk[top - 1]).second;
                    edge[stk[top - 1]].push_back({stk[top], w}); top--;
                }
                int w = LCA::qlca(l, stk[top]).second;
                if (dfn[l] > dfn[stk[top - 1]]) {
                    edge[l].clear();
                    edge[l].push_back({ stk[top], w }); 
                    stk[top] = l;
                } else {
                    edge[l].push_back({ stk[top], w });
                    top--;
                }
            }
            edge[x].clear(); stk[++top] = x;
        }
        for (int i = 1; i < top; i++) {
            int w = LCA::qlca(stk[i], stk[i + 1]).second;
            edge[stk[i]].push_back({ stk[i + 1], w });
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        edge[u].push_back({v, w}); edge[v].push_back({u, w});
    } 
    LCA::dfs(1, 0);
    scanf("%d", &q);
    while (q--) {
        int k; vector<int> vec;
        scanf("%d", &k);
        for (int i = 1, x; i <= k; i++) {
            scanf("%d", &x); 
            vec.push_back(x);
            key[x] = 1;
        }
        VT::build(vec);
        dp(1, 0); printf("%lld\n", f[1]);
        for (int x: vec) key[x] = 0;
    }
    return 0;
}
```

### 长链剖分

#### k 级祖先

```c++
int n, m;
vector<int> edge[maxn];

int dep[maxn], son[maxn], top[maxn], len[maxn], maxd[maxn], fa[maxn][20];
void dfs(int u, int f) {
    maxd[u] = dep[u] = dep[f] + 1;
    fa[u][0] = f; son[u] = 0;
    for (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        if (maxd[v] > maxd[son[u]]) son[u] = v, maxd[u] = maxd[v];
    }
}
void dfs(int u, int f, int tp, int l) {
    top[u] = tp; len[u] = l;
    if (son[u]) {
        dfs(son[u], u, tp, l + 1);
        len[u] = len[son[u]];
    }
    for (int& v: edge[u]) {
        if (v == f || v == son[u]) continue;
        dfs(v, u, v, 1);
    }
}
bool vis[maxn]; int highbit[maxn];
vector<int> up[maxn], dwn[maxn];
void init() {
    dfs(1, 0); dfs(1, 0, 1, 1);
    for (int i = 1; i <= n; i++) {
        int tp = top[i];
        if (!vis[tp]) {
            vis[tp] = 1;
            int l = 0, now = tp;
            while (l < len[tp] && now) {
                now = fa[now][0];
                l++; up[tp].push_back(now);
            }
            l = 0, now = tp;
            while (l < len[tp]) {
                now = son[now];
                l++; dwn[tp].push_back(now);
            }
        }
    }
    int mx = 1;
    for (int i = 1; i <= n; i++) {
        if (i >> mx & 1) mx++;
        highbit[i] = mx - 1;
    }
}
int qkth(int u, int k) {
    if (k > dep[u]) return 0;
    if (k == 0) return u;
    u = fa[u][highbit[k]]; k -= 1 << highbit[k];
    if (k == 0) return u;
    if (dep[u] - dep[top[u]] == k) return top[u];
    if (dep[u] - dep[top[u]] > k) return dwn[top[u]][dep[u] - dep[top[u]] - k - 1];
    return up[top[u]][k - (dep[u] - dep[top[u]]) - 1];
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v); edge[v].push_back(u);
    } init();
    scanf("%d", &m);
    int u, k, lastans = 0;
    while (m--) {
        scanf("%d%d", &u, &k);
        u ^= lastans; k ^= lastans;
        printf("%d\n", lastans = qkth(u, k));
    }
    return 0;
}
```

#### 优化深度信息合并

```c++
int n; ll ans = 0;
vector<int> edge[maxn];

int dep[maxn], son[maxn], top[maxn], len[maxn];
void dfs1(int u, int f) {
    len[u] = 0;
    for (int v: edge[u]) {
        if (v == f) continue;
        dfs1(v, u);
        if (len[v] > len[son[u]]) son[u] = v, len[u] = len[v];
    }
    len[u]++;
}
int tmp[maxn * 16], *f[maxn], *g[maxn], *tot = tmp;
void make(int u, int len) {
    f[u] = tot; tot += (len + 5) * 2;
    g[u] = tot; tot += (len + 5) * 2;
}
void dfs(int u, int ff) {
    if (son[u]) {
        f[son[u]] = f[u] + 1;
        g[son[u]] = g[u] - 1;
        dfs(son[u], u);
    }
    f[u][0] = 1;
    ans += g[u][0];
    for (int& v: edge[u]) {
        if (v == ff || v == son[u]) continue;
        make(v, len[v]);
        dfs(v, u);
        for (int j = 0; j <= len[v] + 1; j++) {
            ans += f[u][j] * g[v][j + 1];
            if (j) ans += g[u][j] * f[v][j - 1];
            g[u][j] += g[v][j + 1];
            if (j) g[u][j] += f[u][j] * f[v][j - 1];
            if (j) f[u][j] += f[v][j - 1];
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v); edge[v].push_back(u);
    }
    dfs1(1, 0);
    make(1, len[1]);
    dfs(1, 0);
    cout << ans << '\n';
    return 0;
}
```


### 树上启发式合并

```c++
int sz[maxn], son[maxn], dep[maxn];
void getsz(int u, int f) {
    sz[u] = 1; dep[u] = dep[f] + 1;
    for (auto& v : edge[u]) {
        if (v == f) continue;
        getsz(v, u); sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}
int sk[maxn], cnt[maxn][30];
void add(int u, int f, int x) {
    // update answer
    for (auto& v : edge[u]) {
        if (v == f || sk[v]) continue;
        add(v, u, x);
    }
}
void dfs(int u, int f, int kp) {
    for (auto& v : edge[u]) {
        if (v == f || v == son[u]) continue;
        dfs(v, u, 0);
    }
    if (son[u]) dfs(son[u], u, 1), sk[son[u]] = 1;
    add(u, f, 1); sk[son[u]] = 0;
		// answert query
    if (!kp) add(u, f, -1);
}
```

### 树分块

```c++
int n, b;
vector<int> edge[maxn];

int stk[maxn], tot, bel[maxn], bcnt, key[maxn];
void dfs(int u, int f) {
    int bot = tot;
    for (int& v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        if (tot - bot >= b) {
            bcnt++; key[bcnt] = u;
            while (tot != bot) {
                bel[stk[tot--]] = bcnt;
            }
        }
    }
    stk[++tot] = u;
} 

int main() {
    scanf("%d%d", &n, &b);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    dfs(1, 0);
    while (tot) bel[stk[tot--]] = bcnt;
    printf("%d\n", bcnt);
    for (int i = 1; i <= n; i++) printf("%d%c", bel[i], " \n"[i == n]);
    for (int i = 1; i <= bcnt; i++) printf("%d%c", key[i], " \n"[i == bcnt]);
    return 0;
}
```

### 树哈希

原题：[HDu6647 Bracket Sequences on Tree](http://acm.hdu.edu.cn/showproblem.php?pid=6647)。

求每个点作为根节点的树哈希值。

```c++
namespace sieve{
    const int maxp = 2000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
        ms(vis, 0);
        for (int i = 2; i < maxp; i++) {
            if (!vis[i]) prime[++tot] = i;
            for (int j = 1; j <= tot && prime[j] * i < maxp; j++) {
                vis[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
    }
}
namespace MyIO {
    struct fastIO {
        char s[100000]; int it,len;
        fastIO() { it = len = 0; }
        inline char get() {
            if (it < len) return s[it++];
            it = 0; len = fread(s, 1, 100000, stdin);
            if (len == 0) return EOF;
            else return s[it++];
        }
        bool notend() {
            char c = get();
            while(c == ' ' || c == '\n') c = get();
            if (it > 0) it--;
            return c != EOF;
        }
    } buff;
    inline int gi() {
        int r = 0; bool ng = 0; 
        char c = buff.get();
        while (c != '-' && (c < '0' || c > '9')) c = buff.get();
        if (c == '-') ng = 1, c = buff.get();
        while (c >= '0' && c <= '9') r = r * 10 + c - '0', c = buff.get();
        return ng ? -r : r;
    }
}
namespace {
    inline int add(int x, int y) {
        x += y;
        return x >= mod ? x -= mod : x;
    }
    inline int sub(int x, int y) {
        x -= y;
        return x < 0 ? x += mod : x;
    }
    inline int mul(int x, int y) {
        return 1ll * x * y % mod;
    }
    inline int qpow(int x, ll n) {
        int r = 1;
        while (n > 0) {
            if (n & 1) r = 1ll * r * x % mod;
            n >>= 1; x = 1ll * x * x % mod;
        }
        return r;
    }
    inline int inv(int x) {
        return qpow(x, mod - 2);
    }
}
using sieve::prime;
using MyIO::gi;

int ping[maxn], pingv[maxn];

int n, ans, siz[maxn];
vector<int> edge[maxn];
map<ull,int> uqc[maxn];
map<ull,int>::iterator it;

ull hashval[maxn], hashrt[maxn];
ull srchashval[maxn], srchashrt[maxn];
int dp[maxn], rdp[maxn];
ull pack(ull val, int sz) {
    return 2ull + 3ull * val + 7ull * prime[sz + 1];
}
void predfs(int u, int ff) {
    siz[u] = dp[u] = 1;
    hashval[u] = 1;
    int sz = 0;
    for (int v: edge[u]) {
        if (v == ff) continue;
        predfs(v, u);
        sz++;
        siz[u] += siz[v];
        dp[u] = mul(dp[u], dp[v]);
        uqc[u][hashval[v]]++;
        hashval[u] += hashval[v] * prime[siz[v]];
    }

    srchashval[u] = hashval[u];
    hashval[u] = pack(hashval[u], siz[u]);

    dp[u] = mul(dp[u], ping[sz]);
    for (it = uqc[u].begin(); it != uqc[u].end(); it++) {
        dp[u] = mul(dp[u], pingv[it->second]);
    }
}
set<ull> qc;
void dfs(int u, int ff) {
    if (!qc.count(hashrt[u])) {
        qc.insert(hashrt[u]);
        ans = add(ans, rdp[u]);
    }
    for (int v: edge[u]) {
        if (v == ff) continue;

        ull tmp = srchashrt[u] - hashval[v] * prime[siz[v]];
        tmp = pack(tmp, n - siz[v]);

        uqc[v][tmp]++;
        srchashrt[v] = srchashval[v] + tmp * prime[n - siz[v]];
        hashrt[v] = pack(srchashrt[v], n);

        int tdp = mul(rdp[u], inv(dp[v]));
        tdp = mul(tdp, inv((int)edge[u].size()));
        tdp = mul(tdp, uqc[u][hashval[v]]);
        rdp[v] = mul(dp[v], tdp);
        rdp[v] = mul(rdp[v], (int)edge[v].size());
        rdp[v] = mul(rdp[v], inv(uqc[v][tmp]));

        dfs(v, u);
    }
}

int main() {
    sieve::init(); ping[0] = pingv[0] = 1;
    for (int i = 1; i < maxn; i++) {
        ping[i] = mul(ping[i - 1], i);
        pingv[i] = mul(pingv[i - 1], inv(i));
    }
    int T = gi();
    while (T--) {
        n = gi();
        for (int i = 2, u, v; i <= n; i++) {
            u = gi(); v = gi();
            edge[u].push_back(v);
            edge[v].push_back(u);
        }

        predfs(1, 0);
        ans = 0; qc.clear();
        rdp[1] = dp[1]; 
        hashrt[1] = hashval[1];
        srchashrt[1] = srchashval[1];
        dfs(1, 0);

        printf("%d\n", ans);

        for (int i = 1; i <= n; i++) {
            edge[i].clear();
            uqc[i].clear();
        }
    }
    return 0;
}
```

### 树分治

```c++
const int mod = 998244353;
const int inf = 2147483647; 
const int maxn = 200000 + 50;

int tr[maxn];
inline int lowbit(int x) { return x & -x; }
inline void update(int i, int x) {
    while (i < maxn) tr[i] = max(tr[i], x), i += lowbit(i);
}
inline void del(int i) {
    while (i < maxn) tr[i] = 0, i += lowbit(i);
}
inline int query(int i) {
    int r = 0; while (i > 0) r = max(tr[i], r), i -= lowbit(i);
    return r;
}

struct edge {
    int to, nxt, d;
} g[maxn << 1];
int head[maxn], tot;
void add(int u, int v, int w) {
    g[++tot] = (edge){v, head[u], w}; head[u] = tot;
}

int n, k, m, key[maxn], ans;

int vis[maxn], siz[maxn], sum, mn, rt;
void getrt(int u, int f) {
    siz[u] = 1; int t = 0;
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (v == f || vis[v]) continue;
        getrt(v, u); siz[u] += siz[v];
        t = max(t, siz[v]);
    }
    t = max(t, sum - siz[u]);
    if (t < mn) mn = t, rt = u;
}
int getrt(int u) {
    sum = siz[u]; mn = 1e9; rt = 0;
    getrt(u, 0); return rt;
}

vector<PII> vec;
void dfs(int u, int f, int c, int d) {
    c += key[u];
    if (c > k) return ;
    vec.push_back({c, d});
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (v == f || vis[v]) continue;
        dfs(v, u, c, d + g[i].d);
    }
}
void solve(int u) {
    vis[u] = 1; vector<int> al; 
    update(key[u] + 1, 0); al.push_back(key[u]);
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (vis[v]) continue;
        vec.clear();
        dfs(v, u, key[u], g[i].d);
        for (int i = 0; i < vec.size(); i++) {
            ans = max(ans, vec[i].second + query(k - vec[i].first + key[u] + 1));
        }
        for (int i = 0; i < vec.size(); i++) {
            al.push_back(vec[i].first), update(vec[i].first + 1, vec[i].second);
        }
    }
    for (int i = 0; i < al.size(); i++) del(al[i] + 1);
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (vis[v]) continue;
        solve(getrt(v));
    }
}

int main() {
    scanf("%d%d%d", &n, &k, &m);
    for (int i = 1, x; i <= m; i++) scanf("%d", &x), key[x] = 1;
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    siz[1] = n; solve(getrt(1));
    cout << ans << endl;
    return 0;
}
```

### 树形依赖背包

```c++
const int mod = 998244353;
const int maxn = 5000 + 5;

vector<int> edge[maxn];
int n, b, d[maxn], c[maxn];

// min cost of subtree-i buy j things, with discount or not
ll dp[maxn][maxn][2];
int siz[maxn];
void dfs(int u, int f) {
    siz[u] = 1;
    dp[u][0][0] = 0;
    dp[u][1][0] = c[u];
    dp[u][1][1] = c[u] - d[u];
    for (int& v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        for (int i = siz[u]; i >= 0; i--) {
            for (int j = 1; j <= siz[v]; j++) {
                dp[u][i + j][0] = min(dp[u][i + j][0], dp[u][i][0] + dp[v][j][0]);
                dp[u][i + j][1] = min(dp[u][i + j][1], dp[u][i][1] + dp[v][j][0]);
                dp[u][i + j][1] = min(dp[u][i + j][1], dp[u][i][1] + dp[v][j][1]);
            }
        }
        siz[u] += siz[v];
    }
}

int main(){
    scanf("%d%d", &n, &b);
    for (int i = 1, x; i <= n; i++) {
        for (int j = 0; j <= n; j++) dp[i][j][0] = dp[i][j][1] = 1ll << 60;
        scanf("%d%d", c + i, d + i);
        if (i == 1) continue;
        scanf("%d", &x);
        edge[x].push_back(i);
    }
    dfs(1, 0);
    int ans = 0;
    for (int i = 1; i <= n; i++) if (min(dp[1][i][0], dp[1][i][1]) <= b) ans = i;
    cout << ans << endl;
    return 0;
}
```

### 支配树

- `semi[x]` 半必经点： $x$ 的祖先 $z$ 中，能不经过 $z$ 和 $x$ 之间的树上的点而到达 $x$ 的点中深度最小的
- `idom[x]` 最近必经点：就是深度最大的根到 $x$ 的必经点

```c++
vector<int> G[maxn], rG[maxn];
vector<int> dt[maxn];
// 原图，反图，支配树

namespace DomTree {
    int fa[maxn], idx[maxn], tot, ridx[maxn];
    int c[maxn], best[maxn], semi[maxn], idom[maxn];
    void clear(int n) {
        tot = 0;
        fill(c, c + n + 1, -1);
        fill(idx, idx + n + 1, 0);
        for (int i = 0; i <= n; i++) {
            dt[i].clear();
            semi[i] = best[i] = i;
        }
    }
    void dfs(int u) {
        idx[u] = ++tot; ridx[tot] = u;
        for (int& v: G[u]) {
            if (idx[v]) continue;
            fa[v] = u; dfs(v);
        }
    }
    int fix(int x) {
        if (c[x] == -1) return x;
        int &f = c[x], rt = fix(f);
        if (idx[semi[best[x]]] > idx[semi[best[f]]]) best[x] = best[f];
        return f = rt;
    }
    void build(int rt) {
        dfs(rt);
        for (int i = tot; i >= 1; i--) {
            int x = ridx[i], mn = tot + 1;
            for (int& u: rG[x]) {
                if (!idx[u]) continue;
                fix(u); mn = min(mn, idx[semi[best[u]]]);
            }
            c[x] = fa[x];
            dt[semi[x] = ridx[mn]].push_back(x);
            x = ridx[i - 1];
            for (int& u: dt[x]) {
                fix(u);
                if (semi[best[u]] != x) idom[u] = best[u];
                else idom[u] = x;
            }
            dt[x].clear();
        }
        for (int i = 2; i <= tot; i++) {
            int u = ridx[i];
            if (idom[u] != semi[u]) idom[u] = idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}
```

## 仙人掌

```c++
int cnt;
namespace cactus {
    struct E { 
        int to, nxt; 
    } e[maxn * 2];
    int head[maxn], ecnt;
    void adde(int u, int v) {
        e[++ecnt] = {v, head[u]};
        head[u] = ecnt;
    }
    int tot, dfn[maxn], fa[maxn];
    bool ring[maxn];
    void clear(int n) { 
        cnt = ecnt = tot = 0;
        for (int i = 1; i <= n; i++) {
            head[i] = dfn[i] = ans[i] = 0;
        }
    }
    void dfs(int u, int f) {
        dfn[u] = ++tot;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (v == f) continue;
            if (!dfn[v]) {
                fa[v] = u; ring[u] = false;
                dfs(v, u);
                if (!ring[u]) { 
                    edge[u].push_back(v); edge[v].push_back(u); 
                }
            } else if (dfn[v] < dfn[u]) {
                cnt++; int rt = cnt + n;
                bcc[cnt].clear();
                edge[rt].push_back(v); 
                edge[v].push_back(rt);
                bcc[cnt].push_back(v);
                for (int x = u; x != v; x = fa[x]) {
                    ring[x] = true;
                    bcc[cnt].push_back(x);
                    edge[rt].push_back(x); 
                    edge[x].push_back(rt);
                }
                ring[v] = true;
            }
        }
    }
    void build() {
        dfs(1, 0);
    }
}
```

