# 图论

[TOC]

## LCA

### 倍增

```c++
int head[maxn], to[maxn * 2], nxt[maxn * 2], d[maxn * 2], tot;
void add(int x, int y, int w) {
    to[++tot] = y; nxt[tot] = head[x]; d[tot] = w; head[x] = tot;
}

int n, m;

int dp[maxn][20], dep[maxn], dis[maxn];
void dfs(int u, int fa) {
    dp[u][0] = fa; dep[u] = dep[fa] + 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == fa) continue;
        dis[v] = dis[u] + d[i];
        dfs(v, u);
    }
}
void init() {
    ms(dp, 0); dep[0] = dis[0] = 0;
    dfs(1, 0);
    for (int j = 1; j < 20; j++)
        for (int i = 1; i <= n; i++)
            dp[i][j] = dp[dp[i][j - 1]][j - 1];
}
int lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    int tmp = dep[x] - dep[y];
    for (int i = 0; tmp; i++, tmp >>= 1)
        if (tmp & 1) x = dp[x][i];
    if (x == y) return x;
    for (int i = 19; i >= 0; i--) {
        if (dp[x][i] != dp[y][i]) {
            x = dp[x][i]; y = dp[y][i];
        }
    }
    return dp[x][0];
}
```

### 树链剖分

```c++
namespace hld {
  int siz[maxn], dep[maxn], fa[maxn], son[maxn], top[maxn];
  void dfs(int u, int f) {
    fa[u] = f; siz[u] = 1; son[u] = 0;
    int m = -1;
    for (auto& v: edge[u]) {
      if (v == f) continue;
      dep[v] = dep[u] + 1;
      dfs(v, u);
      siz[u] += siz[v];
      if (siz[v] > m) son[u] = v, m = siz[v];
    }
  }
  void dfs(int u, int f, int tp) {
    top[u] = tp;
    if (!son[u]) return;
    dfs(son[u], u, tp); // !
    for (auto& v: edge[u]) {
      if (v == f || v == son[u]) continue; // !
      dfs(v, u, v);
    }
  }
  void build() {
    dep[1] = 0;
    dfs(1, 0);
    dfs(1, 0, 1);
  }
  int qlca(int u, int v) {
    while (top[u] != top[v]){
      if (dep[top[u]] < dep[top[v]]) swap(u, v);
      u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
  }
  int qdis(int u, int v) {
    return dep[u] + dep[v] - 2 * dep[qlca(u, v)];
  }
}
```

### 欧拉序

```c++
namespace LCA {
  const int L = 18;
  
  int st[maxn], ed[maxn], dep[maxn];
  int euler[maxn * 2], cnt;
  int dp[L][maxn * 2];
  
  void dfs(int u, int f) {
    euler[++cnt] = u;
    st[u] = cnt;
    for (int v: edge[u]) {
      if (v == f) continue;
      dep[v] = dep[u] + 1;
      dfs(v, u);
      euler[++cnt] = u;
    }
    ed[u] = cnt;
  }
  void build(int rt = 1) {
    dep[rt] = 0;
    cnt = 0;
    dfs(rt, 0);
    for (int i = 1; i <= cnt; i++) {
      dp[0][i] = euler[i];
    }
    for (int j = 1; j < L; j++) {
      for (int i = 1; i + (1 << j) <= cnt + 1; i++) {
        int l = dp[j - 1][i];
        int r = dp[j - 1][i + (1 << (j - 1))];
        if (dep[l] < dep[r]) {
          dp[j][i] = l;
        } else {
          dp[j][i] = r;
        }
      }
    }
  }
  int qlca(int u, int v) {
    int l = st[u], r = st[v];
    if (l > r) swap(l, r);
    int k = __lg(r - l + 1);
    int x = dp[k][l], y = dp[k][r - (1 << k) + 1];
    if (dep[x] < dep[y]) {
      return x;
    } else {
      return y;
    }
  }
  int qdis(int u, int v) {
    return dep[u] + dep[v] - 2 * dep[qlca(u, v)];
  }
}
```

### 维护联通子图距离

```c++
const int maxn = 100000 + 5;

vector<PII> edge[maxn];
int n, q, dfn[maxn], id[maxn], tot;

namespace LCA {
    int fa[maxn][20], dep[maxn];
    ll dis[maxn];
    void dfs(int u, int f) {
        dfn[u] = ++tot; id[tot] = u;
        fa[u][0] = f; dep[u] = dep[f] + 1;
        for (auto& x: edge[u]) {
            int v = x.first;
            if (v == f) continue;
            dis[v] = dis[u] + x.second;
            dfs(v, u);
        }
    }
    void init() {
        dfs(1, 0);
        for (int j = 1; j < 20; j++) for (int i = 1; i <= n; i++)
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
    }
    int qlca(int u, int v) {
        if (dep[u] < dep[v]) swap(u, v);
        int tmp = dep[u] - dep[v];
        for (int i = 0; tmp; i++, tmp >>= 1) if (tmp & 1) u = fa[u][i];
        if (u == v) return u;
        for (int i = 19; i >= 0; i--) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
        return fa[u][0];
    }
    ll qdis(int u, int v) {
        return dis[u] + dis[v] - 2ll * dis[qlca(u, v)];
    }
}

int main(){
    scanf("%d", &n);
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        edge[u].push_back({v, w});
        edge[v].push_back({u, w});
    } LCA::init();
    scanf("%d", &q);
    char op[3]; int x; ll ans = 0; set<int> st;
    while (q--) {
        scanf("%s", op);
        if (op[0] == '+') {
            scanf("%d", &x);
            st.insert(dfn[x]);
            auto it = st.find(dfn[x]);
            auto l = it, r = it; r++;
            if (l == st.begin()) l = --st.end();
            else l--;
            if (r == st.end()) r = st.begin();
            ans += LCA::qdis(id[*l], x) + LCA::qdis(x, id[*r]) - LCA::qdis(id[*l], id[*r]);
        }
        if (op[0] == '-') {
            scanf("%d", &x);
            auto it = st.find(dfn[x]);
            auto l = it, r = it; r++;
            if (l == st.begin()) l = --st.end();
            else l--;
            if (r == st.end()) r = st.begin();
            ans -= LCA::qdis(id[*l], x) + LCA::qdis(x, id[*r]) - LCA::qdis(id[*l], id[*r]);
            st.erase(it);
        }
        if (op[0] == '?') {
            printf("%lld\n", ans / 2);
        }
    }
    return 0;
}
```

## Dijkstra

```c++
struct Edge { int to, nxt, d; } f[maxn * 2];
int head[maxn], ecnt;
void adde(int x, int y, int d) {
  f[++ecnt] = { y, head[x], d };
  head[x] = ecnt;
}

bool vis[maxn];
struct Node {
  int to; ll d;
  bool operator< (const Node& b)const{
    return d > b.d;
  }
};
void dijkstra(int s, ll dis[]) {
  for (int i = 0; i <= n; i++) {
    vis[i] = false; dis[i] = 1ll << 60;
  }
  ms(vis, 0); dis[s] = 0;
  priority_queue<Node> q;
  q.push((Node){s, 0});
  while (!q.empty()) {
    Node t = q.top(); q.pop();
    if (vis[t.to]) continue;
    vis[t.to] = 1;
    for (int i = head[t.to]; i; i = f[i].nxt) {
      int v = f[i].to;
      if (vis[v]) continue;
      if (dis[v] > dis[t.to] + f[i].d) {
        dis[v] = dis[t.to] + f[i].d;
        q.push({v, dis[v]});
      }
    }
  }
}

```

## SPFA

一般用于计算差分约束

最大值 $x-y\le k$， 从 $y$ 到 $x$ 权值为 $k$ 的边，求最短路。

注意： $x-y \lt k$ 转化成 $x-y \le k-1$。

最小值 $x-y\ge k$， 从 $y$ 到 $x$ 权值为 $k$ 的边，求最长路。

注意设置的源点要能到图里所有点！

```c++
const int N = 1e4 + 5, M = 1e5 + 5;
const ll inf = 1e18;

int T, n, m;
struct edge {
    int to, l, nxt;
} e[M * 2];
int head[N], cnt;

void init() {
    ms(head, -1); cnt = 0;
}

void add_edge(int u, int v, int l) {
    e[cnt].to = v;
    e[cnt].l = l;
    e[cnt].nxt = head[u];
    head[u] = cnt++;
}

queue<int> que;
ll dis[N];
int counts[N];
bool vis[N];

int spfa(int s) {
    for (int i = 0; i <= n; i++) {
        vis[i] = 0;
        counts[i] = 0;
        dis[i] = inf;
        // 最大值模式，最小值改-inf
    }
    while (!que.empty()) que.pop();
    dis[s] = 0;
    que.push(s);
    int u, v, l;
    while (!que.empty()) {
        u = que.front();
        que.pop();
        vis[u] = 0;
        for (int i = head[u]; i != -1; i = e[i].nxt) {
            v = e[i].to; l = e[i].l;
            if (dis[u] + l < dis[v]) {
                // 最大值模式，最小值改减号
                dis[v] = dis[u] + l;
                if (vis[v]) continue;
                vis[v] = 1;
                counts[v]++;
                que.push(v);
                if (counts[v] == n) return 1;
            }
        }
    }
    return 0;
}

int main() {
    scanf("%d", &T);
    int cas = 1;
    while (T--) {
        int x;
        scanf("%d%d%d",&n,&m,&x);
        init();
        while (m--) {
            int a, b, c, d;
            scanf("%d%d%d%d", &a, &b, &c, &d);
            if (a == b && c == d) {
                add_edge(a, c, x); add_edge(c, a, -x);
                // add_edge(c, a, -x); add_edge(a, c, x);
            } else if (a == b && d == c + 1) {
                add_edge(a, c, x - 1); add_edge(c + 1, a, -x - 1);
                // add_edge(c, a, -x + 1); add_edge(a, c + 1, x + 1);
            } else if(b == a + 1 && c == d) {
                add_edge(a + 1, c, x - 1); add_edge(c, a, -x - 1);
                // add_edge(c, a + 1, -x + 1); add_edge(a, c, x + 1);
            } else {
                add_edge(a + 1, c, x - 2); add_edge(c + 1, a, -x - 2);
                // add_edge(c, a + 1, -x + 2); add_edge(a, c + 1, x + 2);
            }
        }
        for (int i = 1; i <= n - 1; i++) {
            add_edge(i + 1, i, -1);
            // add_edge(i, i + 1, 1);
        }
        printf("Case #%d: ", cas++);
        bool f = !spfa(n);
        if(!f) printf("IMPOSSIBLE\n");
        else {
            for (int i = 1; i <= n; i++) if (dis[i] == inf) dis[i] = 0;
            for (int i = 2; i <= n; i++) if (dis[i] - dis[i - 1] > 2000000000) f = false;
            if (!f) printf("IMPOSSIBLE\n");
            else {
                for (int i = 1; i < n; i++) {
                    printf("%lld%c", dis[i + 1] - dis[i], i == n - 1 ? '\n' : ' ');
                }
            }
        }
    }
    return 0;
}
```

## K短路

```c++
int n, m, s, e, k, t;
vector<PII> edge[maxn], edge1[maxn];

int vis[maxn], dis[maxn];
int dijkstra(int beg = 1) {
    ms(vis, 0);
    for (int i = 1; i <= n; i++) dis[i] = inf;
    dis[beg] = 0;
    priority_queue<PII, vector<PII>, greater<PII> > q; q.emplace(0, beg);
    while (!q.empty()) {
        PII t = q.top(); q.pop();
        int u = t.second;
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &x : edge1[u]) {
            int v = x.first;
            if (vis[v]) continue;
            if (dis[v] > dis[u] + x.second) {
                dis[v] = dis[u] + x.second;
                q.emplace(dis[v], v);
            }
        }
    }
    return 0;
}

struct node{
    int to, f, g;
    node() {}
    node(int tt, int ff, int gg): to(tt), f(ff), g(gg) {}
    bool operator < (const node &t) const{
        if(t.f == f) return t.g < g;
        return t.f < f;
    }
};

int astar() {
    priority_queue<node> q; q.emplace(s, dis[s], 0);
    int cnt = 0;
    if (dis[s] == inf) return inf;
    while (!q.empty()) {
        node t = q.top(); q.pop();
        if (t.to == e) cnt++;
        if (cnt == k) return t.g;
        for (auto &x : edge[t.to]) {
            q.emplace(x.first, t.g + x.second + dis[x.first], t.g + x.second);
        }
    }
    return inf;
}

int main() {
    while (~scanf("%d%d", &n, &m)) {
        scanf("%d%d%d%d", &s, &e, &k, &t);
        for (int i = 0; i <= n; i++) edge[i].clear(), edge1[i].clear();
        while (m--) {
            int u, v, w; scanf("%d%d%d", &u, &v, &w);
            edge[u].emplace_back(v, w);
            edge1[v].emplace_back(u, w);
        }
        dijkstra(e);
        int ans = astar();
        if (ans <= t) puts("yareyaredawa");
        else puts("Whitesnake!");
    }
    return 0;
}
```

## 最小生成树

### Kruskal

```c++
struct edge{char x, y; int d;};
bool cmp(const edge& a, const edge& b) {
    return a.d < b.d;
}
vector<edge> v;

int n, pre[maxn];
void init() {
    for (int i = 0; i < maxn; i++) pre[i] = i;
}
int find(int x) {return x == pre[x] ? x : pre[x] = find(pre[x]);}
void join(int x, int y) {
    x = find(x), y = find(y);
    pre[x] = y;
}
int kruskal() {
    sort(v.begin(), v.end(), cmp);
    int ans = 0;
    for (int i = 0, a, b; i < v.size(); i++) {
        a = find(v[i].x - 'A'), b = find(v[i].y - 'A');
        if (a == b) continue;
        join(a, b); ans += v[i].d;
    }
    return ans;
}
```

### Borůvka

给定一个无向完全图，$i$ 和 $j$ 的边权为 $D|i-j|+a_i+a_j$，求最小生成树。

来源：[KEYENCE Programming Contest 2019 E - Connecting Cities](https://atcoder.jp/contests/keyence2019/tasks/keyence2019_e)

```c++
const ll inf = 1ll << 60;
const int maxn = 200000 + 5;

int n, d, a[maxn];

ll F(int i) {
  return -1ll * i * d + a[i];
}
ll G(int i) {
  return 1ll * i * d + a[i];
}

struct SegT {
  #define lson l, m, rt << 1
  #define rson m + 1, r, rt << 1 | 1
  ll mn[maxn << 2]; int pos[maxn << 2];
  void pushup(int rt) {
    if (mn[rt << 1] < mn[rt << 1 | 1]) {
      mn[rt] = mn[rt << 1];
      pos[rt] = pos[rt << 1];
    } else {
      mn[rt] = mn[rt << 1 | 1];
      pos[rt] = pos[rt << 1 | 1];
    }
  }
  void build(function<ll(int)> f, int l = 1, int r = n, int rt = 1) {
    if (l == r) {
      mn[rt] = f(l); pos[rt] = l;
      return ;
    }
    int m = (l + r) / 2;
    build(f, lson); build(f, rson);
    pushup(rt);
  }
  void update(int i, ll x, int l = 1, int r = n, int rt = 1) {
    if (l == r) {
      mn[rt] = x; return ;
    }
    int m = (l + r) / 2;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    pushup(rt);
  }
  pair<ll,int> query(int L, int R, int l = 1, int r = n, int rt = 1) {
    if (L <= l && r <= R) return { mn[rt], pos[rt] };
    int m = (l + r) / 2;
    pair<ll,int> ans(inf, -1);
    if (L <= m) ans = query(L, R, lson);
    if (R > m) ans = min(ans, query(L, R, rson));
    return ans;
  }
} pr, sf;

int pre[maxn], siz[maxn], last[maxn], nxt[maxn];
int find(int x) {
  return x == pre[x] ? x : pre[x] = find(pre[x]);
}
int join(int x, int y) {
  x = find(x); y = find(y);
  if (x == y) return false;
  if (siz[x] > siz[y]) swap(x, y);
  pre[x] = y; siz[y] += siz[x];
  return true;
}

int main() {
  scanf("%d%d", &n, &d);
  for (int i = 1; i <= n; i++) {
    scanf("%d", a + i);
    pre[i] = i; siz[i] = 1;
  }
  pr.build(F); sf.build(G);
  ll ans = 0;
  for (int T = 1; T <= 20; T++) {
    for (int i = 1; i <= n; i++) last[i] = 0;
    for (int i = 1; i <= n; i++) {
      nxt[i] = last[find(i)];
      last[find(i)] = i;
    }
    vector<PII> egs;
    for (int i = 1; i <= n; i++) {
      if (i != find(i)) continue;
      for (int x = last[i]; x; x = nxt[x]) {
        pr.update(x, inf); sf.update(x, inf);
      }
      ll mn = inf; int u, v;
      for (int x = last[i]; x; x = nxt[x]) {
        if (x < n) {
          auto r = sf.query(x + 1, n);
          ll sum = r.first + F(x);
          if (r.second != -1 && sum < mn) {
            mn = sum; u = x; v = r.second;
          }
        }
        if (x > 1) {
          auto r = pr.query(1, x - 1);
          ll sum = r.first + G(x);
          if (r.second != -1 && sum < mn) {
            mn = sum; u = x; v = r.second;
          }
        }
      }
      if (mn < inf) {
        egs.emplace_back(u, v);
      }
      for (int x = last[i]; x; x = nxt[x]) {
        pr.update(x, F(x)); sf.update(x, G(x));
      }
    }
    if (egs.empty()) break;
    for (auto& e: egs) {
      int u = e.first,  v = e.second;
      if (join(u, v)) {
        ans += 1ll * d * abs(u - v) + a[u] + a[v];
      }
    }
  }
  cout << ans << endl;
  return 0;
}
```

## 斯坦纳树

```c++
const ll inf = 1ll << 60;
const int mod = 998244353;
const int maxn = 1010 + 5;

bool vis[1 << 6][maxn];
struct node{
    int to; ll d;
    bool operator< (const node& b)const{
        return d > b.d;
    }
};

vector<PII> edge[maxn];
int n, m, p, a[maxn];
ll dp[1 << 6][maxn];

int main() {
    while (scanf("%d%d%d", &n, &m, &p) == 3) {
        ms(vis, 0);
        for (int i = 0; i <= n + m; i++) edge[i].clear();
        for (int i = 1; i <= n + m; i++) {
            scanf("%d", a + i);
            edge[0].push_back({i, a[i]});
            edge[i].push_back({0, a[i]});
        }
        for (int i = 1, u, v, w; i <= p; i++) {
            scanf("%d%d%d", &u, &v, &w);
            edge[u].push_back({v, w});
            edge[v].push_back({u, w});
        }
        int ss = 1 << (n + 1);
        for (int s = 1; s < ss; s++) for (int u = 0; u <= n + m; u++) dp[s][u] = inf;
        for (int u = 0; u <= n; u++) dp[1 << u][u] = 0;
        priority_queue<node> pq;
        for (int s = 1; s < ss; s++) {
            for (int u = 0; u <= n + m; u++) {
                for (int t = s; t; t = (t - 1) & s) {
                    dp[s][u] = min(dp[s][u], dp[t][u] + dp[s ^ t][u]);
                }
            }
            for (int u = 0; u <= n + m; u++) if (dp[s][u] != inf) pq.push({u, dp[s][u]});
            while (!pq.empty()) {
                node tp = pq.top(); pq.pop();
                if (vis[s][tp.to]) continue;
                vis[s][tp.to] = 1;
                for (auto& x: edge[tp.to]) {
                    if (dp[s][x.first] > dp[s][tp.to] + x.second) {
                        dp[s][x.first] = dp[s][tp.to] + x.second;
                        pq.push({x.first, dp[s][x.first]});
                    }
                }
            }
        }
        ll ans = inf;
        for (int i = 0; i <= n + m; i++) ans = min(ans, dp[ss - 1][i]);
        printf("%lld\n", ans);
    }
    return 0;
}
```

## 拓扑排序

```c++
vector<int> edge[maxn], v;
int ind[maxn], n, m;

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        ms(ind, 0); v.clear(); for (int i = 1; i <= n; i++) edge[i].clear();
        while (m--) {
            int x, y; scanf("%d%d", &x, &y);
            edge[y].push_back(x); ind[x]++;
        }
        priority_queue<int, vector<int>, less<int> > pq;
        for (int i = 1; i <= n; i++) if (!ind[i]) pq.push(i);
        while (!pq.empty()) {
            int t = pq.top(); pq.pop();
            v.push_back(t);
            for (int i = 0; i < edge[t].size(); i++) {
                ind[edge[t][i]]--;
                if (!ind[edge[t][i]]) pq.push(edge[t][i]);
            }
        }
        reverse(v.begin(), v.end());
        for (int i = 0; i < v.size(); i++) {
            if (i) putchar(' ');
            printf("%d", v[i]);
        }
        puts("");
    }
    return 0;
}
```

## 欧拉图

```c++
namespace UndirectedGraph {
  struct Edge {
    int to, nxt;
  } E[maxn];
  int ecnt = 1, head[maxn], vis[maxn];
  
  void adde(int u, int v) {
    E[++ecnt] = { v, head[u] };
    head[u] = ecnt;
  }

  int n, m, deg[maxn], ans[maxn], tot;

  void dfs(int u) {
    for (int& i = head[u]; i; i = E[i].nxt) {
      if (vis[i / 2]) continue;
      vis[i / 2] = true;
      int id = (i / 2) * (i % 2 == 0 ? 1 : -1);
      int v = E[i].to;
      dfs(v);
      ans[++tot] = id;
    }
  }
  
  void solve() {
    read(n, m);
    for (int i = 1; i <= m; i++) {
      int u, v;
      read(u, v);
      deg[u]++;
      deg[v]++;
      adde(u, v);
      adde(v, u);
    }
    for (int i = 1; i <= n; i++) {
      if (deg[i] % 2 == 1) {
        puts("NO");
        return ;
      }
    }
    for (int i = 1; i <= n; i++) {
      if (head[i]) {
        dfs(i);
        break;
      }
    }
    if (tot == m) {
      puts("YES");
      for (int i = m; i >= 1; i--) {
        write(ans[i], " \n"[i == 1]);
      }
    } else {
      puts("NO");
    }
  }
}

namespace DirectedGraph {
  struct Edge {
    int to, nxt;
  } E[maxn];
  int ecnt, head[maxn], vis[maxn];
  void adde(int u, int v) {
    E[++ecnt] = { v, head[u] };
    head[u] = ecnt;
  }
  
  int n, m, ind[maxn], oud[maxn], ans[maxn], tot;

  void dfs(int u) {
    for (int& i = head[u]; i; i = E[i].nxt) {
      if (vis[i]) continue;
      vis[i] = true;
      int id = i;
      int v = E[i].to;
      dfs(v);
      ans[++tot] = id;
    }
  }

  void solve() {
    read(n, m);
    for (int i = 1; i <= m; i++) {
      int u, v;
      read(u, v);
      oud[u]++;
      ind[v]++;
      adde(u, v);
    }
    for (int i = 1; i <= n; i++) {
      if (ind[i] != oud[i]) {
        puts("NO");
        return ;
      }
    }
    for (int i = 1; i <= n; i++) {
      if (head[i]) {
        dfs(i);
        break;
      }
    }
    if (tot == m) {
      puts("YES");
      for (int i = m; i >= 1; i--) {
        write(ans[i], " \n"[i == 1]);
      }
    } else {
      puts("NO");
    }
  }
}
```

## 二分图

### 概念

1. 最小顶点覆盖 = 最大匹配数：选择最少的顶点来覆盖所有的边。
2. 最大独立集 = 顶点数 - 最小顶点覆盖：选出最多的顶点，使得这些顶点两两不相邻。
3. 最大团 = 补图最大独立集：选出最多的顶点，使得这些顶点两两之间都有边。

### 匈牙利算法

```c++
int line[maxn][maxn], k, m, n, vis[maxn], nxt[maxn];

int find(int p) {
    for (int i = 1; i <= n; i++) {
        if (line[p][i] && !vis[i]) {
            vis[i] = 1;
            if (!nxt[i] || find(nxt[i])) {
                nxt[i] = p;
                return true;
            }
        }
    }
    return false;
}
int match() {
    int sum = 0;
    for (int i = 1; i <= m; i++) {
        ms(vis, 0);
        if (find(i)) sum++;
    }
    return sum;
}
```

### Hopcroft Karp 算法

时间复杂度：$O(|E|\sqrt{|V|})$。

```c++
namespace hk {
  int n, ans;
  int dx[maxn], dy[maxn];
  int linkx[maxn], linky[maxn];
  int head[maxn], to[maxn * maxn], nxt[maxn * maxn], ecnt;

  void clear(int N) {
    n = N; ecnt = ans = 0;
    ms(linkx, 0xff); ms(linky, 0xff); ms(head, 0);
  }
  void adde(int u, int v) {
    to[++ecnt] = v; nxt[ecnt] = head[u]; head[u] = ecnt;
    if (linkx[u] == -1 && linky[v] == -1) {
      linkx[u] = v;
      linky[v] = u;
      ans++;
    }
  }
  bool bfs() {
    bool res = 0;
    static int q[maxn], l, r;

    ms(dx, 0); ms(dy, 0);
    l = r = 0;
    for (int i = 1; i <= n; i++)
      if (linkx[i] == -1) q[r++] = i;

    while (l < r) {
      int x = q[l++];
      for (int i = head[x]; i; i = nxt[i]) {
        if (!dy[to[i]]) {
          dy[to[i]] = dx[x] + 1;
          if (linky[to[i]] == -1) res = 1;
          else dx[q[r++] = linky[to[i]]] = dy[to[i]] + 1;
        }
      }
    }
    return res;
  }
  bool dfs(int u) {
    for (int i = head[u]; i; i = nxt[i]) {
      if (dx[u] + 1 == dy[to[i]]) {
        dy[to[i]] = 0;
        if (linky[to[i]] == -1 || dfs(linky[to[i]])) {
          linky[to[i]] = u;
          linkx[u] = to[i];
          return true;
        }
      }
    }
    return false;
  }
  int match(int n) {
    // clear(n): 1 ~ n
    while (bfs()) {
      for (int i = 1; i <= n; i++) {
        if (linkx[i] == -1) ans += dfs(i);
      }
    }
    return ans;
  }
}
```

#### 独立集 / 点覆盖方案

```c++
bool visx[maxn], visy[maxn];
void mark(int u) {
    if (visx[u]) return ;
    visx[u] = true;
    for (int i = head[u]; i; i = nxt[i]) {
        if (to[i] == linkx[u]) continue;
        visy[to[i]] = true;
        assert(linky[to[i]] != -1);
        mark(linky[to[i]]);
    }
}

for (int i = 0; i < (int)bag[0].size(); i++) {
    if (f.linkx[i] == -1) {
        f.mark(i);
    }
}
vector<int> plan;
// 独立集
for (int i = 0; i < (int)bag[0].size(); i++) if (f.visx[i]) plan.push_back(bag[0][i]);
for (int i = 0; i < (int)bag[1].size(); i++) if (!f.visy[i]) plan.push_back(bag[1][i]);
```

### KM 算法

来源：[2019-2020 ACM-ICPC Brazil Subregional Programming Contest G. Getting Confidence](https://codeforces.com/gym/102346/problem/G)

```c++
template<typename T>
struct KM {
    T dbx[maxn], dby[maxn], slack[maxn], C[maxn][maxn];
    int linky[maxn], pre[maxn];
    bool vis[maxn];
    int nx, ny;

    void bfs(int k) {
        int px, py = 0, yy = 0; T d;
        memset(pre, 0, sizeof pre);
        for (int i = 0; i <= ny; i++) slack[i] = inf;
        linky[py] = k;
        do {
            px = linky[py]; d = inf; vis[py] = 1;
            for (int i = 1; i <= ny; i++) {
                if (vis[i] == 0) {
                    if (slack[i] > dbx[px] + dby[i] - C[px][i])
                        slack[i] = dbx[px] + dby[i] - C[px][i], pre[i]=py;
                    if (slack[i] < d)
                        d = slack[i], yy = i;
                }
            }
            for (int i = 0; i <= ny; i++)
                if (vis[i]) dbx[linky[i]] -= d, dby[i] += d;
                else slack[i] -= d;
            py = yy;
        } while (linky[py] != 0);
        while (py) linky[py] = linky[pre[py]], py = pre[py];
    }

    T km(int n, int m) {
        nx = n; ny = m;
        memset(dbx, 0, sizeof dbx);
        memset(dby, 0, sizeof dby);
        memset(linky, 0, sizeof linky);
        for (int i = 1; i <= nx; i++) {
            memset(vis, 0, sizeof vis); bfs(i);
        }
        T ans = 0;
        for (int i = 1; i <= ny; i++) {
            if (linky[i]) ans += dbx[linky[i]] + dby[i];
        }
        return ans;
    }
};

KM<float> f;

int main() {
    int n;
    scanf("%d",&n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            scanf("%f", &f.C[i][j]);
            f.C[i][j] = log(f.C[i][j]);
        }
    }
    f.km(n, n);
    for (int i = 1; i <= n; i++) {
        printf("%d%c", f.linky[i], i == n ? '\n' : ' ');
    }
}
```

### 一般图匹配

来源：[2020 牛客多校 Day1 I](https://ac.nowcoder.com/acm/contest/5666/I)

```c++
const int maxn = 500;

deque<int> Q;
// g[i][j]存放关系图：i,j是否有边,match[i]存放i所匹配的点
bool g[maxn][maxn], inque[maxn], inblossom[maxn];
int match[maxn], pre[maxn], base[maxn];

//找公共祖先
bool inpath[maxn] = { false };
int findancestor(int u, int v) {
  while (1) {
    u = base[u];
    inpath[u] = true;
    if (match[u] == -1) break;
    u = pre[match[u]];
  }
  while (1) {
    v = base[v];
    if (inpath[v]) return v;
    v = pre[match[v]];
  }
}

//压缩花
void reset(int u, int anc) {
  while (u != anc) {
    int v = match[u];
    inblossom[base[u]] = 1;
    inblossom[base[v]] = 1;
    v = pre[v];
    if (base[v] != anc) pre[v] = match[u];
    u = v;
  }
}

void contract(int u, int v, int n) {
  int anc = findancestor(u, v);
  memset(inblossom, 0, sizeof(inblossom));
  reset(u, anc);
  reset(v, anc);
  if (base[u] != anc) pre[u] = v;
  if (base[v] != anc) pre[v] = u;
  for (int i = 1; i <= n; i++)
    if (inblossom[base[i]]) {
      base[i] = anc;
      if (!inque[i]) {
        Q.push_back(i);
        inque[i] = 1;
      }
    }
}

bool dfs(int S, int n) {
  for (int i = 0; i <= n; i++) pre[i] = -1, inque[i] = 0, base[i] = i;
  Q.clear();
  Q.push_back(S);
  inque[S] = 1;
  while (!Q.empty()) {
    int u = Q.front();
    Q.pop_front();
    for (int v = 1; v <= n; v++) {
      if (g[u][v] && base[v] != base[u] && match[u] != v) {
        if (v == S || (match[v] != -1 && pre[match[v]] != -1))
          contract(u, v, n);
        else if (pre[v] == -1) {
          pre[v] = u;
          if (match[v] != -1)
            Q.push_back(match[v]), inque[match[v]] = 1;
          else {
            u = v;
            while (u != -1) {
              v = pre[u];
              int w = match[v];
              match[u] = v;
              match[v] = u;
              u = w;
            }
            return true;
          }
        }
      }
    }
  }
  return false;
}

int n, m, a, b, ans;

void init() {
  memset(match, -1, sizeof(match));
  memset(g, 0, sizeof(g));
  ans = 0;
}

int main() {
  while (scanf("%d%d", &n, &m) != EOF) {
    for (int i = 1; i <= m; i++) {
      scanf("%d%d", &a, &b);
      g[a][b] = g[b][a] = 1;
    }
    for (int i = 1; i <= n; i++) {
      if (match[i] == -1 && dfs(i, n)) {
        ans++;  // ans记录最多有几对匹配
      }
    }
    if (ans * 2 == n) puts("Yes");
    else puts("No");
  }
  return 0;
}
```

## 网络流

### 最大权闭合子图

闭合子图：子图中每个点的出边指向的结点也在子图内。

有 $n$ 个商品，$m$ 个物资，生产一个商品需要某些物资，商品有价值，物资有费用（出现时只算一次），求最大利益。

建一个超级源点 $S$ 指向所有商品，容量为商品权值，建一个超级汇点 $T$，所有物资指向 $T$，容量为物资费用。

对于依赖关系，建一条容量为无穷大的边。

最大权闭合子图为商品正权值之和减去最大流（最小割）。

最大权闭合子图为最后所有与超级源点相连的点。

### Dinic

```c++
struct Dinic {
    struct Edge {
        int from, to; ll cap, flow;
        Edge(int u, int v, ll c, ll f): from(u), to(v), cap(c), flow(f) {}
    };

    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[maxn];
    bool vis[maxn];
    int dep[maxn], cur[maxn];
    void init(int _n) {
        n = _n;
        for (int i = 0; i <= n; i++) G[i].clear();
        edges.clear();
    }
    void adde(int from, int to, ll cap) {
        edges.emplace_back(from, to, cap, 0);
        edges.emplace_back(to, from, 0, 0);
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool bfs() {
        ms(vis, 0); ms(dep, 0);
        queue<int> q; q.push(s);
        dep[s] = 0; vis[s] = 1;
        while (!q.empty()) {
            int x = q.front(); q.pop();
            for (int i = 0; i < G[x].size(); i++) {
                Edge& e = edges[G[x][i]];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = 1;
                    dep[e.to] = dep[x] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    ll dfs(int x, ll a) {
        if (x == t || a == 0) return a;
        ll flow = 0, f;
        for (int& i = cur[x]; i < G[x].size(); i++) {
            //从上次考虑的弧
            Edge& e = edges[G[x][i]];
            if (dep[x] + 1 == dep[e.to] && (f = dfs(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0) break;
            }
        }
        return flow;
    }
    ll get(int s, int t) {
        this->s = s, this->t = t;
        ll flow = 0;
        while (bfs()) {
            ms(cur, 0);
            flow += dfs(s, inf);
        }
        return flow;
    }
} f;
```

### SAP

```C++
const int INF = 0x3f3f3f3f;

const int maxn = 100010; // 点数的最大值
const int maxm = 400010; // 边数的最大值

struct edge {
    int to, next, cap, flow;
} e[maxm];

int tol;
int head[maxn];
int gap[maxn], dep[maxn], cur[maxn];

void init() {
    tol = 0;
    memset(head, -1, sizeof(head));
}
void addedge(int u, int v, int w, int rw = 0) {
    e[tol].to = v; e[tol].cap = w; e[tol].flow = 0;
    e[tol].next = head[u]; head[u] = tol++;
    e[tol].to = u; e[tol].cap = rw; e[tol].flow = 0;
    e[tol].next = head[v]; head[v] = tol++;
}

int Q[maxn];
void bfs(int s, int t) {
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[t] = 0;
    Q[rear++] = t;
    while (front != rear) {
        int u = Q[front++];
        for (int i = head[u]; i != -1; i = e[i].next) {
            int v = e[i].to;
            if (dep[v] != -1)continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}

int S[maxn];
int sap(int s, int t, int N) {
    bfs(s, t);
    memcpy(cur, head, sizeof(head));
    int top = 0;
    int u = s;
    int ans = 0;
    while (dep[s] < N) {
        if (u == t) {
            int Min = INF;
            int inser;
            for (int i = 0; i < top; i++)
                if (Min > e[S[i]].cap - e[S[i]].flow) {
                    Min = e[S[i]].cap - e[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i < top; i++) {
                e[S[i]].flow += Min;
                e[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = e[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = e[i].next) {
            v = e[i].to;
            if (e[i].cap - e[i].flow && dep[v] + 1 == dep[u]) {
                flag = true;
                cur[u] = i;
                break;
            }
        }
        if (flag) {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = e[i].next)
            if (e[i].cap - e[i].flow && dep[e[i].to] < Min) {
                Min = dep[e[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != s) u = e[S[--top] ^ 1].to;
    }
    return ans;
}

int main(){
    int T; scanf("%d", &T);
    int n, m, u, v, w, s, t, minx, maxx, x, y;
    while (T--) {
        scanf("%d%d", &n, &m);
        init();
        minx = 1000000; maxx = -1000000;
        for (int i = 1; i <= n; i++) {
            scanf("%d%d", &x, &y);
            if (x < minx) {
                minx = x; s = i;
            }
            if (maxx < x) {
                maxx = x; t = i;
            }
        }
        for (int i = 1; i <= m; i++) {
            scanf("%d%d%d", &u, &v, &w);
            addedge(u, v, w);
            addedge(v, u, w);
        }
        printf("%d\n", sap(s, t, n));
    }
    return 0;
}
```

### 最小费用最大流

```c++
struct MCMF {
  struct E {
    int from, to, cap, v;
    E() {}
    E(int f, int t, int cap, int v) : from(f), to(t), cap(cap), v(v) {}
  };

  int n, m, s, t;
  vector<E> edges;
  vector<int> G[maxn];
  bool inq[maxn];
  int dis[maxn], pre[maxn], a[maxn];

  void init(int _n, int _s, int _t) {
    n = _n; s = _s; t = _t;
    for (int i = 0; i <= n; i++) {
      G[i].clear();
    }
    edges.clear();
    m = 0;
  }

  void add(int from, int to, int cap, int cost) {
    edges.emplace_back(from, to, cap, cost);
    edges.emplace_back(to, from, 0, -cost);
    G[from].push_back(m++);
    G[to].push_back(m++);
  }

  bool spfa() {
    for (int i = 0; i <= n; i++) {
      dis[i] = 1e9;
      pre[i] = -1;
      inq[i] = false;
    }
    dis[s] = 0, a[s] = 1e9, inq[s] = true;
    queue<int> Q; Q.push(s);
    while (!Q.empty()) {
      int u = Q.front(); Q.pop();
      inq[u] = false;
      for (int& idx: G[u]) {
        E& e = edges[idx];
        if (e.cap && dis[e.to] > dis[u] + e.v) {
          dis[e.to] = dis[u] + e.v;
          pre[e.to] = idx;
          a[e.to] = min(a[u], e.cap);
          if (!inq[e.to]) {
            inq[e.to] = true;
            Q.push(e.to);
          }
        }
      }
    }
    return pre[t] != -1;
  }

  int solve() {
    int flow = 0, cost = 0;
    while (spfa()) {
      flow += a[t];
      cost += a[t] * dis[t];

      int u = t;
      while (u != s) {
        edges[pre[u]].cap -= a[t];
        edges[pre[u] ^ 1].cap += a[t];
        u = edges[pre[u]].from;
      }
    }
    return cost;
  }
} f;
```

#### Dijkstra 优化

```c++
struct MCMF {
    struct edge {
        int to, flow, cost, rev;
        edge() {}
        edge(int to, int f, int cost, int r): to(to), flow(f), cost(cost), rev(r) {}
    };
    int V, H[maxn + 5], dis[maxn + 5], preV[maxn + 5], preE[maxn + 5];
    vector<edge> G[maxn + 5];
    void init(int n) {
        V = n;
        for (int i = 0; i <= V; ++i) G[i].clear();
    }
    void add(int from, int to, int cap, int cost) {
        G[from].push_back(edge(to, cap, cost, (int)G[to].size()));
        G[to].push_back(edge(from, 0, -cost, (int)G[from].size() - 1));
    }
    int getmin(int s, int t, int f, int& flow) {
        int ans = 0;
        fill(H, H + 1 + V, 0);
        while (f) {
            priority_queue<PII,vector<PII>,greater<PII> > q;
            fill(dis, dis + 1 + V, inf);
            dis[s] = 0; q.push({0, s});
            while (!q.empty()) {
                PII now = q.top(); q.pop();
                int v = now.second;
                if (dis[v] < now.first) continue;
                for (int i = 0; i < G[v].size(); ++i) {
                    edge& e = G[v][i];
                    if (e.flow > 0 && dis[e.to] > dis[v] + e.cost + H[v] - H[e.to]) {
                        dis[e.to] = dis[v] + e.cost + H[v] - H[e.to];
                        preV[e.to] = v;
                        preE[e.to] = i;
                        q.push({dis[e.to], e.to});
                    }
                }
            }
            if (dis[t] == inf) break;
            for (int i = 0; i <= V; ++i) H[i] += dis[i];
            int d = f;
            for (int v = t; v != s; v = preV[v]) d = min(d, G[preV[v]][preE[v]].flow);
            f -= d; flow += d; ans += d * H[t];
            for (int v = t; v != s; v = preV[v]) {
                edge& e = G[preV[v]][preE[v]];
                e.flow -= d;
                G[v][e.rev].flow += d;
            }
        }
        return ans;
    }
} f;

// f.getmin(s, t, inf, flow);
```

## Tarjan

```c++
namespace Tarjan {
    vector<int> st;
    int id, dfn[maxn], low[maxn], vis[maxn];
    int cnt, bel[maxn], ind[maxn], oud[maxn], mn[maxn];
    void dfs(int u) {
        dfn[u] = low[u] = ++id;
        vis[u] = 1; st.push_back(u);
        for (int i = 0; i < edge[u].size(); i++) {
            int v = edge[u][i];
            if (!dfn[v]) {
                dfs(v); low[u] = min(low[u], low[v]);
            } else if (vis[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            cnt++; int t = 0;
            do {
                t = st.back(); st.pop_back();
                bel[t] = cnt;
                vis[t] = 0;
            } while (t != u);
        }
    }
    void clear() {
        ms(dfn, 0); ms(vis, 0);
        ms(ind, 0); ms(oud, 0);
        st.clear();
        cnt = id = 0;
    }
}
```

### 边双联通分量 BCC 缩点

```c++
int cnt, bel[maxn]; // important!
namespace Tarjan {
    int tot, dfn[maxn], low[maxn], st[maxn], top, vis[maxn];
    void clear(int n) {
        tot = top = cnt = 0;
        for (int i = 1; i <= n; i++) {
            edge[i].clear(); dfn[i] = vis[i] = bel[i] = 0;
        }
    }
    void dfs(int u, int f) {
        dfn[u] = low[u] = ++tot;
        st[++top] = u; vis[u] = 1;
        int k = 0;
        for (int& v: edge[u]) {
            if (v == f && !k) {
                k++; continue;
            }
            if (!dfn[v]) {
                dfs(v, u); low[u] = min(low[u], low[v]);
            } else if (vis[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            cnt++; int t = 0;
            do {
                t = st[top--];
                bel[t] = cnt;
                vis[t] = 0;
            } while (t != u);
        }
    }
    void scc(int n, vector<int> * g) {
        for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan::dfs(i, 0);
        for (int i = 1; i <= n; i++) g[i].clear();
        for (int i = 1; i <= n; i++) {
            int u = bel[i];
            for (int& x: edge[i]) {
                int v = bel[x];
                if (u != v) {
                    g[u].push_back(v);
                }
            }
        }
    }
}
```

### 桥

```c++
struct edge{int to, nxt;}f[4 * maxn];
int head[maxn], cnt;
void add(int x, int y) {
    f[++cnt].to = y; f[cnt].nxt = head[x]; head[x] = cnt;
}

int n, m, q;
int tot = 0, dfn[maxn], low[maxn], dep[maxn], fa[maxn];
int cut[maxn], br;

void dfs(int p, int old) {
    dfn[p] = low[p] = ++tot;
    dep[p] = dep[old] + 1;
    for (int i = head[p]; i; i = f[i].nxt) {
        int v = f[i].to;
        if (v == old) continue;
        if (!dfn[v]) {
            fa[v] = p;
            dfs(v, p);
            low[p] = min(low[p], low[v]);
            if (low[v] > dfn[p]) {
                cut[v] = 1;
                br++;
            }
        } else low[p] = min(low[p], dfn[v]);
    }
}
```

### 2-SAT

```c++
vector<int> edge[maxn], ans;
int n, m, bel[maxn];

bool dfs(int x) {
    if (bel[x]) return bel[x] % 2;
    bel[x] = 1; bel[x ^ 1] = 2;
    ans.push_back(x);
    for (auto& v : edge[x]) {
        if (!dfs(v)) return false;
    }
    return true;
}

bool cal() {
    ms(bel, 0);
    for (int i = 0; i < 2 * n; i++) {
        if (bel[i]) continue;
        ans.clear();
        if (!dfs(i)) {
            for (int& x : ans) bel[x] = bel[x ^ 1] = 0;
            if (!dfs(i ^ 1)) return false;
        }
    }
    return true;
}
```

## 一般图最大独立集

### 最大团

```c++
struct Max_Clique {
    static const int N = 100;
    vector<int> sol;
    int el[N][N / 30 + 1], s[N][N / 30 + 1];
    int n, ans, dp[N];
    void init(int _n) {
        n = _n;
        for(int i = 0; i <= n; i++) {
            dp[i] = 0;
            ms(el[i], 0);
        }
    }
    /* Zero Base */
    void add_edge(int a,int b) {
        if(a > b) swap(a, b);
        if(a == b) return;
        el[a][b / 32] |= (1 << (b % 32));
    }
    bool dfs(int x,int k) {
        int c = 0, d = 0;
        for(int i = 0; i < (n + 31) / 32; i++) {
            s[k][i] = el[x][i];
            if (k != 1) s[k][i] &= s[k - 1][i];
            c += __builtin_popcount(s[k][i]);
        }
        if (c == 0) {
            if(k > ans) {
                ans = k;
                sol.clear();
                sol.push_back(x);
                return 1;
            }
            return 0;
        }
        for (int i = 0; i < (n + 31) / 32; i++) {
            for (int a = s[k][i]; a; d++) {
                if (k + (c - d) <= ans) return 0;
                int lb = a & (-a), lg = 0;
                a ^= lb;
                while (lb!=1) {
                    lb = (unsigned int)(lb) >> 1;
                    lg++;
                }
                int u = i * 32 + lg;
                if (k + dp[u] <= ans) return 0;
                if (dfs(u, k + 1)) {
                    sol.push_back(x);
                    return 1;
                }
            }
        }
        return 0;
    }
    int solve() {
        ans = 0;
        for(int i = n - 1; i >= 0; i--) {
            dfs(i,1);
            dp[i] = ans;
        }
        return ans;
    }
} mcp;
```

### 随机化

```c++
const int maxn = 100 + 5;

int n, m, p[maxn], vis[maxn], G[maxn][maxn];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; i++) {
        scanf("%d%d", &u, &v);
        G[u][v] = G[v][u] = 1;
    }
    for (int i = 1; i <= n; i++) p[i] = i;
    int T = 10000, ans = 0;
    vector<int> rec;
    while (T--) {
        random_shuffle(p + 1, p + 1 + n);
        ms(vis, 0);
        vector<int> v;
        int res = 1; vis[1] = 1;
        v.push_back(p[1]);
        for (int i = 2; i <= n; i++) {
            int flag = 1;
            for (int j = 1; j < i; j++) {
                if (vis[j] && G[p[i]][p[j]]) {
                    flag = 0; break;
                }
            }
            if (flag) {
                v.push_back(p[i]);
                vis[i] = 1; res++;
            }
        }
        if (res > ans) {
            ans = res; rec = v;
        }
    }
    printf("%d\n", ans);
    for (int i = 0; i < (int)rec.size(); i++) {
        if (i) putchar(' ');
        printf("%d", rec[i]);
    }
    return 0;
}
```

## Erdos-Gallai 定理

$n+1$ 个点的图，给出前 $n$ 个点的度数序列，问第 $n+1$ 个点的所有可能取值。

根据握手定理可以知道最后一点度数的奇偶性，并且如果度数可以取到 $x,y(x < y)$，那么 $[ x, y ]$ 中都可以很容易构造出来。

因此可以二分上下界。

对于一个点的度数是否可行，可以应用 [Erdos-Gallai Theorem](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem) 判定。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
const int maxn = 500000 + 5;

bool cmp(int x, int y) { return x > y; }
int n, a[maxn], b[maxn];
ll sum = 0;

int check(int x) {
    for (int i = 1; i <= n; i++) b[i] = a[i]; b[n + 1] = x;
    sort(b + 1, b + n + 2, cmp);
    int p = 0; for (int i = 1; i <= n + 1; i++) if (b[i] == x) p = i;
    ll sum = 0, s2 = 0; int j = n + 1;
    for (int i = 1; i <= n + 1; i++) {
        sum += b[i];
        while (j > i && b[j] <= i) s2 += b[j--];
        if (j < i) s2 -= b[i];
        if (sum > 1ll * i * (i - 1) + s2 + 1ll * i * max(j - i, 0)) {
            if (b[i] > x) return -1;
            else return 1;
        }
    }
    return 0;
}

int main(){
    scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", a + i), sum += a[i];
    sort(a + 1, a + 1 + n, cmp);
    sum %= 2;
    int l = 0, r = (n - sum) / 2, u = -1, d = -1;
    while (l <= r) {
        int m = l + r >> 1;
        if (check(2 * m + sum) == -1) l = m + 1;
        else r = m - 1, d = m;
    }
    l = d, r = (n - sum) / 2;
    while (l <= r) {
        int m = l + r >> 1;
        if (check(2 * m + sum) == 1) r = m - 1;
        else l = m + 1, u = m;
    }
    // cout << u << ' ' << d << endl;
    if (u == -1 || d == -1) return puts("-1"), 0;
    for (int i = d; i <= u; i++) printf("%d ", 2 * i + sum);
    return 0;
}
```

## 同构图

```c++
struct edge{int x, y;};
using G = vector<edge>;

inline G read(int m) {
    G a;
    for (int i = 0; i < m; i++) {
        int x, y; scanf("%d%d", &x, &y);
        a.push_back(edge {x, y});
    }
    return a;
}
inline int count(const G& b, const G& a) {
    ms(vis, 0);
    for (int i = 0; i < a.size(); i++)
        vis[a[i].x][a[i].y] = vis[a[i].y][a[i].x] = 1;
    for (int i = 0; i <= n; i++) f[i] = i;
    int res = 0;
    do{
        bool flag = true;
        for (int i = 0; i < b.size(); i++) {
            if (!vis[f[b[i].x]][f[b[i].y]]) {
                flag = false; break;
            }
        }
        if (flag) res++;
    } while (next_permutation(f + 1, f + 1 + n));
    return res;
}
```

## 线段树优化建图

```c++
const int mod = 998244353;
const int maxn = 500000 + 5;

vector<int> edge[maxn];
int n, b[maxn], a[maxn], pos[maxn], id[maxn], deg[maxn];

void build(int l, int r, int rt) {
    pos[rt] = -1;
    if (l == r) {
        id[l] = rt; pos[rt] = l;
        return ;
    }
    int m = (l + r) >> 1;
    edge[rt << 1].push_back(rt);
    edge[rt << 1 | 1].push_back(rt);
    deg[rt] += 2;
    build(lson); build(rson);
}
void link(int L, int R, int p, int l, int r, int rt) {
    if (L <= l && r <= R) {
        edge[rt].push_back(p);
        deg[p]++;
        return ;
    }
    int m = (l + r) >> 1;
    if (L <= m) link(L, R, p, lson);
    if (R > m) link(L, R, p, rson);
}

int main(){
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", b + i);
    build(0, n - 1, 1);
    for (int i = 0; i < n; i++) {
        if (b[i] % n == i) continue;
        int s = b[i] % n;
        if (s < i) link(s, i - 1, id[i], 0, n - 1, 1);
        else {
            link(s, n - 1, id[i], 0, n - 1, 1);
            if (i) link(0, i - 1, id[i], 0, n - 1, 1);
        }
    }
    int last = 0;
    priority_queue<PII,vector<PII>,greater<PII> > pq;
    for (int i = 0; i < n; i++) {
        if (deg[id[i]] == 0) pq.push({b[i], id[i]});
    }
    while (!pq.empty()) {
        PII t = pq.top(); pq.pop();
        if (t.first != -1) a[last++] = t.first;
        for (int& v: edge[t.second]) {
            deg[v]--;
            if (deg[v] == 0) {
                if (pos[v] == -1) pq.push({-1, v});
                else pq.push({b[pos[v]], v});
            }
        }
    }
    for (int i = 0; i < n; i++) printf("%d%c", a[i], " \n"[i == n - 1]);
    return 0;
}
```

## 树

### 笛卡尔树

```c++
vector<int> stk;
for (int i = 1; i < n; i++) {
  while (!stk.empty() && K[stk.back()] >= K[i]) {
    ls[i] = stk.back();
    stk.pop_back();
  }
  if (!stk.empty()) {
    rs[stk.back()] = i;
  }
  stk.push_back(i);
}
int rt = stk.front();
```

### 虚树

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
const int mod = 998244353;
const int inf = 1 << 30;
const int maxn = 300000 + 5;

int n, q, dfn[maxn], key[maxn], tot;
vector<PII> edge[maxn];

namespace LCA {
    int fa[maxn][20], dep[maxn], mn[maxn][20];
    void dfs(int u, int f) {
        dfn[u] = ++tot; fa[u][0] = f; dep[u] = dep[f] + 1;
        for (int i = 1; i < 20; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            mn[u][i] = min(mn[u][i - 1], mn[fa[u][i - 1]][i - 1]);
        }
        for (auto& x: edge[u]) {
            int v = x.first;
            if (v == f) continue;
            mn[v][0] = x.second;
            dfs(v, u);
        }
    }
    PII qlca(int u, int v) {
        int d = inf;
        if (dep[u] < dep[v]) swap(u, v);
        for (int i = 19; i >= 0; i--) if (dep[fa[u][i]] >= dep[v]) {
            d = min(d, mn[u][i]); u = fa[u][i];
        }
        if (u == v) return { u, d };
        for (int i = 19; i >= 0; i--) {
            if (fa[u][i] == fa[v][i]) continue;
            d = min(d, min(mn[u][i], mn[v][i]));
            u = fa[u][i]; v = fa[v][i];
        }
        return { fa[u][0], d };
    }
}

ll f[maxn];
void dp(int u, int ff) {
    f[u] = 0;
    for (auto& x: edge[u]) {
        int v = x.first;
        if (v == ff) continue;
        dp(v, u);
        if (key[v]) f[u] += x.second;
        else f[u] += min(1ll * x.second, f[v]);
    }
}
namespace VT {
    int stk[maxn], top;
    void build(vector<int>& vec) {
        sort(vec.begin(), vec.end(), [](int a, int b) { return dfn[a] < dfn[b]; });
        stk[top = 1] = 1; edge[1].clear();
        for (int x: vec) {
            if (x == 1) continue;
            int l = LCA::qlca(stk[top], x).first;
            if (l != stk[top]) {
                while (dfn[l] < dfn[stk[top - 1]]) {
                    int w = LCA::qlca(stk[top], stk[top - 1]).second;
                    edge[stk[top - 1]].push_back({stk[top], w}); top--;
                }
                int w = LCA::qlca(l, stk[top]).second;
                if (dfn[l] > dfn[stk[top - 1]]) {
                    edge[l].clear();
                    edge[l].push_back({ stk[top], w });
                    stk[top] = l;
                } else {
                    edge[l].push_back({ stk[top], w });
                    top--;
                }
            }
            edge[x].clear(); stk[++top] = x;
        }
        for (int i = 1; i < top; i++) {
            int w = LCA::qlca(stk[i], stk[i + 1]).second;
            edge[stk[i]].push_back({ stk[i + 1], w });
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        edge[u].push_back({v, w}); edge[v].push_back({u, w});
    }
    LCA::dfs(1, 0);
    scanf("%d", &q);
    while (q--) {
        int k; vector<int> vec;
        scanf("%d", &k);
        for (int i = 1, x; i <= k; i++) {
            scanf("%d", &x);
            vec.push_back(x);
            key[x] = 1;
        }
        VT::build(vec);
        dp(1, 0); printf("%lld\n", f[1]);
        for (int x: vec) key[x] = 0;
    }
    return 0;
}
```

题解：[第 18 届上海大学程序设计联赛 G 血压游戏 题解](https://xlor.cn/2020/4/2020shu-g)。

```c++
ll cal(ll val, int d) {
  if (val == 0) return 0;
  return max(val - d, 1ll);
}

int n, rt, a[maxn];
int tot, dfn[maxn], dep[maxn], fa[20][maxn];
vector<int> edge[maxn], bag[maxn];

void getdep(int u, int f) {
  fa[0][u] = f;
  for (int i = 1; i < 20; i++) {
    fa[i][u] = fa[i - 1][fa[i - 1][u]];
  }
  dfn[u] = ++tot;
  dep[u] = dep[f] + 1;
  for (int v: edge[u]) {
    if (v == f) continue;
    getdep(v, u);
  }
}
int qlca(int x, int y) {
  if (dep[x] < dep[y]) swap(x, y);
  int tmp = dep[x] - dep[y];
  for (int i = 0; tmp; i++, tmp >>= 1)
    if (tmp & 1) x = fa[i][x];
  if (x == y) return x;
  for (int i = 19; i >= 0; i--) {
    if (fa[i][x] != fa[i][y]) {
      x = fa[i][x]; y = fa[i][y];
    }
  }
  return fa[0][x];
}

namespace VT {
  int stk[maxn], top;
  void build(vector<int>& vec) {
    sort(vec.begin(), vec.end(), [&](int a, int b) { return dfn[a] < dfn[b]; });
    stk[top = 1] = rt; edge[rt].clear();
    for (int x: vec) {
      if (x == rt) continue;
      int g = qlca(stk[top], x);
      if (g != stk[top]) {
        while (dfn[g] < dfn[stk[top - 1]]) {
          edge[stk[top - 1]].push_back(stk[top]); top--;
        }
        if (dfn[g] > dfn[stk[top - 1]]) {
          edge[g].clear();
          edge[g].push_back(stk[top]);
          stk[top] = g;
        } else {
          edge[g].push_back(stk[top]); top--;
        }
      }
      edge[x].clear(); stk[++top] = x;
    }
    for (int i = 1; i < top; i++) {
      edge[stk[i]].push_back(stk[i + 1]);
    }
  }
}

ll dfs(int u, int f) {
  ll ans = a[u];
  for (int v: edge[u]) {
    if (v == f) continue;
    ll val = dfs(v, u);
    ans += cal(val, dep[v] - dep[u]);
  }
  return ans;
}

int main() {
  scanf("%d%d", &n, &rt);
  for (int i = 1; i <= n; i++) {
    scanf("%d", a + i);
  }
  for (int i = 2, u, v; i <= n; i++) {
    scanf("%d%d", &u, &v);
    edge[u].push_back(v);
    edge[v].push_back(u);
  }
  getdep(rt, 0);
  ll ans = cal(a[rt], 1); a[rt] = 0;
  for (int i = 1; i <= n; i++) {
    bag[dep[i]].push_back(i);
    edge[i].clear();
  }
  for (int i = 2; i <= n; i++) {
    if (bag[i].empty()) continue;
    VT::build(bag[i]);
    ans += cal(dfs(rt, 0), 1);
    for (int x: bag[i]) a[x] = 0;
  }
  cout << ans << endl;
  return 0;
}
```

### 长链剖分

#### k 级祖先

```c++
int n, m;
vector<int> edge[maxn];

int dep[maxn], son[maxn], top[maxn], len[maxn], maxd[maxn], fa[maxn][20];
void dfs(int u, int f) {
    maxd[u] = dep[u] = dep[f] + 1;
    fa[u][0] = f; son[u] = 0;
    for (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        if (maxd[v] > maxd[son[u]]) son[u] = v, maxd[u] = maxd[v];
    }
}
void dfs(int u, int f, int tp, int l) {
    top[u] = tp; len[u] = l;
    if (son[u]) {
        dfs(son[u], u, tp, l + 1);
        len[u] = len[son[u]];
    }
    for (int& v: edge[u]) {
        if (v == f || v == son[u]) continue;
        dfs(v, u, v, 1);
    }
}
bool vis[maxn]; int highbit[maxn];
vector<int> up[maxn], dwn[maxn];
void init() {
    dfs(1, 0); dfs(1, 0, 1, 1);
    for (int i = 1; i <= n; i++) {
        int tp = top[i];
        if (!vis[tp]) {
            vis[tp] = 1;
            int l = 0, now = tp;
            while (l < len[tp] && now) {
                now = fa[now][0];
                l++; up[tp].push_back(now);
            }
            l = 0, now = tp;
            while (l < len[tp]) {
                now = son[now];
                l++; dwn[tp].push_back(now);
            }
        }
    }
    int mx = 1;
    for (int i = 1; i <= n; i++) {
        if (i >> mx & 1) mx++;
        highbit[i] = mx - 1;
    }
}
int qkth(int u, int k) {
    if (k > dep[u]) return 0;
    if (k == 0) return u;
    u = fa[u][highbit[k]]; k -= 1 << highbit[k];
    if (k == 0) return u;
    if (dep[u] - dep[top[u]] == k) return top[u];
    if (dep[u] - dep[top[u]] > k) return dwn[top[u]][dep[u] - dep[top[u]] - k - 1];
    return up[top[u]][k - (dep[u] - dep[top[u]]) - 1];
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v); edge[v].push_back(u);
    } init();
    scanf("%d", &m);
    int u, k, lastans = 0;
    while (m--) {
        scanf("%d%d", &u, &k);
        u ^= lastans; k ^= lastans;
        printf("%d\n", lastans = qkth(u, k));
    }
    return 0;
}
```

#### 优化深度信息合并

```c++
int n; ll ans = 0;
vector<int> edge[maxn];

int dep[maxn], son[maxn], top[maxn], len[maxn];
void dfs1(int u, int f) {
    len[u] = 0;
    for (int v: edge[u]) {
        if (v == f) continue;
        dfs1(v, u);
        if (len[v] > len[son[u]]) son[u] = v, len[u] = len[v];
    }
    len[u]++;
}
int tmp[maxn * 16], *f[maxn], *g[maxn], *tot = tmp;
void make(int u, int len) {
    f[u] = tot; tot += (len + 5) * 2;
    g[u] = tot; tot += (len + 5) * 2;
}
void dfs(int u, int ff) {
    if (son[u]) {
        f[son[u]] = f[u] + 1;
        g[son[u]] = g[u] - 1;
        dfs(son[u], u);
    }
    f[u][0] = 1;
    ans += g[u][0];
    for (int& v: edge[u]) {
        if (v == ff || v == son[u]) continue;
        make(v, len[v]);
        dfs(v, u);
        for (int j = 0; j <= len[v] + 1; j++) {
            ans += f[u][j] * g[v][j + 1];
            if (j) ans += g[u][j] * f[v][j - 1];
            g[u][j] += g[v][j + 1];
            if (j) g[u][j] += f[u][j] * f[v][j - 1];
            if (j) f[u][j] += f[v][j - 1];
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v); edge[v].push_back(u);
    }
    dfs1(1, 0);
    make(1, len[1]);
    dfs(1, 0);
    cout << ans << '\n';
    return 0;
}
```

### 树上启发式合并

```c++
int sz[maxn], son[maxn];
void getsz(int u, int f) {
    sz[u] = 1;
    for (auto& v : edge[u]) {
        if (v == f) continue;
        getsz(v, u); sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}
int sk[maxn];
void add(int u, int f, int x) {
    // update answer
    for (auto& v : edge[u]) {
        if (v == f || sk[v]) continue;
        add(v, u, x);
    }
}
void dfs(int u, int f, int kp) {
    for (auto& v : edge[u]) {
        if (v == f || v == son[u]) continue;
        dfs(v, u, 0);
    }
    if (son[u]) dfs(son[u], u, 1), sk[son[u]] = 1;
    add(u, f, 1); sk[son[u]] = 0;
    // answert query
    if (!kp) add(u, f, -1);
}
```

### 树分块

```c++
int n, b;
vector<int> edge[maxn];

int stk[maxn], tot, bel[maxn], bcnt, key[maxn];
void dfs(int u, int f) {
    int bot = tot;
    for (int& v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        if (tot - bot >= b) {
            bcnt++; key[bcnt] = u;
            while (tot != bot) {
                bel[stk[tot--]] = bcnt;
            }
        }
    }
    stk[++tot] = u;
}

int main() {
    scanf("%d%d", &n, &b);
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    dfs(1, 0);
    while (tot) bel[stk[tot--]] = bcnt;
    printf("%d\n", bcnt);
    for (int i = 1; i <= n; i++) printf("%d%c", bel[i], " \n"[i == n]);
    for (int i = 1; i <= bcnt; i++) printf("%d%c", key[i], " \n"[i == bcnt]);
    return 0;
}
```

### 树哈希

原题：[HDu6647 Bracket Sequences on Tree](http://acm.hdu.edu.cn/showproblem.php?pid=6647)。

求每个点作为根节点的树哈希值。

```c++
namespace sieve{
    const int maxp = 2000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
        ms(vis, 0);
        for (int i = 2; i < maxp; i++) {
            if (!vis[i]) prime[++tot] = i;
            for (int j = 1; j <= tot && prime[j] * i < maxp; j++) {
                vis[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
    }
}
namespace MyIO {
    struct fastIO {
        char s[100000]; int it,len;
        fastIO() { it = len = 0; }
        inline char get() {
            if (it < len) return s[it++];
            it = 0; len = fread(s, 1, 100000, stdin);
            if (len == 0) return EOF;
            else return s[it++];
        }
        bool notend() {
            char c = get();
            while(c == ' ' || c == '\n') c = get();
            if (it > 0) it--;
            return c != EOF;
        }
    } buff;
    inline int gi() {
        int r = 0; bool ng = 0;
        char c = buff.get();
        while (c != '-' && (c < '0' || c > '9')) c = buff.get();
        if (c == '-') ng = 1, c = buff.get();
        while (c >= '0' && c <= '9') r = r * 10 + c - '0', c = buff.get();
        return ng ? -r : r;
    }
}
namespace {
    inline int add(int x, int y) {
        x += y;
        return x >= mod ? x -= mod : x;
    }
    inline int sub(int x, int y) {
        x -= y;
        return x < 0 ? x += mod : x;
    }
    inline int mul(int x, int y) {
        return 1ll * x * y % mod;
    }
    inline int qpow(int x, ll n) {
        int r = 1;
        while (n > 0) {
            if (n & 1) r = 1ll * r * x % mod;
            n >>= 1; x = 1ll * x * x % mod;
        }
        return r;
    }
    inline int inv(int x) {
        return qpow(x, mod - 2);
    }
}
using sieve::prime;
using MyIO::gi;

int ping[maxn], pingv[maxn];

int n, ans, siz[maxn];
vector<int> edge[maxn];
map<ull,int> uqc[maxn];
map<ull,int>::iterator it;

ull hashval[maxn], hashrt[maxn];
ull srchashval[maxn], srchashrt[maxn];
int dp[maxn], rdp[maxn];
ull pack(ull val, int sz) {
    return 2ull + 3ull * val + 7ull * prime[sz + 1];
}
void predfs(int u, int ff) {
    siz[u] = dp[u] = 1;
    hashval[u] = 1;
    int sz = 0;
    for (int v: edge[u]) {
        if (v == ff) continue;
        predfs(v, u);
        sz++;
        siz[u] += siz[v];
        dp[u] = mul(dp[u], dp[v]);
        uqc[u][hashval[v]]++;
        hashval[u] += hashval[v] * prime[siz[v]];
    }

    srchashval[u] = hashval[u];
    hashval[u] = pack(hashval[u], siz[u]);

    dp[u] = mul(dp[u], ping[sz]);
    for (it = uqc[u].begin(); it != uqc[u].end(); it++) {
        dp[u] = mul(dp[u], pingv[it->second]);
    }
}
set<ull> qc;
void dfs(int u, int ff) {
    if (!qc.count(hashrt[u])) {
        qc.insert(hashrt[u]);
        ans = add(ans, rdp[u]);
    }
    for (int v: edge[u]) {
        if (v == ff) continue;

        ull tmp = srchashrt[u] - hashval[v] * prime[siz[v]];
        tmp = pack(tmp, n - siz[v]);

        uqc[v][tmp]++;
        srchashrt[v] = srchashval[v] + tmp * prime[n - siz[v]];
        hashrt[v] = pack(srchashrt[v], n);

        int tdp = mul(rdp[u], inv(dp[v]));
        tdp = mul(tdp, inv((int)edge[u].size()));
        tdp = mul(tdp, uqc[u][hashval[v]]);
        rdp[v] = mul(dp[v], tdp);
        rdp[v] = mul(rdp[v], (int)edge[v].size());
        rdp[v] = mul(rdp[v], inv(uqc[v][tmp]));

        dfs(v, u);
    }
}

int main() {
    sieve::init(); ping[0] = pingv[0] = 1;
    for (int i = 1; i < maxn; i++) {
        ping[i] = mul(ping[i - 1], i);
        pingv[i] = mul(pingv[i - 1], inv(i));
    }
    int T = gi();
    while (T--) {
        n = gi();
        for (int i = 2, u, v; i <= n; i++) {
            u = gi(); v = gi();
            edge[u].push_back(v);
            edge[v].push_back(u);
        }

        predfs(1, 0);
        ans = 0; qc.clear();
        rdp[1] = dp[1];
        hashrt[1] = hashval[1];
        srchashrt[1] = srchashval[1];
        dfs(1, 0);

        printf("%d\n", ans);

        for (int i = 1; i <= n; i++) {
            edge[i].clear();
            uqc[i].clear();
        }
    }
    return 0;
}
```

最小表示?

```c++
int tot;
map<vector<int>,int> mp;
int siz[maxn];
int hsh[maxn];
void predfs(int u, int ff) {
  siz[u] = 1;
  vector<int> vec;
  for (int v: edge[u]) {
    if (v == ff) continue;
    predfs(v, u, edge, hsh);
    siz[u] += siz[v];
    vec.push_back(hsh[v]);
  }
  sort(begin(vec), end(vec));
  if (!mp.count(vec)) {
    mp[vec] = ++tot;
  }
  hsh[u] = mp[vec];
}
```

### 树分治

```c++
const int mod = 998244353;
const int inf = 2147483647;
const int maxn = 200000 + 50;

int tr[maxn];
inline int lowbit(int x) { return x & -x; }
inline void update(int i, int x) {
    while (i < maxn) tr[i] = max(tr[i], x), i += lowbit(i);
}
inline void del(int i) {
    while (i < maxn) tr[i] = 0, i += lowbit(i);
}
inline int query(int i) {
    int r = 0; while (i > 0) r = max(tr[i], r), i -= lowbit(i);
    return r;
}

struct edge {
    int to, nxt, d;
} g[maxn << 1];
int head[maxn], tot;
void add(int u, int v, int w) {
    g[++tot] = (edge){v, head[u], w}; head[u] = tot;
}

int n, k, m, key[maxn], ans;

int vis[maxn], siz[maxn], sum, mn, rt;
void getrt(int u, int f) {
    siz[u] = 1; int t = 0;
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (v == f || vis[v]) continue;
        getrt(v, u); siz[u] += siz[v];
        t = max(t, siz[v]);
    }
    t = max(t, sum - siz[u]);
    if (t < mn) mn = t, rt = u;
}
int getrt(int u) {
    sum = siz[u]; mn = 1e9; rt = 0;
    getrt(u, 0); return rt;
}

vector<PII> vec;
void dfs(int u, int f, int c, int d) {
    c += key[u];
    if (c > k) return ;
    vec.push_back({c, d});
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (v == f || vis[v]) continue;
        dfs(v, u, c, d + g[i].d);
    }
}
void solve(int u) {
    vis[u] = 1; vector<int> al;
    update(key[u] + 1, 0); al.push_back(key[u]);
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (vis[v]) continue;
        vec.clear();
        dfs(v, u, key[u], g[i].d);
        for (int i = 0; i < vec.size(); i++) {
            ans = max(ans, vec[i].second + query(k - vec[i].first + key[u] + 1));
        }
        for (int i = 0; i < vec.size(); i++) {
            al.push_back(vec[i].first), update(vec[i].first + 1, vec[i].second);
        }
    }
    for (int i = 0; i < al.size(); i++) del(al[i] + 1);
    for (int i = head[u]; i; i = g[i].nxt) {
        int v = g[i].to;
        if (vis[v]) continue;
        solve(getrt(v));
    }
}

int main() {
    scanf("%d%d%d", &n, &k, &m);
    for (int i = 1, x; i <= m; i++) scanf("%d", &x), key[x] = 1;
    for (int i = 2, u, v, w; i <= n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    siz[1] = n; solve(getrt(1));
    cout << ans << endl;
    return 0;
}
```

### 树形依赖背包

```c++
const int mod = 998244353;
const int maxn = 5000 + 5;

vector<int> edge[maxn];
int n, b, d[maxn], c[maxn];

// min cost of subtree-i buy j things, with discount or not
ll dp[maxn][maxn][2];
int siz[maxn];
void dfs(int u, int f) {
    siz[u] = 1;
    dp[u][0][0] = 0;
    dp[u][1][0] = c[u];
    dp[u][1][1] = c[u] - d[u];
    for (int& v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        for (int i = siz[u]; i >= 0; i--) {
            for (int j = 1; j <= siz[v]; j++) {
                dp[u][i + j][0] = min(dp[u][i + j][0], dp[u][i][0] + dp[v][j][0]);
                dp[u][i + j][1] = min(dp[u][i + j][1], dp[u][i][1] + dp[v][j][0]);
                dp[u][i + j][1] = min(dp[u][i + j][1], dp[u][i][1] + dp[v][j][1]);
            }
        }
        siz[u] += siz[v];
    }
}

int main(){
    scanf("%d%d", &n, &b);
    for (int i = 1, x; i <= n; i++) {
        for (int j = 0; j <= n; j++) dp[i][j][0] = dp[i][j][1] = 1ll << 60;
        scanf("%d%d", c + i, d + i);
        if (i == 1) continue;
        scanf("%d", &x);
        edge[x].push_back(i);
    }
    dfs(1, 0);
    int ans = 0;
    for (int i = 1; i <= n; i++) if (min(dp[1][i][0], dp[1][i][1]) <= b) ans = i;
    cout << ans << endl;
    return 0;
}
```

### 支配树

- `semi[x]` 半必经点： $x$ 的祖先 $z$ 中，能不经过 $z$ 和 $x$ 之间的树上的点而到达 $x$ 的点中深度最小的
- `idom[x]` 最近必经点：就是深度最大的根到 $x$ 的必经点

```c++
vector<int> G[maxn], rG[maxn];
vector<int> dt[maxn];
// 原图，反图，支配树

namespace DomTree {
    int fa[maxn], idx[maxn], tot, ridx[maxn];
    int c[maxn], best[maxn], semi[maxn], idom[maxn];
    void clear(int n) {
        tot = 0;
        fill(c, c + n + 1, -1);
        fill(idx, idx + n + 1, 0);
        for (int i = 0; i <= n; i++) {
            dt[i].clear();
            semi[i] = best[i] = i;
        }
    }
    void dfs(int u) {
        idx[u] = ++tot; ridx[tot] = u;
        for (int& v: G[u]) {
            if (idx[v]) continue;
            fa[v] = u; dfs(v);
        }
    }
    int fix(int x) {
        if (c[x] == -1) return x;
        int &f = c[x], rt = fix(f);
        if (idx[semi[best[x]]] > idx[semi[best[f]]]) best[x] = best[f];
        return f = rt;
    }
    void build(int rt) {
        dfs(rt);
        for (int i = tot; i >= 1; i--) {
            int x = ridx[i], mn = tot + 1;
            for (int& u: rG[x]) {
                if (!idx[u]) continue;
                fix(u); mn = min(mn, idx[semi[best[u]]]);
            }
            c[x] = fa[x];
            dt[semi[x] = ridx[mn]].push_back(x);
            x = ridx[i - 1];
            for (int& u: dt[x]) {
                fix(u);
                if (semi[best[u]] != x) idom[u] = best[u];
                else idom[u] = x;
            }
            dt[x].clear();
        }
        for (int i = 2; i <= tot; i++) {
            int u = ridx[i];
            if (idom[u] != semi[u]) idom[u] = idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}
```

## 仙人掌

```c++
int cnt;
namespace cactus {
    struct E {
        int to, nxt;
    } e[maxn * 2];
    int head[maxn], ecnt;
    void adde(int u, int v) {
        e[++ecnt] = {v, head[u]};
        head[u] = ecnt;
    }
    int tot, dfn[maxn], fa[maxn];
    bool ring[maxn];
    void clear(int n) {
        cnt = ecnt = tot = 0;
        for (int i = 1; i <= n; i++) {
            head[i] = dfn[i] = ans[i] = 0;
        }
    }
    void dfs(int u, int f) {
        dfn[u] = ++tot;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (v == f) continue;
            if (!dfn[v]) {
                fa[v] = u; ring[u] = false;
                dfs(v, u);
                if (!ring[u]) {
                    edge[u].push_back(v); edge[v].push_back(u);
                }
            } else if (dfn[v] < dfn[u]) {
                cnt++; int rt = cnt + n;
                bcc[cnt].clear();
                edge[rt].push_back(v);
                edge[v].push_back(rt);
                bcc[cnt].push_back(v);
                for (int x = u; x != v; x = fa[x]) {
                    ring[x] = true;
                    bcc[cnt].push_back(x);
                    edge[rt].push_back(x);
                    edge[x].push_back(rt);
                }
                ring[v] = true;
            }
        }
    }
    void build() {
        dfs(1, 0);
    }
}
```