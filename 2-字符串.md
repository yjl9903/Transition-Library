# 字符串

[TOC]

## 哈希

初始化：`Hash::init()`。

1. 获取子串 $[l,r]$ 的哈希值，注意预处理和取模细节。
2. 注意不要将字符映射到 $0$ 上。

```c++
typedef unsigned long long ull;
const int seed = 135;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;
ull xp1[maxn], xp2[maxn], xp[maxn];
struct Hash {
    static void init() {
        xp1[0] = xp2[0] = xp[0] = 1;
        for (int i = 1; i < maxn; ++i) {
            xp1[i] = xp1[i - 1] * seed % p1;
            xp2[i] = xp2[i - 1] * seed % p2;
            xp[i] = xp[i - 1] * seed;
        }
    }

    ull h[maxn];
    ull build(int n, const char* s) {
        ull r1 = 0, r2 = 0;
        for (int i = 1; i <= n; i++) {
            r1 = (r1 * seed + s[i]) % p1;
            r2 = (r2 * seed + s[i]) % p2;
            h[i] = (r1 << 32) | r2;
        }
        return h[n];
    }

    ull query(int l, int r) {
        int len = r - l + 1;
        unsigned int mask32 = ~(0u);
        ull left1 = h[l - 1] >> 32, right1 = h[r] >> 32;
        ull left2 = h[l - 1] & mask32, right2 = h[r] & mask32;
        return (((right1 - left1 * xp1[len] % p1 + p1) % p1) << 32) |
                (((right2 - left2 * xp2[len] % p2 + p2) % p2));
    }
} h;
```

模数：

```c++
1000000007, 1000000009,
998244353, 91815541,
122420729, 917120411,
687840301, 515880193,
1222827239, 1610612741
```

### 哈希表

```c++
template<typename keyT, typename valT>
struct HashTable {
    static const int htMod = (1 << 25) - 1;
    static const int mxSize = maxn << 4;
    keyT key[mxSize]; valT val[mxSize];
    int sz, head[htMod + 10], nxt[mxSize];
    inline void add(int hsh, keyT V) {
        key[++sz] = V;
        nxt[sz] = head[hsh];
        head[hsh] = sz;
    }
    inline valT& operator [](keyT xe) {
        int key = xe & htMod;
        for (int i = head[key]; i; i = nxt[i])
            if (this->key[i] == xe) return val[i];
        add(key, xe); return val[sz];
    }
    inline bool count(keyT xe) {
        int key = xe & htMod;
        for (int i = head[key]; i; i = nxt[i])
            if (this->key[i] == xe) return true;
        return false;
    }
    inline void clear() {
        for (int i = 1; i <= sz; i++) head[this->key[i] & htMod] = 0;
        for (int i = 1; i <= sz; i++) val[i] = 0;
        sz = 0;
    }
    inline int size() { return sz; }
};
```

## KMP

下标从 $1$ 开始。

参数：前一个为文本串，后一个为模式串。

```c++
char s[maxn], p[maxn];
int nxt[maxn];

void getfail(int len, char* s, int fail[]) {
    fail[1] = 0;
    for (int i = 2; i <= len; i++) {
        int cur = fail[i - 1];
        while (cur > 0 && s[cur + 1] != s[i])
            cur = fail[cur];
        if (s[cur + 1] == s[i])
            ++cur;
        fail[i] = cur;
    }
}
void kmp(char *s, char *p) {
    int slen = strlen(s + 1), plen = strlen(p + 1), cur = 0;
    getfail(plen, p, nxt);
    for (int i = 1; i <= slen; i++) {
        while (cur > 0 && s[i] != p[cur + 1]) cur = nxt[cur];
        if (p[cur + 1] == s[i]) cur++;
        if (cur == plen) {
            printf("%d\n", i - cur + 1);
            cur = nxt[cur];
        }
    }
}
```

### 扩展KMP

下标从 $1$ 开始。

$extend[i]$ 表示 $T[i\dots n-1]$ 和 $S$ 的最长公共前缀。

```c++
namespace exkmp {
    int nxt[maxn], extend[maxn];
    void getnxt(int n, char *s) {
        int p = 1, k = 2; nxt[1] = n;
        while (p + 1 <= n && s[p] == s[p + 1]) p++;
        nxt[2] = p - 1;
        for (int i = 3; i <= n; i++) {
            int len = nxt[i - k + 1];
            if (len + i <= p) nxt[i] = len;
            else {
                int j = max(p - i + 1, 0);
                while (i + j <= n && s[j + 1] == s[i + j]) j++;
                nxt[i] = j; k = i;
                p = i + j - 1;
            }
        }
    }
    void build(int tlen, char *t, int slen, char *s) {
        getnxt(slen, s);
        int p = 1, k = 1;
        while (p <= tlen && p <= slen && t[p] == s[p]) p++;
        p--; extend[1] = p;
        for (int i = 2; i <= tlen; i++) {
            int len = nxt[i - k + 1];
            if (len + i <= p) extend[i] = len;
            else {
                int j = max(p - i + 1, 0);
                while (i + j <= tlen && j <= slen && s[j + 1] == t[i + j]) j++;
                extend[i] = j; k = i;
                p = i + j - 1;
            }
        }
    }
}
```

## 后缀数组

注意：

1. 下标从 $1$ 开始
2. 每个字符的值域范围

定义：

1. $sa[n]$ : 后缀排序后，排名第 $i$ 个串的开始下标。
2. $rk[n]$ : 原串第 $i$ 个后缀排过序后的名次。
3. $sa[n]$ 和 $rk[n]$ 互为逆运算，$rk[sa[i]]=sa[rk[i]]=i$。
4. $LCP$ : 最长公共前缀。
5. $height[rk[i]] \ge height[rk[i-1]] - 1$。
6. $height[i]$ = $LCP(sa[i - 1],sa[i])$ ($2 \le i \le n$)。

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    void build(int nn, char* s) {
        n = nn; m = 255; // important
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort();
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
    }
}
```

### LCP

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    int dp[21][maxn];
    void build(int nn, char* s) {
        n = nn; m = 255;
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort();
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
        for (int i = 1; i <= n; i++) dp[0][i] = h[i];
        for (int j = 1; j < 21; j++) {
            for (int i = 1; i + (1 << j) <= n + 1; i++) {
                dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);
            }
        }
    }
    int qlcp(int l, int r) {
        if (l <= 0) return 0;
        if (r <= 0) return 0;
        if (l == r) return n - l + 1;
        l = x[l]; r = x[r];
        if (l > r) swap(l, r);
        l++; int k = __lg(r - l + 1);
        return min(dp[k][l], dp[k][r - (1 << k) + 1]);
    }
}
```

### SAIS

下标从 $1$ 开始。

```c++
namespace SA {
    int n, sa[maxn], rk[maxn], h[maxn];
    int s[maxn << 1], t[maxn << 1], p[maxn], cnt[maxn], cur[maxn];
    void sais(int n, int m, int* s, int* t, int* p) {
        int n1 = t[n - 1] = 0, ch = rk[0] = -1, *s1 = s + n;
        auto pushS = [&](int x) {
            sa[cur[s[x]]--] = x;
        };
        auto pushL = [&](int x) {
            sa[cur[s[x]]++] = x;
        };
        auto isort = [&](const int* v) {
            fill_n(sa, n, -1); fill_n(cnt, m, 0);
            for (int i = 0; i < n; i++) cnt[s[i]]++;
            for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];
            for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;
            for (int i = n1 - 1; ~i; i--) pushS(v[i]);
            for (int i = 1; i < m; i++) cur[i] = cnt[i - 1];
            for (int i = 0; i < n; i++) if (sa[i] > 0 && t[sa[i] - 1]) pushL(sa[i] - 1);
            for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;
            for (int i = n - 1; ~i; i--) if (sa[i] > 0 && !t[sa[i] - 1]) pushS(sa[i] - 1);
        };
        for (int i = n - 2; ~i; i--) t[i] = s[i] == s[i + 1] ? t[i + 1] : s[i] > s[i + 1];
        for (int i = 1; i < n; i++) rk[i] = t[i - 1] && !t[i] ? (p[n1] = i, n1++) : -1;
        isort(p);
        for (int i = 0, x, y; i < n; i++) if (~(x = rk[sa[i]])) {
            if (ch < 1 || p[x + 1] - p[x] != p[y + 1] - p[y]) ch++;
            else for (int j = p[x], k = p[y]; j <= p[x + 1]; j++, k++)
                    if ((s[j] << 1 | t[j]) != (s[k] << 1 | t[k])) { ch++; break;}
            s1[y = x] = ch;
        }
        if (ch + 1 < n1) sais(n1, ch + 1, s1, t + n, p + n1);
        else for (int i = 0; i < n1; i++) sa[s1[i]] = i;
        for (int i = 0; i < n1; i++) s1[i] = p[sa[i]];
        isort(s1);
    }
    template<typename T>
    int mapCharToInt(int n, const T* str) {
        int m = *max_element(str, str + n);
        fill_n(rk, m + 1, 0);
        for (int i = 0; i < n; i++) rk[str[i]] = 1;
        for (int i = 0; i < m; i++) rk[i + 1] += rk[i];
        for (int i = 0; i < n; i++) s[i] = rk[str[i]] - 1;
        return rk[m];
    }
    int dp[21][maxn];
    template<typename T>
    void build(int nn, const T* str) {
        n = nn;
        int m = mapCharToInt(++n, str);
        sais(n, m, s, t, p);
        for (int i = 0; i < n; i++) rk[sa[i]] = i;
        for (int i = 0, k = 0; i < n; i++) {
            if (k) k--;
            int j = sa[rk[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[rk[i]] = k;
        }
        for (int i = 1; i <= n; i++) dp[0][i] = h[i];
        for (int j = 1; j < 21; j++) {
            for (int i = 1; i + (1 << j) <= n + 1; i++) {
                dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);
            }
        }
    }
    int qlcp(int l, int r) {
        l--; r--;
        if (l < 0) return 0;
        if (r < 0) return 0;
        if (l == r) return n - 1 - l;
        l = rk[l]; r = rk[r];
        if (l > r) swap(l, r);
        l++; int k = __lg(r - l + 1);
        return min(dp[k][l], dp[k][r - (1 << k) + 1]);
    }
};

int main() {
    scanf("%s", s + 1);
    int n = strlen(s + 1);
    sa::build(n, s + 1); // important
    for (int i = 1; i <= n; i++) {
        if (i > 1) putchar(' ');
        printf("%d", sa::sa[i] + 1);
    }
    puts("");
    for (int i = 2; i <= n; i++) {
        if (i > 2) putchar(' ');
        printf("%d", sa::h[i]);
    }
    return 0;
}
```

### 一个串的经典问题

#### 本质不同子串个数

${n(n+1) \over 2}-\sum_{i=2}^n height[i]$。

#### 可重叠的最长重复子串

$height$ 数组最大值。

#### 不可重叠的最长重复子串

二分答案。

当前二分到 $mid$, 将 $height$ 数组中连续大于等于 $mid$ 的位置划分进一块，一个块内求出现位置的最大值和最小值，如果相差大于等于 $mid$，即代表出现了一段不重叠的重复子串。

```c++
int check(int len) {
    int mx = sa[1], mn = sa[1];
    for (int i = 2; i <= n; i++) {
        if (h[i] >= len) {
            mn = min(mn, sa[i]);
            mx = max(mx, sa[i]);
            if (mx - mn >= len) return 1;
        } else mx = sa[i], mn = sa[i];
    }
    return 0;
}
```

#### 循环节最多的子串

枚举循环节大小 $len$，求 $s[1],s[1+len], s[1+2\cdot len], \dots$，相邻两个的 $LCP$，设 $LCP$ 为 $x$，则循环节个数至少为 ${x \over len} + 1$，再特判一下剩余的 $len - x \bmod len$ 个字符，将 $s[1+k\cdot len]$ 向前推这么多能否构成一个更多的循环节。

### 两个串的经典问题

#### 最长公共子串

将两个串用一个小字符连起来，建一个后缀数组。

$ans=max(height[i])$，满足 $sa[i]$ 和 $sa[i-1]$ 不在同一个串内。

### 多个串的经典问题

将多个串用不同的未出现字符连成一个（注意值域大小）。

#### 出现在至少 $k$ 个串中的最长子串

二分答案，对 $height$ 分块，判断一个块内是否出现 $k$ 次。

## AC 自动机

注意：$1$ 号结点为空的根结点，字母大小写和字母值域。

```c++
namespace acam {
  static const int maxp = 100000 + 5;
  static const int S = 26;
  static const int Base = 'a';
  int sz, ch[maxp][S], fail[maxp], val[maxp];
  int node() {
    ms(ch[++sz], 0);
    fail[sz] = val[sz] = 0;
    return sz;
  }
  void clear() {
    sz = 0; node();
    for (int i = 0; i < S; i++) ch[0][i] = 1;
  }
  int insert(char* s, int i) {
    int u = 1;
    for (int i = 0; s[i]; i++) {
      int v = s[i] - Base; // !
      if (!ch[u][v]) ch[u][v] = node();
      u = ch[u][v];
    }
    val[u]++;
    return u;
  }
  void build() {
    queue<int> q; q.push(1);
    while (!q.empty()) {
      int t = q.front(); q.pop();
      for (int i = 0; i < S; i++) {
        if (ch[t][i]) {
          fail[ch[t][i]] = ch[fail[t]][i];
          q.push(ch[t][i]);
        } else {
          ch[t][i] = ch[fail[t]][i];
        }
      }
    }
  }
}
```

### 定义

+ fail 指针: 当前结点对应串的最长后缀，使得他也是 Trie 树上的结点，类似于 KMP。

+ Trie 图: 建完 AC 自动机后，Trie 树变成了 Trie 图，Trie 树上不存在的出边补成 fail 指针指向结点的对应出边。

### 危险结点

串的终止结点是危险结点，fail 指向危险结点的是危险结点。

```c++
int node() {
    ms(ch[++sz], 0);
    fail[sz] = 0; danger[sz] = 0;
    return sz;
}
void build() {
    queue<int> q; q.push(1);
    while (!q.empty()) {
        int t = q.front(); q.pop();
        for (int i = 0; i < 2; i++) {
            if (ch[t][i]) {
                fail[ch[t][i]] = ch[fail[t]][i];
                danger[ch[t][i]] |= danger[fail[ch[t][i]]];
                // pushdown danger
                q.push(ch[t][i]);
            } else {
                ch[t][i] = ch[fail[t]][i];
            }
        }
    }
}
```

### 求所有模式串出现次数

类似于 KMP，在 Trie 上的每个点打标记，然后将标记从底往上传递，其实就是将 fail 树建初来，求子树大小。

也可以对 fail 树跑拓扑排序。

```c++
vector<int> edge[maxp];
int siz[maxp];
void dfs(int u) {
    for (int& v: edge[u]) {
        dfs(v); siz[u] += siz[v];
    }
}
vector<int> query(int n, char* s) {
    // n: 文本串个数, s: 询问串
    for (int i = 0; i <= sz; i++) edge[i].clear(), siz[i] = 0;
    int now = 1;
    for (int i = 0; s[i]; i++) {
        now = ch[now][s[i] - 'a'];
        siz[now]++;
    }
    for (int i = 2; i <= sz; i++) edge[fail[i]].push_back(i);
    dfs(1);
    vector<int> ans(1, 0);
    for (int i = 1; i <= n; i++) ans.push_back(siz[match[i]]);
    return ans;
}
```

### 询问串包含另一个串的个数

枚举第一个串的每个前缀，即跳 Trie 上的父亲，再每次跳 fail 指针，看能否跳到另外一个结点上。

### AC 自动机上 DP

令 $dp[i][j]$ 表示询问串长度为 $i$，处于结点 $j$ 的不包含任何一个 Trie 树结点的情况数。

枚举长度，再枚举每个状态 $j$ 的儿子 $v$，且 $ch[j][v]$ 不是危险结点，因为到该状态不包含任何一个模板串，加入一个新的字母后，只存在当前某个后缀可能会变成模板串，如果该节点是危险结点，意味着他含有一个后缀是模板串，否则不就一定存在模板串，此时有转移方程 $dp[i][ch[j][v]]+=dp[i-1][j]$。

优化：显然每次转移的转移矩阵相同，矩阵快速幂加速。

### Trie 图上随机游走

定义走到结点 $i$ 的概率为 $x_i$，根据 Trie 构造转移矩阵，并用 $\sum_{i \in \text{终止节点}} x_i = 1$ 替换根节点的转移方程，高斯消元，时间复杂度 $O(n^3)$。

## 后缀自动机

注意：使用前必须 `clear()`；数组开到串长的两倍；插入字母时，注意减去 `a`。

```c++
namespace sam {
  int sz, last, cnt[maxn << 1];
  int len[maxn << 1], link[maxn << 1], ch[maxn << 1][26];
  void clear() {
    for (int i = 1; i <= sz; i++) {
      len[i] = link[i] = cnt[i] = 0;
      ms(ch[i], 0);
    }
    sz = last = 1;
  }
  int insert(int c) {
    int cur = ++sz, p = last;
    len[cur] = len[last] + 1;
    cnt[cur] = 1;
    for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
    if (!p) link[cur] = 1;
    else {
      int q = ch[p][c];
      if (len[p] + 1 == len[q]) link[cur] = q;
      else {
        int nq = ++sz;
        len[nq] = len[p] + 1;
        link[nq] = link[q];
        link[q] = link[cur] = nq;
        memcpy(ch[nq], ch[q], sizeof ch[q]);
        for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
      }
    }
    return last = cur;
  }
  int c[maxn << 1], a[maxn << 1];
  void rsort() {
    for (int i = 1; i <= sz; i++) c[i] = 0;
    for (int i = 1; i <= sz; i++) c[len[i]]++;
    for (int i = 1; i <= sz; i++) c[i] += c[i - 1];
    for (int i = 1; i <= sz; i++) a[c[len[i]]--] = i;
    for (int i = sz; i; i--) {
      int p = a[i];
      cnt[link[p]] += cnt[p];
    }
  }
}
```

### 广义后缀自动机

```c++
namespace gsam {
    int tot, last, cnt[maxn << 1];
    int len[maxn << 1], link[maxn << 1], ch[maxn << 1][26];
    int insert(int last, int c) {
        int cur = ++tot, p = last;
        ms(ch[cur], 0);
        len[cur] = len[last] + 1;
        cnt[cur] = 1;
        for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
        if (!p) link[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) link[cur] = q;
            else {
                int nq = ++tot;
                len[nq] = len[p] + 1;
                cnt[nq] = 0;
                link[nq] = link[q];
                link[q] = link[cur] = nq;
                memcpy(ch[nq], ch[q], sizeof ch[q]);
                for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
            }
        }
        return cur;
    }
    namespace Trie {
        int tot, ch[maxn][26], pos[maxn];
        void clear() {
            tot = 1;
        }
        void insert(char* s) {
            int u = 1;
            for (int i = 0; s[i]; i++) {
                int c = s[i] - '0';
                if (!ch[u][c]) {
                    ch[u][c] = ++tot;
                    ms(ch[tot], 0);
                }
                u = ch[u][c];
            }
        }
        void build() {
            queue<int> q; q.push(1);
            pos[1] = 1;
            while (!q.empty()) {
                int u = q.front(); q.pop();
                for (int i = 0; i < 2; i++) {
                    if (!ch[u][i]) continue;
                    int v = ch[u][i];
                    pos[v] = gsam::insert(pos[u], i);
                    q.push(v);
                }
            }
        }
    }
    using Trie::insert;
    using Trie::build;
    void clear() {
        Trie::clear();
        tot = last = 1; ms(ch[1], 0);
    }
}
```

### 不同子串个数

#### 方法一

不同子串数目即 $sam$ 上的不同路径的数目，记忆化搜索。

```c++
ll dfs(int u) {
    if (ans[u] != -1) return ans[u];
    ll x = 1;
    for (int i = 0; i < 26; i++) {
        if (!ch[u][i]) continue;
        x += dfs(ch[u][i]);
    }
    return ans[u] = x;
}

dfs(1);
printf("%lld", ans[1] - 1);
```

#### 方法二

不同子串数目为 $sam$ 上每个 $endpos$ 状态上的子串数目,  即 $\sum_{i = 1}^{tot} len(i)-len(link(i))$。

```c++
ll cal(){  
  ll ans = 0;
  for (int i = 1; i <= tot; i++) ans += len[i] - len[link[i]];
  return ans;
}
```

##### 增量维护前缀不同子串数

参考 [HDu4622](http://acm.hdu.edu.cn/viewcode.php?rid=26316331) 和 [SDOI2016 生成魔咒](https://www.luogu.org/problemnew/show/P4070)。

```c++
ll insert(int c) {
    // ...
    return cnt = cnt + len[cur] - len[link[cur]];
}
```

### 子串出现次数

按长度对状态基数排序可以得到 $sam$ 的拓扑排序序列。

```c++
int c[maxn], a[maxn];
void rsort() {
    for (int i = 1; i <= tot; i++) c[i] = 0;
    for (int i = 1; i <= tot; i++) c[len[i]]++;
    for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
    for (int i = 1; i <= tot; i++) a[c[len[i]]--] = i;
    for (int i = tot; i; i--) {
        int p = a[i];
        cnt[link[p]] += cnt[p];
    }
}
```

### 最长公共子串

对第一个串建立一个 $sam$ ，维护第二个串的每一个前缀的最长公共子串，即每一个前缀在前一个串中出现过的最长后缀。

```c++
int ans = 0, now = 1, l = 0;
for (int i = 0; s[i]; i++) {
    if (ch[now][s[i] - 'a']) l++, now = ch[now][s[i] - 'a'];
    else {
        while (now && !ch[now][s[i] - 'a']) now = link[now];
        if (!now) now = 1, l = 0;
        else l = len[now] + 1, now = ch[now][s[i] - 'a'];
    }
}
printf("%d", ans);
```

### 多个串的最长公共子串

```c++
for (int i = 1; i <= tot; i++) ans[i] = len[i];
while (scanf("%s", s + 1) == 1) {
    ms(dep, 0);
    int u = 1, l = 0;
    for (int i = 1; s[i]; i++) {
        int c = s[i] - 'a';
        if (ch[u][c]) u = ch[u][c], l++;
        else {
            while (u && !ch[u][c]) u = link[u];
            if (!u) u = 1, l = 0;
            else l = len[u] + 1, u = ch[u][c];
        }
        dep[u] = max(dep[u], l);
    }
    for (int i = tot; i >= 1; i--) {
        int u = sam::a[i];
        dep[link[u]] = max(dep[u], dep[link[u]]);
    }
    for (int i = tot; i >= 1; i--) ans[i] = min(ans[i], dep[i]);
}
int res = 0;
for (int i = 1; i <= tot; i++) res = max(res, ans[i]);
printf("%d", res);
```

### 字典序第 $k$ 大子串

$t=0$，重复子串只算一个；$t=1$，重复子串算多个。

```c++
void rsort(int t) {
    for (int i = 1; i <= sz; i++) c[len[i]]++;
    for (int i = 1; i <= sz; i++) c[i] += c[i - 1];
    for (int i = 1; i <= sz; i++) a[c[len[i]]--] = i;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        if (t) cnt[link[p]] += cnt[p];
        else cnt[p] = 1;
    }
    cnt[1] = 0;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        sum[p] = cnt[p];
        for (int j = 0; j < 26; j++) {
            if (ch[p][j])
                sum[p] += sum[ch[p][j]];
        }
    }
}
string query(int k) {
    if (k > sum[1]) return string("-1");
    int u = 1; string ans; k -= cnt[1];
    while (k > 0) {
        int c = 0;
        while (k > sum[ch[u][c]]) {
            k -= sum[ch[u][c]]; c++;
        }
        u = ch[u][c]; ans += ('a' + c); k -= cnt[u];
    }
    return ans;
}
```

### 线段树合并

```c++
namespace SegTrees {
    const int maxm = maxn * 60;
    int tot, root[maxn << 1], ls[maxm], rs[maxm], val[maxm];
    void clear(int n) {
        tot = 0;
        for (int i = 0; i <= 2 * n; i++) root[i] = 0;
    }
    void update(int i, int l, int r, int& rt) {
        if (!rt) rt = ++tot, ls[rt] = rs[rt] = val[rt] = 0;
        if (l == r) {
            val[rt]++; return ;
        }
        int m = (l + r) / 2;
        if (i <= m) update(i, l, m, ls[rt]);
        else update(i, m + 1, r, rs[rt]);
        val[rt] = val[ls[rt]] + val[rs[rt]];
    }
    int join(int x, int y, int l = 1, int r = n) {
        if (!x || !y) return x + y;
        int u = ++tot; ls[u] = rs[u] = val[u] = 0;
        if (l == r) {
            val[u] = val[x] + val[y];
        } else {
            int m = (l + r) / 2;
            ls[u] = join(ls[x], ls[y], l, m);
            rs[u] = join(rs[x], rs[y], m + 1, r);
            val[u] = val[ls[u]] + val[rs[u]];
        }
        return u;
    }
    int query(int L, int R, int l, int r, int rt) {
        if (!rt) return 0;
        if (L <= l && r <= R) return val[rt];
        int m = (l + r) / 2, ans = 0;
        if (L <= m) ans = query(L, R, l, m, ls[rt]);
        if (R > m) ans += query(L, R, m + 1, r, rs[rt]);
        return ans;
    }
}
using SegTrees::root;
```

### 获取子串结点

```c++
int fa[maxn << 1][21];
struct Edge {
    int to, nxt;
} e[maxn << 1];
int ecnt, head[maxn << 1];
void adde(int u, int v) {
    e[++ecnt] = { v, head[u] };
    head[u] = ecnt;
}
void dfs(int u, int f) {
    fa[u][0] = f;
    for (int i = 1; i < 21; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        dfs(v, u);
    }
}
void build() {
    ecnt = 0;
    for (int i = 0; i <= tot; i++) head[i] = 0;
    for (int i = 2; i <= tot; i++) adde(link[i], i);
    dfs(1, 0);
}

int get(int u, int l) { // u: s[1...r], l: r - l + 1
    for (int i = 20; i >= 0; i--) {
        if (!fa[u][i]) continue;
        int v = fa[u][i];
        if (sam::len[v] >= l) u = v;
    }
    return u;
}
```

## Manacher

下标从 $1$ 开始。

```c++
namespace manacher {
    char s[maxn << 1] = "##";
    int n, hw[maxn << 1];
    void manacher() {
        int maxr = 0, m = 0;
        for (int i = 1; i < n; i++) {
            if (i < maxr) hw[i] = min(hw[m * 2 - i], hw[m] + m - i);
            else hw[i] = 1;
            while (s[i + hw[i]] == s[i - hw[i]]) hw[i]++;
            if (hw[i] + i > maxr) {
                m = i; maxr = hw[i] + i;
            }
        }
    }
    void build(char a[]) {
        int i;
        for (i = 1; a[i]; i++) {
            s[i * 2] = a[i];
            s[i * 2 + 1] = '#';
        }
        n = i * 2; s[n] = 0;
        manacher();
    }
    int check(int l, int r) {
        // s[l...r] 是否为回文串
        int mid = (l + r);
        if (hw[mid] >= mid - 2 * l + 1) return 1;
        else return 0;
    }
}
```

## 回文树

```c++
namespace pam {
    int sz, tot, last;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l; fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last = 0;
        s[tot = 0] = '$';
        node(0); node(-1);
        fail[0] = 1;
    }
    int getfail(int x) {
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void insert(char c) {
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }
    void count() {
        for (int i = sz; i >= 0; i--) {
            cnt[fail[i]] += cnt[i];
        }
    }
}
```

### half 指针

```c++
void insert(char c) {
    s[++tot] = c;
    int now = getfail(last);
    if (!ch[now][c - 'a']) {
        int x = node(len[now] + 2);
        fail[x] = ch[getfail(fail[now])][c - 'a'];
        dep[x] = dep[fail[x]] + 1;
        ch[now][c - 'a'] = x;

        if (len[x] == 1) half[x] = 1;
        else {
            int pos = half[now];
            while (s[tot - len[pos] - 1] != s[tot] || (2 + len[pos]) * 2 > len[x]) pos = fail[pos];
            half[x] = ch[pos][c - 'a'];
        }
        val[x] = 1;
        if (len[x] / 2 == len[half[x]]) val[x] += val[half[x]];
    }
    last = ch[now][c - 'a'];
    cnt[last]++;
}
```

### 双向加字符

```c++
namespace pam {
    // last1: right, last2: left
    int sz, last1, last2, l, r;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l;
        fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last1 = last2 = 0;
        l = 100002; r = l - 1;
        node(0); node(-1);
        fail[0] = 1;
        ms(s, -1);
    }
    int getfail1(int x) {
        while (s[r - len[x] - 1] != s[r]) x = fail[x];
        return x;
    }
    int getfail2(int x) {
        while (s[l + len[x] + 1] != s[l]) x = fail[x];
        return x;
    }
    int insertR(char c) {
        s[++r] = c;
        int now = getfail1(last1);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail1(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last1 = ch[now][c - 'a'];
        cnt[last1]++;
        if (len[last1] == r - l + 1) last2 = last1;
        return dep[last1];
    }
    int insertL(char c) {
        s[--l] = c;
        int now = getfail2(last2);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail2(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last2 = ch[now][c - 'a'];
        cnt[last2]++;
        if (len[last2] == r - l + 1) last1 = last2;
        return dep[last2];
    }
}
```

### Border

来源： [Codeforces Round #463 G. Palindrome Partition]( https://codeforces.com/contest/932/problem/G ) 

```c++
namespace pam {
    int sz, tot, last;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn], dif[maxn], slink[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l; fail[sz] = 0;
        cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last = 0;
        s[tot = 0] = '$';
        node(0); node(-1);
        fail[0] = 1;
    }
    int getfail(int x) {
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void insert(char c) {
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
 
            dif[x] = len[x] - len[fail[x]];
            if (dif[x] == dif[fail[x]]) slink[x] = slink[fail[x]];
            else slink[x] = fail[x];
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }
}
using pam::len;
using pam::fail;
using pam::slink;
using pam::dif;
 
int n, dp[maxn], g[maxn]; char s[maxn], t[maxn];
 
int main() {
    pam::clear();
    scanf("%s", s + 1); n = strlen(s + 1);
    for (int i = 1, j = 0; i <= n; i++) t[++j] = s[i], t[++j] = s[n - i + 1];
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        pam::insert(t[i]);
        for (int x = pam::last; x > 1; x = slink[x]) {
            g[x] = dp[i - len[slink[x]] - dif[x]];
            if (dif[x] == dif[fail[x]]) g[x] = add(g[x], g[fail[x]]);
            if (i % 2 == 0) dp[i] = add(dp[i], g[x]);
        }
    }
    printf("%d", dp[n]);
    return 0;
}
```

### 获取回文子串结点

```c++
int get(int u, int ql) {
  if (ql > len[u]) return len[u];
  while (true) {
    int l = len[slink[u]];
    int d = dif[u];
    if (ql >= l) {
      return ((ql - l) / d) * d + l;
    }
    u = slink[u];
  }
  return 0;
}
```

## 最小表示法

```c++
int getmin(char* s) {
    int n = strlen(s), i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n) {
        int t = s[(i + k) % n] - s[(j + k) % n];
        if (!t) k++;
        else {
            if (t > 0) i += k + 1;
            else j += k + 1;
            if (i == j) j++;
            k = 0;
        }
    }
    return min(i, j) + 1;
}
```

## Runs

```c++
namespace Runs {
  struct SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
      for (int i = 1; i <= m; i++) c[i] = 0;
      for (int i = 1; i <= n; i++) c[x[i]]++;
      for (int i = 1; i <= m; i++) c[i] += c[i - 1];
      for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
      int a = i + k > n ? -1 : y[i + k];
      int b = j + k > n ? -1 : y[j + k];
      return y[i] == y[j] && a == b;
    }
    int dp[21][maxn];
    void build(int nn, const char* s) {
      n = nn; m = 255;
      for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
      rsort();
      for (int k = 1, p; k <= n; k += k, m = p) {
        p = 0;
        for (int i = n; i > n - k; i--) y[++p] = i;
        for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
        rsort();
        for (int i = 1; i <= n; i++) swap(x[i], y[i]);
        x[sa[1]] = p = 1;
        for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
      }
      for (int i = 1; i <= n; i++) x[sa[i]] = i;
      for (int i = 1, k = 0; i <= n; i++) {
        if (k) k--;
        int j = sa[x[i] - 1];
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
        h[x[i]] = k;
      }
      for (int i = 1; i <= n; i++) dp[0][i] = h[i];
      for (int j = 1; j < 21; j++) {
        for (int i = 1; i + (1 << j) <= n + 1; i++) {
          dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);
        }
      }
    }
    int qlcp(int l, int r) {
      if (l < 1 || l > n) return 0;
      if (r < 1 || r > n) return 0;
      if (l == r) return n - l + 1;
      l = x[l]; r = x[r];
      if (l > r) swap(l, r);
      l++; int k = __lg(r - l + 1);
      return min(dp[k][l], dp[k][r - (1 << k) + 1]);
    }
  } ori, rev;

  int n; char s[maxn];

  bool cmp(int x, int y) {
    int len = ori.qlcp(x, y);
    if (x + len > n) return false;
    if (y + len > n) return true;
    return s[x + len] < s[y + len];
  }

  set<PII> mp;
  void add(int l, int r, int p) {
    if (mp.count({l, r})) return ;
    // Run => (l, r, p)
    mp.insert({l, r});
    for (int i = 0; i < p * 2 && l + 2 * p - 1 + i <= r; i++) {
      for (int j = l + 2 * p - 1 + i; j <= r; j += 2 * p) {
        // Primitive Square: [j-2p+1,j]
      }
    }
    for (int i = l; i < l + p; i++) {
      // primitive x power string [i,i+px-1]
      int x = (r - i + 1) / p;
    }
  }
  void check(int l, int r) {
    int len = r - l;
    int lcp = ori.qlcp(l, r); // lcp of s[l...n], s[r...n]
    int lcs = rev.qlcp(n - l + 2, n - r + 2); // lcs of s[1...l-1], s[1...r-1]
    if (lcp + lcs >= len) {
      add(l - lcs, r + lcp - 1, len);
    }
  }
  void find(int type) {
    static int st[maxn], stn;
    stn = 0; st[stn++] = n + 1;
    for (int i = n; i >= 1; i--) {
      while (stn > 1 && cmp(i, st[stn - 1]) == type) stn--;
      check(i, st[stn - 1]);
      st[stn++] = i;
    }
  }
  void build(int nn, char* ss) {
    n = nn;
    for (int i = 1; i <= n; i++) s[i] = ss[i];
    s[n + 1] = 0;
    ori.build(n, ss); // 原串
    reverse(ss + 1, ss + n + 1);
    rev.build(n, ss); // 反串
    mp.clear();
    find(0); find(1);
  }
}
```

## Lyndon 分解

下标从 $1$ 开始。

```c++
void duval(int n, char s[]) {
    for (int i = 1, j, k; i <= n; ) {
        j = i; k = i + 1;
        while (k <= n && s[j] <= s[k]) {
            if (s[j] < s[k]) {
                j = i;
            } else {
                j++;
            }
            k++;
        }
        while (i <= j) {
            printf("%d ", i + k - j - 1);
            i += k - j;
        }
    }
}
```

## 区间本质不同子串

时间复杂度：$O(n\log^2n)$。

```c++
namespace BIT {
  ll c[maxn], s[maxn];
  inline int lowbit(int i) { return i & -i; }
  inline void update(int i, int x) {
    ll y = 1ll * i * x;
    for (; i < maxn; i += lowbit(i)) {
      c[i] += x; s[i] += y;
    }
  }
  inline void update(int l, int r, int x) {
    l++; r++;
    update(l, x); update(r + 1, -x);
  }
  inline ll query(ll* a, int i) {
    ll r = 0;
    for (; i; i -= lowbit(i)) r += a[i];
    return r;
  }
  inline ll query(int l, int r) {
    l++; r++;
    return (r - l + 1) * query(c, l - 1) + (r + 1) * (query(c, r) - query(c, l - 1)) 
      - query(s, r) + query(s, l - 1);
  }
}

namespace sam {
  int sz, last, cnt[maxn << 1];
  int len[maxn << 1], link[maxn << 1], ch[maxn << 1][26];
  void clear() {
    for (int i = 1; i <= sz; i++) {
      len[i] = link[i] = cnt[i] = 0;
      ms(ch[i], 0);
    }
    sz = last = 1;
  }
  int insert(int c) {
    int cur = ++sz, p = last;
    len[cur] = len[last] + 1;
    cnt[cur] = 1;
    for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
    if (!p) link[cur] = 1;
    else {
      int q = ch[p][c];
      if (len[p] + 1 == len[q]) link[cur] = q;
      else {
        int nq = ++sz;
        len[nq] = len[p] + 1;
        link[nq] = link[q];
        link[q] = link[cur] = nq;
        memcpy(ch[nq], ch[q], sizeof ch[q]);
        for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
      }
    }
    return last = cur;
  }
  int tin[maxn << 1], tout[maxn << 1];
  vector<int> edge[maxn << 1];
  void build() {
    for (int i = 2; i <= sz; i++) {
      edge[link[i]].push_back(i);
    }
    int tot = 0;
    function<void(int)> dfs = [&](int u) {
      tin[u] = ++tot;
      for (int v: edge[u]) dfs(v);
      tout[u] = tot;
    };
    dfs(1);
  }
}
using sam::len;
using sam::tin;
using sam::tout;

int vis[maxn << 1], up[maxn << 1];
namespace SegT {
  #define lson l, m, rt << 1
  #define rson m + 1, r, rt << 1 | 1
  int mx[maxn << 3];
  void update(int i, int x, int l = 1, int r = sam::sz, int rt = 1) {
    if (l == r) {
      mx[rt] = x; return ;
    }
    int m = (l + r) / 2;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    mx[rt] = max(mx[rt << 1], mx[rt << 1 | 1]);
  }
  int query(int L, int R, int l = 1, int r = sam::sz, int rt = 1) {
    if (L <= l && r <= R) return mx[rt];
    int m = (l + r) / 2, ans = 0;
    if (L <= m) ans = query(L, R, lson);
    if (R > m) ans = max(ans, query(L, R, rson));
    return ans;
  }
}

int n, q;
char s[maxn];
vector<PII> que[maxn];
ll ans[maxn];

int main() {
  sam::clear();
  scanf("%d%d%s", &n, &q, s + 1);
  for (int i = 1; i <= n; i++) {
    sam::insert(s[i] - 'a');
  }
  sam::build();
  for (int i = 1, l, r; i <= q; i++) {
    scanf("%d%d", &l, &r); l++; r++;
    que[r].emplace_back(l, i);
  }
  for (int r = 1, u = 1; r <= n; r++) {
    u = sam::ch[u][s[r] - 'a'];
    assert(sam::len[u] == r);
    BIT::update(1, r, 1);
    int x = u;
    while (x > 1 && !vis[x]) {
      vis[x] = true; x = sam::link[x];
    }
    while (x > 1) {
      int cur = SegT::query(tin[x], tout[x]);
      BIT::update(cur - len[x] + 1, cur - len[up[cur]], -1);
      swap(up[cur], x);
    }
    SegT::update(tin[u], r); up[r] = 1;
    for (auto& q: que[r]) {
      ans[q.second] = BIT::query(q.first, r);
    }
  }
  for (int i = 1; i <= q; i++) {
    printf("%lld\n", ans[i]);
  }
  return 0;
}
```

### 区间本质不同回文串

时间复杂度：$O(n\log^2n)$。

```c++
int n, m, node[maxn], tin[maxn], tout[maxn], tot;
char s[maxn];
vector<int> edge[maxn];
vector<PII> que[maxn];

void dfs(int u) {
  tin[u] = ++tot;
  for (int i = 0; i < (int)edge[u].size(); i++) {
    dfs(edge[u][i]);
  }
  tout[u] = tot;
}

namespace pam {
  int sz, tot, last;
  int ch[maxn][26], len[maxn], fail[maxn];
  int cnt[maxn], dep[maxn], dif[maxn], slink[maxn];
  char s[maxn];
  int node(int l) {
    sz++; ms(ch[sz], 0);
    len[sz] = l; fail[sz] = 0;
    cnt[sz] = dep[sz] = 0;
    return sz;
  }
  void clear() {
    sz = -1; last = 0;
    s[tot = 0] = '$';
    node(0); node(-1);
    fail[0] = 1;
  }
  int getfail(int x) {
    while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
    return x;
  }
  int insert(char c) {
    s[++tot] = c;
    int now = getfail(last);
    if (!ch[now][c - 'a']) {
      int x = node(len[now] + 2);
      fail[x] = ch[getfail(fail[now])][c - 'a'];
      dep[x] = dep[fail[x]] + 1;
      ch[now][c - 'a'] = x;
 
      dif[x] = len[x] - len[fail[x]];
      if (dif[x] == dif[fail[x]]) slink[x] = slink[fail[x]];
      else slink[x] = fail[x];
    }
    last = ch[now][c - 'a'];
    cnt[last]++;
    return last;
  }
}
using pam::len;
using pam::fail;
using pam::slink;
using pam::dif;

struct BIT {
  int a[maxn];
  void update(int i, int x) {
    for (; i <= n; i += i & -i) a[i] += x;
  }
  void update(int l, int r, int x) {
    update(l, x); update(r + 1, -x);
  }
  int query(int i) {
    int r = 0;
    for (; i; i -= i & -i) r += a[i];
    return r;
  }
} f;

struct SegTree {
  #define lson l, m, rt << 1
  #define rson m + 1, r, rt << 1 | 1
  int a[maxn << 2];
  void update(int i, int x, int l = 1, int r = pam::sz + 1, int rt = 1) {
    if (l == r) {
      a[rt] = x; return ;
    }
    int m = (l + r) / 2;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    a[rt] = max(a[rt << 1], a[rt << 1 | 1]);
  }
  int query(int L, int R, int l = 1, int r = pam::sz + 1, int rt = 1) {
    if (L <= l && r <= R) return a[rt];
    int m = (l + r) / 2, ans = 0;
    if (L <= m) ans = query(L, R, lson);
    if (R > m) ans = max(ans, query(L, R, rson));
    return ans;
  }
} g;

int main() {
  pam::clear();
  scanf("%d%d%s", &n, &m, s + 1);
  for (int i = 1; i <= n; i++) node[i] = pam::insert(s[i]);
  edge[1].push_back(0);
  for (int i = 2; i <= pam::sz; i++) edge[fail[i]].push_back(i);
  dfs(1);
  for (int i = 1, l, r; i <= m; i++) {
    scanf("%d%d", &l, &r); que[r].push_back({l, i});
  }
  int ans = 0;
  for (int i = 1; i <= n; i++) {
    int u = node[i];
    for (int x = u; x > 1; x = slink[x]) {
      int pos = g.query(tin[x], tout[x]) - len[x] + 1;
      int l = max(pos + 1, 1);
      int r = i - len[slink[x]] - dif[x] + 1;
      f.update(l, r, 1);
    }
    g.update(tin[u], i);
    for (int j = 0; j < (int)que[i].size(); j++) {
      int p = que[i][j].first, id = que[i][j].second;
      ans += 1ll * id * f.query(p) % mod;
      if (ans >= mod) ans -= mod;
    }
  }
  printf("%d", ans);
  return 0;
}
```

