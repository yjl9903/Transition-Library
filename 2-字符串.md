# 字符串

## 哈希

1. 第 $n$ 位哈希值置 0，从 $n−1$ 开始逆序计算哈希值。 
2. 获取子串 $[l,r)$ 的哈希值，注意预处理和取模细节。
3. 注意不要将字符映射到 $0$ 上。

```c++
typedef long long ll;
typedef unsigned long long ull;
const int seed = 135;
const int maxn = 1000000 + 10;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;

ull xp1[maxn], xp2[maxn], xp[maxn];
void init() {
    xp1[0] = xp2[0] = xp[0] = 1;
    for (int i = 1; i < maxn; ++i) {
        xp1[i] = xp1[i - 1] * seed % p1;
        xp2[i] = xp2[i - 1] * seed % p2;
        xp[i] = xp[i - 1] * seed;
    }
}

#define ENABLE_DOUBLE_HASH

// index start at 0
char s[maxn];
ull h[maxn], hl[maxn];
ull Hash() { 
    int length = strlen(s);
    ull res1 = 0, res2 = 0;
    h[length] = 0;  // ATTENTION!
    for (int j = length - 1; j >= 0; j--) {
    #ifdef ENABLE_DOUBLE_HASH
        res1 = (res1 * seed + s[j]) % p1;
        res2 = (res2 * seed + s[j]) % p2;
        h[j] = (res1 << 32) | res2;
    #else
        res1 = res1 * seed + s[j];
        h[j] = res1;
    #endif
    }
    return h[0];
}

// 获取子串哈希，左闭右开区间
ull get(int left, int right) {
    int len = right - left;
#ifdef ENABLE_DOUBLE_HASH
    // get hash of s[left...right-1]
    unsigned int mask32 = ~(0u);
    ull left1 = h[left] >> 32, right1 = h[right] >> 32;
    ull left2 = h[left] & mask32, right2 = h[right] & mask32;
    return (((left1 - right1 * xp1[len] % p1 + p1) % p1) << 32) |
            (((left2 - right2 * xp2[len] % p2 + p2) % p2));
#else
    return h[left] - h[right] * xp[len];
#endif
}
```

## KMP

参数：前一个为文本串，后一个为模式串。

```c++
char s[maxn], p[maxn];
int nxt[maxn];

void getnxt(char *p) {
    int len = strlen(p), k = -1, i = 0; nxt[0] = -1;
    while (i < len) {
        if (k == -1 || p[k] == p[i]) i++, k++, nxt[i] = k;
        else k = nxt[k];
    }
}
void getfail(int len, char* s, int fail[]) {
    fail[1] = 0;
    for (int i = 2; i <= len; i++) {
        int cur = fail[i - 1];
        while (cur > 0 && s[cur + 1] != s[i])
            cur = fail[cur];
        if (s[cur + 1] == s[i])
            ++cur;
        fail[i] = cur;
    }
}
int kmp(char *s, char *p) {
    getnxt(p);
    int slen = strlen(s), plen = strlen(p), i = 0, j = 0;
    while (i < slen && j < plen) {
        if (j == -1 || s[i] == p[j]) i++, j++;
        else j = nxt[j];
    }
    if (j == plen) return i - j;
    return -1;
}
void kmp(char *s, char *p) {
    int slen = strlen(s + 1), plen = strlen(p + 1), cur = 0;
    getfail(plen, p, nxt);
    for (int i = 1; i <= slen; i++) {
        while (cur > 0 && s[i] != p[cur + 1]) cur = nxt[cur];
        if (p[cur + 1] == s[i]) cur++;
        if (cur == plen) {
            printf("%d\n", i - cur + 1);
            cur = nxt[cur];
        }
    }
}
```

### 扩展KMP

$extend[i]$ 表示 $T$ 和 $S[i\dots n-1]$ 的最长公共前缀。

```c++
char s[maxn], t[maxn];
int nxt[maxn], extend[maxn];

void getnxt(char *s) {
    int n = strlen(s), p = 0, k = 1; nxt[0] = n;
    while (p + 1 < n && s[p] == s[p + 1]) p++;
    nxt[1] = p;
    for (int i = 2; i < n; i++) {
        p = k + nxt[k] - 1;
        if (i + nxt[i - k] <= p) nxt[i] = nxt[i - k];
        else {
            int j = max(p - i + 1, 0);
            while (i + j < n && s[i + j] == s[j]) j++;
            nxt[i] = j; k = i;
        }
    }
}
void exkmp(char *t, char *s) { 
    getnxt(s); 
    int tlen = strlen(t), slen = strlen(s), p = 0, k = 0;
    while (p < tlen && p < slen && t[p] == s[p]) p++;
    extend[0] = p;
    for (int i = 1; i < tlen; i++) {
        p = k + extend[k] - 1;
        if (i + nxt[i - k] <= p) extend[i] = nxt[i - k];
        else {
            int j = max(p - i + 1, 0);
            while (i + j < tlen && j < slen && t[i + j] == s[j]) j++;
            extend[i] = j; k = i;
        }
    }
}
```

## 后缀数组

```c++
namespace SA{
    int n, m, a[maxn], x[maxn], y[maxn], c[maxn], sa[maxn], h[maxn];
    void rsort() {
        for (int i = 0; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {return y[i] == y[j] && y[i + k] == y[j + k];}
    void init() {
        m = 130; n = strlen(s);
        for (int i = 1; i <= n; i++) x[i] = a[i] = s[i - 1], y[i] = i;
        rsort();
        for (int k = 1, p = 1; p < n; k += k, m = p) {
            p = 0;
            for (int i = n - k + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort(); swap(x, y); x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) 
            	  x[sa[i]] = cmp(sa[i - 1], sa[i], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
    }
    void geth() {
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (a[i + k] == a[j + k] && k < n) k++;
            h[x[i]] = k;
        }
    }
}
```

## 后缀自动机

```c++
namespace sam{
    int len[maxn], cnt[maxn], link[maxn], ch[maxn][26], tot, last;
    void init() { ms(ch, 0); ms(cnt, 0); tot = last = 1; }
    void insert(int c) {
        int cur = ++tot, p = last;
        len[cur] = len[last] + 1; cnt[cur] = 1;
        for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
        if (!p) link[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) link[cur] = q;
            else {
                int nq = ++tot; len[nq] = len[p] + 1;
                link[nq] = link[q]; link[q] = link[cur] = nq;
                memcpy(ch[nq], ch[q], sizeof ch[q]);
                for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
            }
        } 
        last = cur;
    }
}
```

### 不同子串个数

```c++
ll cal() {  
		ll ans = 0;
  	for (int i = 1; i <= tot; i++) ans += len[i] - len[link[i]];
  	return ans;
}
```

### 子串出现次数

```c++
int c[maxn], a[maxn];
void rsort() {
    for (int i = 1; i <= tot; i++) c[i] = 0;
    for (int i = 1; i <= tot; i++) c[len[i]]++;
    for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
    for (int i = 1; i <= tot; i++) a[c[len[i]]--] = i;
    for (int i = tot; i; i--) {
        int p = a[i];
        cnt[link[p]] += cnt[p];
    }
}
```

### 最长公共子串

```c++
int ans = 0, now = 1, l = 0;
for (int i = 0; s[i]; i++) {
    while (now && !ch[now][s[i] - 'a']) now = link[now], l = len[now];
    if (!now) now = 1, l = 0;
    else l++, now = ch[now][s[i] - 'a'];
    ans = max(ans, l);
}
```
## Manacher

```c++
namespace manacher {
    char s[maxn << 1] = "##";
    int n, hw[maxn << 1];
    void init() {
        int len = strlen(a);
        for (int i = 0; i < len; i++) {
            s[i * 2 + 2] = a[i];
            s[i * 2 + 3] = '#';
        }
        n = len * 2 + 2; s[n] = 0;
    }
    void manacher() {
        int maxr = 0, m = 0;
        for (int i = 1; i < n; i++) {
            if (i < maxr) hw[i] = min(hw[m * 2 - i], hw[m] + m - i);
            else hw[i] = 1;
            while (s[i + hw[i]] == s[i - hw[i]]) hw[i]++;
            if (hw[i] + i > maxr) {
                m = i; maxr = hw[i] + i;
            }
        }
    }
    int getMax() {
        init(); manacher(); int ans = 1;
        for (int i = 0; i < n; i++) ans = max(ans, hw[i]);
        return ans - 1;
    }
}
```

## 最小表示法

```c++
int getmin(char* s) {
    int n = strlen(s), i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n) {
        int t = s[(i + k) % n] - s[(j + k) % n];
        if (!t) k++;
        else {
            if (t > 0) i += k + 1;
            else j += k + 1;
            if (i == j) j++;
            k = 0;
        }
    }
    return min(i, j) + 1;
}
```