# 字符串

## 哈希

1. 第 $n$ 位哈希值置 0，从 $n−1$ 开始逆序计算哈希值。 
2. 获取子串 $[l,r)$ 的哈希值，注意预处理和取模细节。
3. 注意不要将字符映射到 $0$ 上。

```c++
typedef long long ll;
typedef unsigned long long ull;
const int seed = 135;
const int maxn = 1000000 + 10;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;

ull xp1[maxn], xp2[maxn], xp[maxn];
void init() {
    xp1[0] = xp2[0] = xp[0] = 1;
    for (int i = 1; i < maxn; ++i) {
        xp1[i] = xp1[i - 1] * seed % p1;
        xp2[i] = xp2[i - 1] * seed % p2;
        xp[i] = xp[i - 1] * seed;
    }
}

#define ENABLE_DOUBLE_HASH

// index start at 0
char s[maxn];
ull h[maxn], hl[maxn];
ull Hash() { 
    int length = strlen(s);
    ull res1 = 0, res2 = 0;
    h[length] = 0;  // ATTENTION!
    for (int j = length - 1; j >= 0; j--) {
    #ifdef ENABLE_DOUBLE_HASH
        res1 = (res1 * seed + s[j]) % p1;
        res2 = (res2 * seed + s[j]) % p2;
        h[j] = (res1 << 32) | res2;
    #else
        res1 = res1 * seed + s[j];
        h[j] = res1;
    #endif
    }
    return h[0];
}

// 获取子串哈希，左闭右开区间
ull get(int left, int right) {
    int len = right - left;
#ifdef ENABLE_DOUBLE_HASH
    // get hash of s[left...right-1]
    unsigned int mask32 = ~(0u);
    ull left1 = h[left] >> 32, right1 = h[right] >> 32;
    ull left2 = h[left] & mask32, right2 = h[right] & mask32;
    return (((left1 - right1 * xp1[len] % p1 + p1) % p1) << 32) |
            (((left2 - right2 * xp2[len] % p2 + p2) % p2));
#else
    return h[left] - h[right] * xp[len];
#endif
}
```

## KMP

参数：前一个为文本串，后一个为模式串。

```c++
char s[maxn], p[maxn];
int nxt[maxn];

void getnxt(char *p) {
    int len = strlen(p), k = -1, i = 0; nxt[0] = -1;
    while (i < len) {
        if (k == -1 || p[k] == p[i]) i++, k++, nxt[i] = k;
        else k = nxt[k];
    }
}
void getfail(int len, char* s, int fail[]) {
    fail[1] = 0;
    for (int i = 2; i <= len; i++) {
        int cur = fail[i - 1];
        while (cur > 0 && s[cur + 1] != s[i])
            cur = fail[cur];
        if (s[cur + 1] == s[i])
            ++cur;
        fail[i] = cur;
    }
}
int kmp(char *s, char *p) {
    getnxt(p);
    int slen = strlen(s), plen = strlen(p), i = 0, j = 0;
    while (i < slen && j < plen) {
        if (j == -1 || s[i] == p[j]) i++, j++;
        else j = nxt[j];
    }
    if (j == plen) return i - j;
    return -1;
}
void kmp(char *s, char *p) {
    int slen = strlen(s + 1), plen = strlen(p + 1), cur = 0;
    getfail(plen, p, nxt);
    for (int i = 1; i <= slen; i++) {
        while (cur > 0 && s[i] != p[cur + 1]) cur = nxt[cur];
        if (p[cur + 1] == s[i]) cur++;
        if (cur == plen) {
            printf("%d\n", i - cur + 1);
            cur = nxt[cur];
        }
    }
}
```

### 扩展KMP

$extend[i]$ 表示 $T$ 和 $S[i\dots n-1]$ 的最长公共前缀。

```c++
char s[maxn], t[maxn];
int nxt[maxn], extend[maxn];

void getnxt(char *s) {
    int n = strlen(s), p = 0, k = 1; nxt[0] = n;
    while (p + 1 < n && s[p] == s[p + 1]) p++;
    nxt[1] = p;
    for (int i = 2; i < n; i++) {
        p = k + nxt[k] - 1;
        if (i + nxt[i - k] <= p) nxt[i] = nxt[i - k];
        else {
            int j = max(p - i + 1, 0);
            while (i + j < n && s[i + j] == s[j]) j++;
            nxt[i] = j; k = i;
        }
    }
}
void exkmp(char *t, char *s) { 
    getnxt(s); 
    int tlen = strlen(t), slen = strlen(s), p = 0, k = 0;
    while (p < tlen && p < slen && t[p] == s[p]) p++;
    extend[0] = p;
    for (int i = 1; i < tlen; i++) {
        p = k + extend[k] - 1;
        if (i + nxt[i - k] <= p) extend[i] = nxt[i - k];
        else {
            int j = max(p - i + 1, 0);
            while (i + j < tlen && j < slen && t[i + j] == s[j]) j++;
            extend[i] = j; k = i;
        }
    }
}
```

## 后缀数组

注意：

1. 下标从 $1$ 开始
2. 每个字符的值域范围

定义：

1. $sa[n]$ : 后缀排序后，排名第 $i$ 个串的开始下标。
2. $rk[n]$ : 原串第 $i$ 个后缀排过序后的名次。
3. $sa[n]$ 和 $rk[n]$ 互为逆运算，$rk[sa[i]]=sa[rk[i]]=i$。
4. $LCP$ : 最长公共前缀。
5. $height[rk[i]] \ge height[rk[i-1]] - 1$。
6. $height[i]$ = $LCP(sa[i - 1],sa[i])$ ($2 \le i \le n$)。 

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    void build(int nn, char* s) {
        n = nn; m = 255; // important
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort(); 
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
    }
}
```

### LCP

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    int dp[maxn][21];
    void build(int nn, char* s) {
        n = nn; m = 255;
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort(); 
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
        for (int i = 1; i <= n; i++) dp[i][0] = h[i];
        for (int j = 1; j < 21; j++) {
            for (int i = 1; i + (1 << j) <= n + 1; i++) {
                dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int qlcp(int l, int r) {
        if (l == r) return n - l + 1;
        l = x[l]; r = x[r];
        if (l > r) swap(l, r);
        l++;
        int k = 0; while ((1 << (k + 1)) <= r - l + 1) k++;
        return min(dp[l][k], dp[r - (1 << k) + 1][k]);
    }
}
```

### 一个串的经典问题

#### 本质不同子串个数

${n(n+1) \over 2}-\sum_{i=2}^n height[i]$。

#### 可重叠的最长重复子串

$height$ 数组最大值。

#### 不可重叠的最长重复子串

二分答案。

当前二分到 $mid$, 将 $height$ 数组中连续大于等于 $mid$ 的位置划分进一块，一个块内求出现位置的最大值和最小值，如果相差大于等于 $mid$，即代表出现了一段不重叠的重复子串。

```c++
int check(int len) {
    int mx = sa[1], mn = sa[1];
    for (int i = 2; i <= n; i++) {
        if (h[i] >= len) {
            mn = min(mn, sa[i]);
            mx = max(mx, sa[i]);
            if (mx - mn >= len) return 1;
        } else mx = sa[i], mn = sa[i];
    }
    return 0;
}
```

#### 循环节最多的子串

枚举循环节大小 $len$，求 $s[1],s[1+len], s[1+2\cdot len], \dots$，相邻两个的 $LCP$，设 $LCP$ 为 $x$，则循环节个数至少为 ${x \over len} + 1$，再特判一下剩余的 $len - x \bmod len$ 个字符，将 $s[1+k\cdot len]$ 向前推这么多能否构成一个更多的循环节。

### 两个串的经典问题

#### 最长公共子串

将两个串用一个小字符连起来，建一个后缀数组。

$ans=max(height[i])$，满足 $sa[i]$ 和 $sa[i-1]$ 不在同一个串内。

### 多个串的经典问题

将多个串用不同的未出现字符连成一个（注意值域大小）。

#### 出现在至少 $k$ 个串中的最长子串

二分答案，对 $height$ 分块，判断一个块内是否出现 $k$ 次。

## AC 自动机

```c++
namespace ACAM {
    static const int maxp = 100000 + 5;
    int sz, ch[maxp][26], fail[maxp];
    int match[maxp], val[maxp];
    int node() {
        ms(ch[++sz], 0); fail[sz] = 0; val[sz] = 0;
        return sz;
    }
    void clear() {
        sz = 0; node();
        for (int i = 0; i < 26; i++) ch[0][i] = 1;
    }
    ACAM() { clear(); }
    void insert(char* s, int i) {
        int u = 1;
        for (int i = 0; s[i]; i++) {
            int v = s[i] - 'a';
            if (!ch[u][v]) ch[u][v] = node();
            u = ch[u][v];
        }
        val[u]++; match[i] = u;
    }
    void build() {
        queue<int> q; q.push(1);
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (int i = 0; i < 26; i++) {
                if (ch[t][i]) {
                    fail[ch[t][i]] = ch[fail[t]][i];
                    q.push(ch[t][i]);
                } else {
                    ch[t][i] = ch[fail[t]][i];
                }
            }
        }
    }
}
```


### 注意

+ $1$ 号结点为空结点。
+ 字母大小写和字母值域。

### 定义

+ fail 指针: 当前结点对应串的最长后缀，使得他也是 Trie 树上的结点，类似于 KMP。

+ Trie 图: 建完 AC 自动机后，Trie 树变成了 Trie 图，Trie 树上不存在的出边补成 fail 指针指向结点的对应出边。

### 危险结点

串的终止结点是危险结点，fail 指向危险结点的是危险结点。

```c++
int node() {
    ms(ch[++sz], 0); 
    fail[sz] = 0; danger[sz] = 0;
    return sz;
}
void build() {
    queue<int> q; q.push(1);
    while (!q.empty()) {
        int t = q.front(); q.pop();
        for (int i = 0; i < 2; i++) {
            if (ch[t][i]) {
                fail[ch[t][i]] = ch[fail[t]][i];
                danger[ch[t][i]] |= danger[fail[ch[t][i]]];
                // pushdown danger
                q.push(ch[t][i]);
            } else {
                ch[t][i] = ch[fail[t]][i];
            }
        }
    }
}
```

### 求所有模式串出现次数

类似于 KMP，在 Trie 上的每个点打标记，然后将标记从底往上传递，其实就是将 fail 树建初来，求子树大小。

也可以对 fail 树跑拓扑排序。

```c++
vector<int> edge[maxp];
int siz[maxp];
void dfs(int u) {
    for (int& v: edge[u]) {
        dfs(v); siz[u] += siz[v];
    }
}
vector<int> query(int n, char* s) {
    // n: 文本串个数, s: 询问串
    for (int i = 0; i <= sz; i++) edge[i].clear(), siz[i] = 0;
    int now = 1;
    for (int i = 0; s[i]; i++) {
        now = ch[now][s[i] - 'a'];
        siz[now]++;
    }
    for (int i = 2; i <= sz; i++) edge[fail[i]].push_back(i);
    dfs(1);
    vector<int> ans(1, 0);
    for (int i = 1; i <= n; i++) ans.push_back(siz[match[i]]);
    return ans;
}
```

### 询问串包含另一个串的个数

枚举第一个串的每个前缀，即跳 Trie 上的父亲，再每次跳 fail 指针，看能否跳到另外一个结点上。

### AC 自动机上 DP

令 $dp[i][j]$ 表示询问串长度为 $i$，处于结点 $j$ 的不包含任何一个 Trie 树结点的情况数。

枚举长度，再枚举每个状态 $j$ 的儿子 $v$，且 $ch[j][v]$ 不是危险结点，因为到该状态不包含任何一个模板串，加入一个新的字母后，只存在当前某个后缀可能会变成模板串，如果该节点是危险结点，意味着他含有一个后缀是模板串，否则不就一定存在模板串，此时有转移方程 $dp[i][ch[j][v]]+=dp[i-1][j]$。

优化：显然每次转移的转移矩阵相同，矩阵快速幂加速。

## 后缀自动机

```c++
namespace sam {
    int len[maxn], cnt[maxn], link[maxn], ch[maxn][26], tot, last;
    void init() { 
        ms(ch, 0); ms(cnt, 0); tot = last = 1; 
    }
    void insert(int c) {
        int cur = ++tot, p = last;
        len[cur] = len[last] + 1; cnt[cur] = 1;
        for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
        if (!p) link[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) link[cur] = q;
            else {
                int nq = ++tot; len[nq] = len[p] + 1;
                link[nq] = link[q]; link[q] = link[cur] = nq;
                memcpy(ch[nq], ch[q], sizeof ch[q]);
                for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
            }
        } 
        last = cur;
    }
}
```

### 不同子串个数

#### 方法一

不同子串数目即 $sam$ 上的不同路径的数目，记忆化搜索。

```c++
ll dfs(int u) {
    if (ans[u] != -1) return ans[u];
    ll x = 1;
    for (int i = 0; i < 26; i++) {
        if (!ch[u][i]) continue;
        x += dfs(ch[u][i]);
    }
    return ans[u] = x;
}

dfs(1);
printf("%lld", ans[1] - 1);
```

#### 方法二

不同子串数目为 $sam$ 上每个 $endpos$ 状态上的子串数目,  即 $\sum_{i = 1}^{tot} len(i)-len(link(i))$。

```c++
ll cal(){  
  ll ans = 0;
  for (int i = 1; i <= tot; i++) ans += len[i] - len[link[i]];
  return ans;
}
```

##### 增量维护前缀不同子串数

参考 [HDu4622](http://acm.hdu.edu.cn/viewcode.php?rid=26316331) 和 [SDOI2016 生成魔咒](https://www.luogu.org/problemnew/show/P4070)。

```c++
ll insert(int c) {
    // ...
    return cnt = cnt + len[cur] - len[link[cur]];
}
```

### 子串出现次数

按长度对状态基数排序可以得到 $sam$ 的拓扑排序序列。

```c++
int c[maxn], a[maxn];
void rsort() {
    for (int i = 1; i <= tot; i++) c[i] = 0;
    for (int i = 1; i <= tot; i++) c[len[i]]++;
    for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
    for (int i = 1; i <= tot; i++) a[c[len[i]]--] = i;
    for (int i = tot; i; i--) {
        int p = a[i];
        cnt[link[p]] += cnt[p];
    }
}
```

### 最长公共子串

对第一个串建立一个 $sam$ ，维护第二个串的每一个前缀的最长公共子串，即每一个前缀在前一个串中出现过的最长后缀。

```c++
int ans = 0, now = 1, l = 0;
for (int i = 0; s[i]; i++) {
    // if (ch[now][s[i] - 'a']) l++, now = ch[now][s[i] - 'a'];
    // else {
    //     while (now && !ch[now][s[i] - 'a']) now = link[now];
    //     if (!now) now = 1, l = 0;
    //     else l = len[now] + 1, now = ch[now][s[i] - 'a'];
    // }
    while (now && !ch[now][s[i] - 'a']) now = link[now], l = len[now];
    if (!now) now = 1, l = 0;
    else l++, now = ch[now][s[i] - 'a'];
    ans = max(ans, l);
}
printf("%d", ans);
```
### 字典序第 $k$ 大子串

$t=0$，重复子串只算一个；$t=1$，重复子串算多个。

```c++
void rsort(int t) {
    for (int i = 1; i <= sz; i++) c[len[i]]++;
    for (int i = 1; i <= sz; i++) c[i] += c[i - 1];
    for (int i = 1; i <= sz; i++) a[c[len[i]]--] = i;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        if (t) cnt[link[p]] += cnt[p];
        else cnt[p] = 1;
    }
    cnt[1] = 0;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        sum[p] = cnt[p];
        for (int j = 0; j < 26; j++) {
            if (ch[p][j])
                sum[p] += sum[ch[p][j]];
        }
    }
}
string query(int k) {
    if (k > sum[1]) return string("-1");
    int u = 1; string ans; k -= cnt[1];
    while (k > 0) {
        int c = 0;
        while (k > sum[ch[u][c]]) {
            k -= sum[ch[u][c]]; c++;
        }
        u = ch[u][c]; ans += ('a' + c); k -= cnt[u];
    }
    return ans;
}
```

## Manacher

下标从 $1$ 开始。

```c++
namespace manacher {
    char s[maxn << 1] = "##";
    int n, hw[maxn << 1];
    void init(char a[]) {
        int i;
        for (i = 1; a[i]; i++) {
            s[i * 2] = a[i];
            s[i * 2 + 1] = '#';
        }
        n = i * 2 + 2; s[n] = 0;
    }
    void manacher() {
        int maxr = 0, m = 0;
        for (int i = 1; i < n; i++) {
            if (i < maxr) hw[i] = min(hw[m * 2 - i], hw[m] + m - i);
            else hw[i] = 1;
            while (s[i + hw[i]] == s[i - hw[i]]) hw[i]++;
            if (hw[i] + i > maxr) {
                m = i; maxr = hw[i] + i;
            }
        }
    }
    int build(char s[]) {
        init(s); manacher();
    }
    int check(int l, int r) {
        // s[l...r] 是否为回文串
        int mid = (l + r);
        if (hw[mid] >= mid - 2 * l + 1) return 1;
        else return 0;
    }
}
```

## 回文树

```c++
namespace pam {
    int sz, tot, last;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l; fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last = 0;
        s[tot = 0] = '$';
        node(0); node(-1);
        fail[0] = 1;
    }
    int getfail(int x) {
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void insert(char c) {
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }
    void count() {
        for (int i = sz; i >= 0; i--) {
            cnt[fail[i]] += cnt[i];
        }
    }
}
```

### 双向加字符

```c++
namespace pam {
    // last1: right, last2: left
    int sz, last1, last2, l, r;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l;
        fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last1 = last2 = 0;
        l = 100002; r = l - 1;
        node(0); node(-1);
        fail[0] = 1;
        ms(s, -1);
    }
    int getfail1(int x) {
        while (s[r - len[x] - 1] != s[r]) x = fail[x];
        return x;
    }
    int getfail2(int x) {
        while (s[l + len[x] + 1] != s[l]) x = fail[x];
        return x;
    }
    int insertR(char c) {
        s[++r] = c;
        int now = getfail1(last1);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail1(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last1 = ch[now][c - 'a'];
        cnt[last1]++;
        if (len[last1] == r - l + 1) last2 = last1;
        return dep[last1];
    }
    int insertL(char c) {
        s[--l] = c;
        int now = getfail2(last2);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail2(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last2 = ch[now][c - 'a'];
        cnt[last2]++;
        if (len[last2] == r - l + 1) last1 = last2;
        return dep[last2];
    }
}
```

## 最小表示法

```c++
int getmin(char* s) {
    int n = strlen(s), i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n) {
        int t = s[(i + k) % n] - s[(j + k) % n];
        if (!t) k++;
        else {
            if (t > 0) i += k + 1;
            else j += k + 1;
            if (i == j) j++;
            k = 0;
        }
    }
    return min(i, j) + 1;
}
```