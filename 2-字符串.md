# 字符串

## 哈希

1. 第 $n$ 位哈希值置 0，从 $n−1$ 开始逆序计算哈希值。 
2. 获取子串 $[l,r)$ 的哈希值，注意预处理和取模细节。
3. 注意不要将字符映射到 $0$ 上。

```c++
typedef long long ll;
typedef unsigned long long ull;
const int seed = 135;
const int maxn = 1000000 + 10;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;

ull xp1[maxn], xp2[maxn], xp[maxn];
void init() {
    xp1[0] = xp2[0] = xp[0] = 1;
    for (int i = 1; i < maxn; ++i) {
        xp1[i] = xp1[i - 1] * seed % p1;
        xp2[i] = xp2[i - 1] * seed % p2;
        xp[i] = xp[i - 1] * seed;
    }
}

#define ENABLE_DOUBLE_HASH

// index start at 0
char s[maxn];
ull h[maxn], hl[maxn];
ull Hash() { 
    int length = strlen(s);
    ull res1 = 0, res2 = 0;
    h[length] = 0;  // ATTENTION!
    for (int j = length - 1; j >= 0; j--) {
    #ifdef ENABLE_DOUBLE_HASH
        res1 = (res1 * seed + s[j]) % p1;
        res2 = (res2 * seed + s[j]) % p2;
        h[j] = (res1 << 32) | res2;
    #else
        res1 = res1 * seed + s[j];
        h[j] = res1;
    #endif
    }
    return h[0];
}

// 获取子串哈希，左闭右开区间
ull get(int left, int right) {
    int len = right - left;
#ifdef ENABLE_DOUBLE_HASH
    // get hash of s[left...right-1]
    unsigned int mask32 = ~(0u);
    ull left1 = h[left] >> 32, right1 = h[right] >> 32;
    ull left2 = h[left] & mask32, right2 = h[right] & mask32;
    return (((left1 - right1 * xp1[len] % p1 + p1) % p1) << 32) |
            (((left2 - right2 * xp2[len] % p2 + p2) % p2));
#else
    return h[left] - h[right] * xp[len];
#endif
}
```

## KMP

下标从 $1$ 开始。

参数：前一个为文本串，后一个为模式串。

```c++
char s[maxn], p[maxn];
int nxt[maxn];

void getfail(int len, char* s, int fail[]) {
    fail[1] = 0;
    for (int i = 2; i <= len; i++) {
        int cur = fail[i - 1];
        while (cur > 0 && s[cur + 1] != s[i])
            cur = fail[cur];
        if (s[cur + 1] == s[i])
            ++cur;
        fail[i] = cur;
    }
}
void kmp(char *s, char *p) {
    int slen = strlen(s + 1), plen = strlen(p + 1), cur = 0;
    getfail(plen, p, nxt);
    for (int i = 1; i <= slen; i++) {
        while (cur > 0 && s[i] != p[cur + 1]) cur = nxt[cur];
        if (p[cur + 1] == s[i]) cur++;
        if (cur == plen) {
            printf("%d\n", i - cur + 1);
            cur = nxt[cur];
        }
    }
}
```

### 扩展KMP

下标从 $1$ 开始。

$extend[i]$ 表示 $T[i\dots n-1]$ 和 $S$ 的最长公共前缀。

```c++
namespace exkmp {
    int nxt[maxn], extend[maxn];
    void getnxt(int n, char *s) {
        int p = 1, k = 2; nxt[1] = n;
        while (p + 1 <= n && s[p] == s[p + 1]) p++;
        nxt[2] = p - 1;
        for (int i = 3; i <= n; i++) {
            int len = nxt[i - k + 1];
            if (len + i <= p) nxt[i] = len;
            else {
                int j = max(p - i + 1, 0);
                while (i + j <= n && s[j + 1] == s[i + j]) j++;
                nxt[i] = j; k = i;
                p = i + j - 1;
            }
        }
    }
    void build(int tlen, char *t, int slen, char *s) { 
        getnxt(slen, s); 
        int p = 1, k = 1;
        while (p <= tlen && p <= slen && t[p] == s[p]) p++;
        p--; extend[1] = p;
        for (int i = 2; i <= tlen; i++) {
            int len = nxt[i - k + 1];
            if (len + i <= p) extend[i] = len;
            else {
                int j = max(p - i + 1, 0);
                while (i + j <= tlen && j <= slen && s[j + 1] == t[i + j]) j++;
                extend[i] = j; k = i;
                p = i + j - 1;
            }
        }
    }
}
```

## 后缀数组

注意：

1. 下标从 $1$ 开始
2. 每个字符的值域范围

定义：

1. $sa[n]$ : 后缀排序后，排名第 $i$ 个串的开始下标。
2. $rk[n]$ : 原串第 $i$ 个后缀排过序后的名次。
3. $sa[n]$ 和 $rk[n]$ 互为逆运算，$rk[sa[i]]=sa[rk[i]]=i$。
4. $LCP$ : 最长公共前缀。
5. $height[rk[i]] \ge height[rk[i-1]] - 1$。
6. $height[i]$ = $LCP(sa[i - 1],sa[i])$ ($2 \le i \le n$)。 

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    void build(int nn, char* s) {
        n = nn; m = 255; // important
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort(); 
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
    }
}
```

### LCP

```c++
namespace SA {
    int n, m, sa[maxn], h[maxn], c[maxn], x[maxn], y[maxn];
    void rsort() {
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
    }
    int cmp(int i, int j, int k) {
        int a = i + k > n ? -1 : y[i + k];
        int b = j + k > n ? -1 : y[j + k];
        return y[i] == y[j] && a == b;
    }
    int dp[maxn][21];
    void build(int nn, char* s) {
        n = nn; m = 255;
        for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
        rsort();
        for (int k = 1, p; k <= n; k += k, m = p) {
            p = 0;
            for (int i = n; i > n - k; i--) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            rsort(); 
            for (int i = 1; i <= n; i++) swap(x[i], y[i]);
            x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p;
        }
        for (int i = 1; i <= n; i++) x[sa[i]] = i;
        for (int i = 1, k = 0; i <= n; i++) {
            if (k) k--;
            int j = sa[x[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[x[i]] = k;
        }
        for (int i = 1; i <= n; i++) dp[i][0] = h[i];
        for (int j = 1; j < 21; j++) {
            for (int i = 1; i + (1 << j) <= n + 1; i++) {
                dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int qlcp(int l, int r) {
        if (l == r) return n - l + 1;
        l = x[l]; r = x[r];
        if (l > r) swap(l, r);
        l++;
        int k = 0; while ((1 << (k + 1)) <= r - l + 1) k++;
        return min(dp[l][k], dp[r - (1 << k) + 1][k]);
    }
}
```

### SAIS

下标从 $0$ 开始，字符串最后填上 `'a' - 1`。

```c++
namespace sa {
    int n, sa[maxn], rk[maxn], h[maxn], s[maxn<<1], t[maxn<<1], p[maxn], cnt[maxn], cur[maxn];
    #define pushS(x) sa[cur[s[x]]--] = x
    #define pushL(x) sa[cur[s[x]]++] = x
    #define inducedSort(v) \
        fill_n(sa, n, -1); fill_n(cnt, m, 0);                                         \
        for (int i = 0; i < n; i++) cnt[s[i]]++;                                      \
        for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];                             \
        for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;                              \
        for (int i = n1 - 1; ~i; i--) pushS(v[i]);                                    \
        for (int i = 1; i < m; i++) cur[i] = cnt[i - 1];                              \
        for (int i = 0; i < n; i++) if (sa[i] > 0 &&  t[sa[i] - 1]) pushL(sa[i] - 1); \
        for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;                              \
        for (int i = n-1;  ~i; i--) if (sa[i] > 0 && !t[sa[i] - 1]) pushS(sa[i] - 1);
    void sais(int n, int m, int *s, int *t, int *p) {
        int n1 = t[n - 1] = 0, ch = rk[0] = -1, *s1 = s + n;
        for (int i = n - 2; ~i; i--) t[i] = s[i] == s[i + 1] ? t[i + 1] : s[i] > s[i + 1];
        for (int i = 1; i < n; i++) rk[i] = t[i - 1] && !t[i] ? (p[n1] = i, n1++) : -1;
        inducedSort(p);
        for (int i = 0, x, y; i < n; i++) if (~(x = rk[sa[i]])) {
            if (ch < 1 || p[x + 1] - p[x] != p[y + 1] - p[y]) ch++;
            else for (int j = p[x], k = p[y]; j <= p[x + 1]; j++, k++)
                if ((s[j] << 1 | t[j]) != (s[k] << 1 | t[k])) {ch++; break;}
            s1[y = x] = ch;
        }
        if (ch + 1 < n1) sais(n1, ch + 1, s1, t + n, p + n1);
        else for (int i = 0; i < n1; i++) sa[s1[i]] = i;
        for (int i = 0; i < n1; i++) s1[i] = p[sa[i]];
        inducedSort(s1);
    }
    template<typename T>
    int mapCharToInt(int n, const T *str) {
        int m = *max_element(str, str + n);
        fill_n(rk, m + 1, 0);
        for (int i = 0; i < n; i++) rk[str[i]] = 1;
        for (int i = 0; i < m; i++) rk[i + 1] += rk[i];
        for (int i = 0; i < n; i++) s[i] = rk[str[i]] - 1;
        return rk[m];
    }
    int dp[maxn][21];
    template<typename T>
    void build(int nn, const T *str) {
        n = nn;
        int m = mapCharToInt(++n, str);
        sais(n, m, s, t, p);
        for (int i = 0; i < n; i++) rk[sa[i]] = i;
        for (int i = 0, k = 0; i < n; i++) {
            if (k) k--;
            int j = sa[rk[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            h[rk[i]] = k;
        }
        for (int i = 1; i <= n; i++) dp[i][0] = h[i];
        for (int j = 1; j < 21; j++) {
            for (int i = 1; i + (1 << j) <= n + 1; i++) {
                dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int qlcp(int l, int r) {
        if (l == r) return n - l + 1;
        l = rk[l]; r = rk[r];
        if (l > r) swap(l, r);
        l++; int k = __lg(r - l + 1);
        return min(dp[l][k], dp[r - (1 << k) + 1][k]);
    }
};
```

### 一个串的经典问题

#### 本质不同子串个数

${n(n+1) \over 2}-\sum_{i=2}^n height[i]$。

#### 可重叠的最长重复子串

$height$ 数组最大值。

#### 不可重叠的最长重复子串

二分答案。

当前二分到 $mid$, 将 $height$ 数组中连续大于等于 $mid$ 的位置划分进一块，一个块内求出现位置的最大值和最小值，如果相差大于等于 $mid$，即代表出现了一段不重叠的重复子串。

```c++
int check(int len) {
    int mx = sa[1], mn = sa[1];
    for (int i = 2; i <= n; i++) {
        if (h[i] >= len) {
            mn = min(mn, sa[i]);
            mx = max(mx, sa[i]);
            if (mx - mn >= len) return 1;
        } else mx = sa[i], mn = sa[i];
    }
    return 0;
}
```

#### 循环节最多的子串

枚举循环节大小 $len$，求 $s[1],s[1+len], s[1+2\cdot len], \dots$，相邻两个的 $LCP$，设 $LCP$ 为 $x$，则循环节个数至少为 ${x \over len} + 1$，再特判一下剩余的 $len - x \bmod len$ 个字符，将 $s[1+k\cdot len]$ 向前推这么多能否构成一个更多的循环节。

### 两个串的经典问题

#### 最长公共子串

将两个串用一个小字符连起来，建一个后缀数组。

$ans=max(height[i])$，满足 $sa[i]$ 和 $sa[i-1]$ 不在同一个串内。

### 多个串的经典问题

将多个串用不同的未出现字符连成一个（注意值域大小）。

#### 出现在至少 $k$ 个串中的最长子串

二分答案，对 $height$ 分块，判断一个块内是否出现 $k$ 次。

## AC 自动机

```c++
namespace acam {
    static const int maxp = 100000 + 5;
    int sz, ch[maxp][26], fail[maxp];
    int match[maxp], val[maxp];
    int node() {
        ms(ch[++sz], 0); fail[sz] = 0; val[sz] = 0;
        return sz;
    }
    void clear() {
        sz = 0; node();
        for (int i = 0; i < 26; i++) ch[0][i] = 1;
    }
    int insert(char* s, int i) {
        int u = 1;
        for (int i = 0; s[i]; i++) {
            int v = s[i] - 'a';
            if (!ch[u][v]) ch[u][v] = node();
            u = ch[u][v];
        }
        val[u]++; match[i] = u;
        return u;
    }
    void build() {
        queue<int> q; q.push(1);
        while (!q.empty()) {
            int t = q.front(); q.pop();
            for (int i = 0; i < 26; i++) {
                if (ch[t][i]) {
                    fail[ch[t][i]] = ch[fail[t]][i];
                    q.push(ch[t][i]);
                } else {
                    ch[t][i] = ch[fail[t]][i];
                }
            }
        }
    }
}
```


### 注意

+ $1$ 号结点为空结点。
+ 字母大小写和字母值域。

### 定义

+ fail 指针: 当前结点对应串的最长后缀，使得他也是 Trie 树上的结点，类似于 KMP。

+ Trie 图: 建完 AC 自动机后，Trie 树变成了 Trie 图，Trie 树上不存在的出边补成 fail 指针指向结点的对应出边。

### 危险结点

串的终止结点是危险结点，fail 指向危险结点的是危险结点。

```c++
int node() {
    ms(ch[++sz], 0); 
    fail[sz] = 0; danger[sz] = 0;
    return sz;
}
void build() {
    queue<int> q; q.push(1);
    while (!q.empty()) {
        int t = q.front(); q.pop();
        for (int i = 0; i < 2; i++) {
            if (ch[t][i]) {
                fail[ch[t][i]] = ch[fail[t]][i];
                danger[ch[t][i]] |= danger[fail[ch[t][i]]];
                // pushdown danger
                q.push(ch[t][i]);
            } else {
                ch[t][i] = ch[fail[t]][i];
            }
        }
    }
}
```

### 求所有模式串出现次数

类似于 KMP，在 Trie 上的每个点打标记，然后将标记从底往上传递，其实就是将 fail 树建初来，求子树大小。

也可以对 fail 树跑拓扑排序。

```c++
vector<int> edge[maxp];
int siz[maxp];
void dfs(int u) {
    for (int& v: edge[u]) {
        dfs(v); siz[u] += siz[v];
    }
}
vector<int> query(int n, char* s) {
    // n: 文本串个数, s: 询问串
    for (int i = 0; i <= sz; i++) edge[i].clear(), siz[i] = 0;
    int now = 1;
    for (int i = 0; s[i]; i++) {
        now = ch[now][s[i] - 'a'];
        siz[now]++;
    }
    for (int i = 2; i <= sz; i++) edge[fail[i]].push_back(i);
    dfs(1);
    vector<int> ans(1, 0);
    for (int i = 1; i <= n; i++) ans.push_back(siz[match[i]]);
    return ans;
}
```

### 询问串包含另一个串的个数

枚举第一个串的每个前缀，即跳 Trie 上的父亲，再每次跳 fail 指针，看能否跳到另外一个结点上。

### AC 自动机上 DP

令 $dp[i][j]$ 表示询问串长度为 $i$，处于结点 $j$ 的不包含任何一个 Trie 树结点的情况数。

枚举长度，再枚举每个状态 $j$ 的儿子 $v$，且 $ch[j][v]$ 不是危险结点，因为到该状态不包含任何一个模板串，加入一个新的字母后，只存在当前某个后缀可能会变成模板串，如果该节点是危险结点，意味着他含有一个后缀是模板串，否则不就一定存在模板串，此时有转移方程 $dp[i][ch[j][v]]+=dp[i-1][j]$。

优化：显然每次转移的转移矩阵相同，矩阵快速幂加速。

## 后缀自动机

注意：使用前必须 `clear()`，数组开到串长的两倍。

```c++
namespace sam {
    int tot, last, cnt[maxn << 1];
    int len[maxn << 1], link[maxn << 1], ch[maxn << 1][26];
    void clear() { 
        tot = last = 1; ms(ch[1], 0);
    }
    int insert(int c) {
        int cur = ++tot, p = last; 
        ms(ch[cur], 0);
        len[cur] = len[last] + 1; 
        cnt[cur] = 1;
        for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
        if (!p) link[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) link[cur] = q;
            else {
                int nq = ++tot; 
                len[nq] = len[p] + 1; 
                cnt[nq] = 0;
                link[nq] = link[q]; 
                link[q] = link[cur] = nq;
                memcpy(ch[nq], ch[q], sizeof ch[q]);
                for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
            }
        }
        return last = cur;
    }
    int c[maxn << 1], a[maxn << 1];
    void rsort() {
        for (int i = 1; i <= tot; i++) c[i] = 0;
        for (int i = 1; i <= tot; i++) c[len[i]]++;
        for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
        for (int i = 1; i <= tot; i++) a[c[len[i]]--] = i;
    }
}
```

### 广义后缀自动机

```c++
namespace gsam {
    int tot, last, cnt[maxn << 1];
    int len[maxn << 1], link[maxn << 1], ch[maxn << 1][26];
    int insert(int last, int c) {
        int cur = ++tot, p = last; 
        ms(ch[cur], 0);
        len[cur] = len[last] + 1; 
        cnt[cur] = 1;
        for (; p && !ch[p][c]; p = link[p]) ch[p][c] = cur;
        if (!p) link[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) link[cur] = q;
            else {
                int nq = ++tot; 
                len[nq] = len[p] + 1; 
                cnt[nq] = 0;
                link[nq] = link[q]; 
                link[q] = link[cur] = nq;
                memcpy(ch[nq], ch[q], sizeof ch[q]);
                for (; ch[p][c] == q; p = link[p]) ch[p][c] = nq;
            }
        } 
        return cur;
    }
    namespace Trie {
        int tot, ch[maxn][26], pos[maxn];
        void clear() {
            tot = 1;
        }
        void insert(char* s) {
            int u = 1;
            for (int i = 0; s[i]; i++) {
                int c = s[i] - '0';
                if (!ch[u][c]) {
                    ch[u][c] = ++tot;
                    ms(ch[tot], 0);
                }
                u = ch[u][c];
            }
        }
        void build() {
            queue<int> q; q.push(1);
            pos[1] = 1;
            while (!q.empty()) {
                int u = q.front(); q.pop();
                for (int i = 0; i < 2; i++) {
                    if (!ch[u][i]) continue;
                    int v = ch[u][i];
                    pos[v] = gsam::insert(pos[u], i);
                    q.push(v);
                }
            }
        }
    }
    using Trie::insert;
    using Trie::build;
    void clear() { 
        Trie::clear();
        tot = last = 1; ms(ch[1], 0);
    }
}
```

### 不同子串个数

#### 方法一

不同子串数目即 $sam$ 上的不同路径的数目，记忆化搜索。

```c++
ll dfs(int u) {
    if (ans[u] != -1) return ans[u];
    ll x = 1;
    for (int i = 0; i < 26; i++) {
        if (!ch[u][i]) continue;
        x += dfs(ch[u][i]);
    }
    return ans[u] = x;
}

dfs(1);
printf("%lld", ans[1] - 1);
```

#### 方法二

不同子串数目为 $sam$ 上每个 $endpos$ 状态上的子串数目,  即 $\sum_{i = 1}^{tot} len(i)-len(link(i))$。

```c++
ll cal(){  
  ll ans = 0;
  for (int i = 1; i <= tot; i++) ans += len[i] - len[link[i]];
  return ans;
}
```

##### 增量维护前缀不同子串数

参考 [HDu4622](http://acm.hdu.edu.cn/viewcode.php?rid=26316331) 和 [SDOI2016 生成魔咒](https://www.luogu.org/problemnew/show/P4070)。

```c++
ll insert(int c) {
    // ...
    return cnt = cnt + len[cur] - len[link[cur]];
}
```

### 子串出现次数

按长度对状态基数排序可以得到 $sam$ 的拓扑排序序列。

```c++
int c[maxn], a[maxn];
void rsort() {
    for (int i = 1; i <= tot; i++) c[i] = 0;
    for (int i = 1; i <= tot; i++) c[len[i]]++;
    for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
    for (int i = 1; i <= tot; i++) a[c[len[i]]--] = i;
    for (int i = tot; i; i--) {
        int p = a[i];
        cnt[link[p]] += cnt[p];
    }
}
```

### 最长公共子串

对第一个串建立一个 $sam$ ，维护第二个串的每一个前缀的最长公共子串，即每一个前缀在前一个串中出现过的最长后缀。

```c++
int ans = 0, now = 1, l = 0;
for (int i = 0; s[i]; i++) {
    if (ch[now][s[i] - 'a']) l++, now = ch[now][s[i] - 'a'];
    else {
        while (now && !ch[now][s[i] - 'a']) now = link[now];
        if (!now) now = 1, l = 0;
        else l = len[now] + 1, now = ch[now][s[i] - 'a'];
    }
}
printf("%d", ans);
```

### 多个串的最长公共子串

```c++
for (int i = 1; i <= tot; i++) ans[i] = len[i];
while (scanf("%s", s + 1) == 1) {
    ms(dep, 0);
    int u = 1, l = 0;
    for (int i = 1; s[i]; i++) {
        int c = s[i] - 'a';
        if (ch[u][c]) u = ch[u][c], l++;
        else {
            while (u && !ch[u][c]) u = link[u];
            if (!u) u = 1, l = 0;
            else l = len[u] + 1, u = ch[u][c];
        }
        dep[u] = max(dep[u], l);
    }
    for (int i = tot; i >= 1; i--) {
        int u = sam::a[i];
        dep[link[u]] = max(dep[u], dep[link[u]]);
    }
    for (int i = tot; i >= 1; i--) ans[i] = min(ans[i], dep[i]);
}
int res = 0;
for (int i = 1; i <= tot; i++) res = max(res, ans[i]);
printf("%d", res);
```


### 字典序第 $k$ 大子串

$t=0$，重复子串只算一个；$t=1$，重复子串算多个。

```c++
void rsort(int t) {
    for (int i = 1; i <= sz; i++) c[len[i]]++;
    for (int i = 1; i <= sz; i++) c[i] += c[i - 1];
    for (int i = 1; i <= sz; i++) a[c[len[i]]--] = i;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        if (t) cnt[link[p]] += cnt[p];
        else cnt[p] = 1;
    }
    cnt[1] = 0;
    for (int i = sz; i >= 1; i--) {
        int p = a[i];
        sum[p] = cnt[p];
        for (int j = 0; j < 26; j++) {
            if (ch[p][j])
                sum[p] += sum[ch[p][j]];
        }
    }
}
string query(int k) {
    if (k > sum[1]) return string("-1");
    int u = 1; string ans; k -= cnt[1];
    while (k > 0) {
        int c = 0;
        while (k > sum[ch[u][c]]) {
            k -= sum[ch[u][c]]; c++;
        }
        u = ch[u][c]; ans += ('a' + c); k -= cnt[u];
    }
    return ans;
}
```

### 线段树合并

[Codeforces666E Forensic Examination](https://codeforces.com/contest/666/problem/E)

```c++
namespace SegTrees {
    const int maxm = maxn * 32;
    int tot, root[maxn << 1], ls[maxm], rs[maxm];
    PII val[maxm];
    PII cal(PII a, PII b) {
        if (a.first > b.first) return a;
        else if (a.first == b.first && a.second < b.second) return a;
        else return b;
    }
    void update(int i, int l, int r, int& rt) {
        if (!rt) rt = ++tot;
        if (l == r) {
            val[rt].first++;
            val[rt].second = i;
            return ;
        }
        int m = (l + r) / 2;
        if (i <= m) update(i, l, m, ls[rt]);
        else update(i, m + 1, r, rs[rt]);
        val[rt] = cal(val[ls[rt]], val[rs[rt]]);
    }
    int join(int x, int y, int l, int r) {
        if (!x || !y) return x + y;
        int u = ++tot;
        if (l == r) {
            val[u].first = val[x].first + val[y].first;
            val[u].second = l;
        } else {
            int m = (l + r) / 2;
            ls[u] = join(ls[x], ls[y], l, m);
            rs[u] = join(rs[x], rs[y], m + 1, r);
            val[u] = cal(val[ls[u]], val[rs[u]]);
        }
        return u;
    }
    PII query(int L, int R, int l, int r, int rt) {
        if (!rt) return { -1, inf };
        if (L <= l && r <= R) return val[rt];
        int m = (l + r) / 2;
        if (R <= m) return query(L, R, l, m, ls[rt]);
        else if (L > m) return query(L, R, m + 1, r, rs[rt]);
        else return cal(query(L, R, l, m, ls[rt]), query(L, R, m + 1, r, rs[rt]));
    }
}
```

### 获取子串结点

```c++
int fa[maxn << 1][21];
struct Edge {
    int to, nxt;
} e[maxn << 1];
int ecnt, head[maxn << 1];
void adde(int u, int v) {
    e[++ecnt] = { v, head[u] };
    head[u] = ecnt;
}
void dfs(int u, int f) {
    fa[u][0] = f;
    for (int i = 1; i < 21; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        dfs(v, u);
    }
}
void build() {
    ecnt = 0;
    for (int i = 0; i <= tot; i++) head[i] = 0;
    for (int i = 2; i <= tot; i++) adde(link[i], i);
    dfs(1, 0);
}

int get(int u, int l) { // u: s[1...r], l: r - l + 1
    for (int i = 20; i >= 0; i--) {
        if (!fa[u][i]) continue;
        int v = fa[u][i];
        if (sam::len[v] >= l) u = v;
    }
    return u;
}
```

## Manacher

下标从 $1$ 开始。

```c++
namespace manacher {
    char s[maxn << 1] = "##";
    int n, hw[maxn << 1];
    void manacher() {
        int maxr = 0, m = 0;
        for (int i = 1; i < n; i++) {
            if (i < maxr) hw[i] = min(hw[m * 2 - i], hw[m] + m - i);
            else hw[i] = 1;
            while (s[i + hw[i]] == s[i - hw[i]]) hw[i]++;
            if (hw[i] + i > maxr) {
                m = i; maxr = hw[i] + i;
            }
        }
    }
    void build(char a[]) {
        int i;
        for (i = 1; a[i]; i++) {
            s[i * 2] = a[i];
            s[i * 2 + 1] = '#';
        }
        n = i * 2; s[n] = 0;
        manacher();
    }
    int check(int l, int r) {
        // s[l...r] 是否为回文串
        int mid = (l + r);
        if (hw[mid] >= mid - 2 * l + 1) return 1;
        else return 0;
    }
}
```

## 回文树

```c++
namespace pam {
    int sz, tot, last;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l; fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last = 0;
        s[tot = 0] = '$';
        node(0); node(-1);
        fail[0] = 1;
    }
    int getfail(int x) {
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void insert(char c) {
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }
    void count() {
        for (int i = sz; i >= 0; i--) {
            cnt[fail[i]] += cnt[i];
        }
    }
}
```

### half 指针

```c++
void insert(char c) {
    s[++tot] = c;
    int now = getfail(last);
    if (!ch[now][c - 'a']) {
        int x = node(len[now] + 2);
        fail[x] = ch[getfail(fail[now])][c - 'a'];
        dep[x] = dep[fail[x]] + 1;
        ch[now][c - 'a'] = x;

        if (len[x] == 1) half[x] = 1;
        else {
            int pos = half[now];
            while (s[tot - len[pos] - 1] != s[tot] || (2 + len[pos]) * 2 > len[x]) pos = fail[pos];
            half[x] = ch[pos][c - 'a'];
        }
        val[x] = 1;
        if (len[x] / 2 == len[half[x]]) val[x] += val[half[x]];
    }
    last = ch[now][c - 'a'];
    cnt[last]++;
}
```

### 双向加字符

```c++
namespace pam {
    // last1: right, last2: left
    int sz, last1, last2, l, r;
    int ch[maxn][26], len[maxn], fail[maxn];
    int cnt[maxn], dep[maxn];
    char s[maxn];
    int node(int l) {
        sz++; ms(ch[sz], 0);
        len[sz] = l;
        fail[sz] = cnt[sz] = dep[sz] = 0;
        return sz;
    }
    void clear() {
        sz = -1; last1 = last2 = 0;
        l = 100002; r = l - 1;
        node(0); node(-1);
        fail[0] = 1;
        ms(s, -1);
    }
    int getfail1(int x) {
        while (s[r - len[x] - 1] != s[r]) x = fail[x];
        return x;
    }
    int getfail2(int x) {
        while (s[l + len[x] + 1] != s[l]) x = fail[x];
        return x;
    }
    int insertR(char c) {
        s[++r] = c;
        int now = getfail1(last1);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail1(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last1 = ch[now][c - 'a'];
        cnt[last1]++;
        if (len[last1] == r - l + 1) last2 = last1;
        return dep[last1];
    }
    int insertL(char c) {
        s[--l] = c;
        int now = getfail2(last2);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail2(fail[now])][c - 'a'];
            dep[x] = dep[fail[x]] + 1;
            ch[now][c - 'a'] = x;
        }
        last2 = ch[now][c - 'a'];
        cnt[last2]++;
        if (len[last2] == r - l + 1) last1 = last2;
        return dep[last2];
    }
}
```

## 最小表示法

```c++
int getmin(char* s) {
    int n = strlen(s), i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n) {
        int t = s[(i + k) % n] - s[(j + k) % n];
        if (!t) k++;
        else {
            if (t > 0) i += k + 1;
            else j += k + 1;
            if (i == j) j++;
            k = 0;
        }
    }
    return min(i, j) + 1;
}
```