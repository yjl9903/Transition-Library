# 数据结构

[TOC]

## 线段树

```c++
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
const int maxn = 100000 + 5;

int sum[maxn << 2], add[maxn << 2], a[maxn], n;
void pushup(int rt) {sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];}
void pushdown(int rt, int ln, int rn) {
    if (add[rt]) {
        add[rt << 1] += add[rt]; add[rt << 1 | 1] += add[rt];
        sum[rt << 1] = add[rt] * ln; sum[rt << 1 | 1] = add[rt] * rn;
        add[rt] = 0;
    }
}
void build(int l, int r, int rt) {
    if (l == r) {
        sum[rt] = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(lson); build(rson);
    pushup(rt);
}
void update(int i, int x, int l, int r, int rt) {
    if (l == r) {
        sum[rt] += x;
        return;
    }
    int m = (l + r) >> 1;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    pushup(rt);
}
void update(int L, int R, int x, int l, int r, int rt) {
    if (L <= l && r <= R) {
        sum[rt] += x * (r - l + 1);
        add[rt] += x;
        return;
    }
    int m = (l + r) >> 1;
    pushdown(rt, m - l + 1, r - m);
    if (L <= m) update(L, R, x, lson);
    if (R > m) update(L, R, x, rson);
    pushup(rt);
}
int query(int i, int l, int r, int rt) {
    if (l == r) {
        return sum[rt];
    }
    int m = (l + r) >> 1;
    if (i <= l) return query(i, lson);
    return query(i, rson);
}
int query(int L, int R, int l, int r, int rt) {
    if (L <= l && r <= R) {
        return sum[rt];
    }
    int m = (l + r) >> 1;
    pushdown(rt, m - l + 1, r - m);
    int ans = 0;
    if (L <= m) ans += query(L, R, lson);
    if (R > m) ans += query(L, R, rson);
    return ans;
}
```

### 区间加乘双标记

```c++
int n, m, p;
ll a[maxn], sum[maxn << 2], add[maxn << 2], mul[maxn << 2];

void pushup(int rt) { sum[rt] = (sum[rt << 1] + sum[rt << 1 | 1]) % p; }
void pushdown(int rt, int ln, int rn) {
    int ls = rt << 1, rs = rt << 1 | 1;
    // 注意优先级高的乘法标记下放！
    if (mul[rt] != 1) {
        mul[ls] *= mul[rt]; mul[rs] *= mul[rt];
        add[ls] *= mul[rt]; add[rs] *= mul[rt];
        sum[ls] *= mul[rt]; sum[rs] *= mul[rt];
        mul[rt] = 1;
    }
    if (add[rt] != 0) {
        add[ls] += add[rt]; add[rs] += add[rt];
        sum[ls] += add[rt] * ln; sum[rs] += add[rt] * rn;
        add[rt] = 0;
    }
}
void build(int l, int r, int rt) {
    mul[rt] = 1;
    if (l == r) {
        sum[rt] = a[l] % p; return;
    }
    int m = l + r >> 1;
    build(lson); build(rson);
    pushup(rt);
}
void update1(int L, int R, int x, int l, int r, int rt) {
    if (L <= l && r <= R) {
        sum[rt] *= x;
        mul[rt] *= x;
        add[rt] *= x;
        return;
    }
    int m = l + r >> 1; pushdown(rt, m - l + 1, r - m);
    if (L <= m) update1(L, R, x, lson);
    if (R > m) update1(L, R, x, rson);
    pushup(rt);
}
void update2(int L, int R, int x, int l, int r, int rt) {
    if (L <= l && r <= R) {
        sum[rt] += x * (r - l + 1);
        add[rt] += x;
        return;
    }
    int m = l + r >> 1; pushdown(rt, m - l + 1, r - m);
    if (L <= m) update2(L, R, x, lson);
    if (R > m) update2(L, R, x, rson);
    pushup(rt);
}
```

### 区间取模

```c++
int n, m, a[maxn], mx[maxn << 2];;
ll sum[maxn << 2];

void pushup(int rt) {
    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    mx[rt] = max(mx[rt << 1], mx[rt << 1 | 1]);
}
void build(int l, int r, int rt) {
    if (l == r) {
        sum[rt] = mx[rt] = a[l]; return;
    }
    int m = l + r >> 1;
    build(lson); build(rson);
    pushup(rt);
}
void update(int i, int x, int l, int r, int rt) {
    if (l == r) {
        sum[rt] = mx[rt] = x; return;
    }
    int m = l + r >> 1;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    pushup(rt);
}
void update(int L, int R, int mod, int l, int r, int rt) {
    if (L > r || l > R || mx[rt] < mod) return; // 剪枝
    if (L <= l && r <= R && l == r) {
        sum[rt] = mx[rt] = mx[rt] % mod;
        return;
    }
    int m = l + r >> 1;
    update(L, R, mod, lson); update(L, R, mod, rson);
    pushup(rt);
}
```

### 区间最值覆盖

对于一类区间最值更新问题，我们可以维护最大值，最大值个数和次大值。

对于最小值更新 x：

1. $max[l \dots r] \le x$ ：无需更新
2. $ secondMax[l \dots r] < x < max[l \dots r]$ ：将 $max[l \dots r]$ 覆盖为 x，打标记。
3. $secondMax[l \dots r] \ge x$：暴力递归。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ms(a,b) memset(a,b,sizeof(a))
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
using namespace std;
typedef long long ll;
const int maxn = 1000000 + 5;

int n, m, a[maxn], mx[maxn << 2], cnt[maxn << 2], se[maxn << 2], add[maxn << 2];
ll sum[maxn << 2];

void pushup(int rt){
    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    if (mx[rt << 1] == mx[rt << 1 | 1]){
        se[rt] = max(se[rt << 1], se[rt << 1 | 1]);
        mx[rt] = mx[rt << 1];
        cnt[rt] = cnt[rt << 1] + cnt[rt << 1 | 1];
    }
    else if (mx[rt << 1] < mx[rt << 1 | 1]){
        se[rt] = max(mx[rt << 1], se[rt << 1 | 1]);
        mx[rt] = mx[rt << 1 | 1];
        cnt[rt] = cnt[rt << 1 | 1];
    }
    else {
        se[rt] = max(mx[rt << 1 | 1], se[rt << 1]);
        mx[rt] = mx[rt << 1];
        cnt[rt] = cnt[rt << 1];
    }
}
void pushdown(int rt){
    if (add[rt] == -1) return;
    // 区间覆盖
    int& t = add[rt]; int ls = rt << 1, rs = rt << 1 | 1;
    if (mx[ls] > t && t > se[ls]) {
        sum[ls] -= 1ll * (mx[ls] - t) * cnt[ls];
        add[ls] = mx[ls] = t;
    }
    if (mx[rs] > t && t > se[rs]){
        sum[rs] -= 1ll * (mx[rs] - t) * cnt[rs];
        add[rs] = mx[rs] = t;
    }
    t = -1;
}
void build(int l, int r, int rt){
    add[rt] = -1;
    if (l == r){
        se[rt] = -1; cnt[rt] = 1;
        sum[rt] = mx[rt] = a[l];
        return;
    }
    int m = l + r >> 1;
    build(lson); build(rson);
    pushup(rt);
}
void update(int L, int R, int t, int l, int r, int rt){
    if (mx[rt] <= t) return;
    if (L <= l && r <= R && se[rt] < t){
        sum[rt] -= 1ll * (mx[rt] - t) * cnt[rt];
        mx[rt] = add[rt] = t;
        return;
    }
    int m = l + r >> 1;
    pushdown(rt);
    if (L <= m) update(L, R, t, lson);
    if (R > m) update(L, R, t, rson);
    pushup(rt);
}
int qmax(int L, int R, int l, int r, int rt){
    if (L <= l && r <= R) return mx[rt];
    int m = l + r >> 1; int ans = 0;
    pushdown(rt);
    if (L <= m) ans = max(ans, qmax(L, R, lson));
    if (R > m) ans = max(ans, qmax(L, R, rson));
    return ans;
}
ll qsum(int L, int R, int l, int r, int rt){
    if (L <= l && r <= R) return sum[rt];
    int m = l + r >> 1; ll ans = 0;
    pushdown(rt);
    if (L <= m) ans += qsum(L, R, lson);
    if (R > m) ans += qsum(L, R, rson);
    return ans;
}

int main(){
    int T; scanf("%d", &T);
    while (T--){
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i++) scanf("%d", a + i);
        build(1, n, 1); int op, x, y, t;
        while (m--){
            scanf("%d", &op);
            if (op == 0){
                scanf("%d%d%d", &x, &y, &t);
                update(x, y, t, 1, n, 1);
            }
            if (op == 1){
                scanf("%d%d", &x, &y);
                printf("%d\n", qmax(x, y, 1, n, 1));
            }
            if (op == 2){
                scanf("%d%d", &x, &y);
                printf("%lld\n", qsum(x, y, 1, n, 1));
            }
        }
    }
    return 0;
}
```

### 线段树合并

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
typedef long long ll;
const int maxn = 100000 + 5;

int n, ans[maxn], fa[maxn], a[maxn];

vector<int> fac[maxn];
int ls[maxn * 800] = {0}, rs[maxn * 800] = {0};
int root[maxn], tot = 0, f;

void update(int k, int l, int r, int& rt){
    if (!rt) rt = ++tot;
    if (l == r) return;
    int m = (l + r) >> 1;
    if (k <= m) update(k, l, m, ls[rt]);
    else update(k, m + 1, r, rs[rt]);
}
int join(int pre, int l, int r, int rt){
    if (!pre || !rt) return pre ^ rt;
    if (l == r) { ans[f] = max(ans[f], l); return rt;}
    int m = (l + r) >> 1;
    ls[rt] = join(ls[pre], l, m, ls[rt]);
    rs[rt] = join(rs[pre], m + 1, r, rs[rt]);
    return rt;
}

int main(){
    for (int i = 1; i < maxn; i++) for (int j = 1; i * j < maxn; j++)
        fac[i * j].push_back(i);
    scanf("%d", &n); ms(ans, -1);
    for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
    for (int x, i = 1; i <= n; i++) {
        scanf("%d", &x); root[i] = ++tot;
        for (int j = 0; j < fac[x].size(); j++)
            update(facx, 1, maxn - 1, root[i]);
    }
    for (int i = n; i >= 1; i--){
        f = fa[i]; root[f] = join(root[i], 1, maxn - 1, root[f]);
    }
    for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
    return 0;
}

```

### 矩形面积并

注意：询问的离线，线段树结点代表的区间。

来源：[2019-2020 ACM-ICPC Brazil Subregional Programming Contest Interplanetary](https://codeforces.com/gym/102346/problem/I)

```c++
const int maxn = 10000 + 5;
const int maxv = 100000 + 5;

int n, p, lx, ly, rx, ry;
int x1[maxn], y1[maxn], x2[maxn], y2[maxn];

struct Node {
    int l, r, pos, sgn;
    bool operator<(const Node& b) const {
        return pos < b.pos;
    }
};

int cnt[maxv << 2], len[maxv << 2];
void upd(int rt, int l, int r) {
    if (cnt[rt]) len[rt] = r - l + 1;
    else if (l < r) len[rt] = len[rt << 1] + len[rt << 1 | 1];
    else len[rt] = 0;
}
void update(int L, int R, int x, int l = 0, int r = 1e5, int rt = 1) {
    if (L <= l && r <= R) {
        cnt[rt] += x; upd(rt, l, r);
        return ;
    }
    int m = (l + r) / 2;
    if (L <= m) update(L, R, x, lson);
    if (R > m) update(L, R, x, rson);
    upd(rt, l, r);
}

int check(int r) {
    ms(cnt, 0); ms(len, 0);
    vector<Node> upd;
    for (int i = 1; i <= n; i++) {
        int L = max(x1[i] - r, lx), R = min(x2[i] + r, rx);
        int D = max(y1[i] - r, ly), U = min(y2[i] + r, ry);
        upd.push_back({L, R, D, 1});
        upd.push_back({L, R, U, -1});
    }
    sort(upd.begin(), upd.end());
    ll ans = 0;
    for (int i = 0; i + 1 < (int)upd.size(); i++) {
        update(upd[i].l + 1, upd[i].r, upd[i].sgn);
        ans += 1ll * len[1] * (upd[i + 1].pos - upd[i].pos);
    }
    return 100ll * ans >= 1ll * p * (rx - lx) * (ry - ly);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d%d%d", x1 + i, y1 + i, x2 + i, y2 + i);
    }
    scanf("%d%d%d%d%d", &p, &lx, &ly, &rx, &ry);
    int l = 1, r = 1e5, ans = r;
    while (l <= r) {
        int m = (l + r) / 2;
        if (check(m)) r = m - 1, ans = m;
        else l = m + 1;
    }
    cout << ans;
    return 0;
}
```

## 主席树

### 区间第k大

```c++
#define lson l, m, ls[rt]
#define rson m + 1, r, rs[rt]

int ls[maxn * 40], rs[maxn * 40], tree[maxn * 40];
int n, q, a[maxn], root[maxn], cnt;
vector<int> h;

void build(int l, int r, int &rt) {
    rt = ++cnt;
    tree[rt] = 0;
    if (l == r)
        return;
    int m = (l + r) >> 1;
    build(l, m, ls[rt]);
    build(m + 1, r, rs[rt]);
}
void update(int p, int x, int pre, int l, int r, int &rt) {
    rt = ++cnt;
    ls[rt] = ls[pre];
    rs[rt] = rs[pre];
    tree[rt] = tree[pre] + x;
    if (l == r)
        return;
    int m = (l + r) >> 1;
    if (p <= m)
        update(p, x, ls[pre], l, m, ls[rt]);
    else
        update(p, x, rs[pre], m + 1, r, rs[rt]);
}
int query(int k, int pre, int l, int r, int rt) {
    if (l == r)
        return l;
    int m = (l + r) >> 1, s = tree[ls[rt]] - tree[ls[pre]];
    if (k <= s)
        return query(k, ls[pre], l, m, ls[rt]);
    else
        return query(k - s, rs[pre], m + 1, r, rs[rt]);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &q);
        h.clear();
        cnt = 0;
        for (int i = 1; i <= n; i++)
            scanf("%d", &a[i]), h.push_back(a[i]);
        sort(h.begin(), h.end());
        vector<int>::iterator it = unique(h.begin(), h.end());
        h.resize(distance(h.begin(), it));
        build(1, h.size(), root[0]);
        for (int i = 1; i <= n; i++)
            a[i] = lower_bound(h.begin(), h.end(), a[i]) - h.begin() + 1;
        for (int i = 1; i <= n; i++)
            update(a[i], 1, root[i - 1], 1, h.size(), root[i]);
        while (q--) {
            int x, y, k;
            scanf("%d%d%d", &x, &y, &k);
            printf("%d\n", h[query(k, root[x - 1], 1, h.size(), root[y]) - 1]);
        }
    }
    return 0;
}
```

### 区间不同数

```c++
int n, q, cnt = 0, a[maxn];
int vis[inf] = {0}, root[maxn], tree[maxn * 40], ls[maxn * 40], rs[maxn * 40];

void build(int l, int r, int& rt) {
    rt = ++cnt;
    if (l == r) {
        tree[rt] = 0; return;
    }
    int m = (l + r) >> 1;
    build(lson); build(rson);
}
void update(int i, int x, int pre, int l, int r, int& rt) {
    rt = ++cnt; ls[rt] = ls[pre]; rs[rt] = rs[pre]; tree[rt] = tree[pre] + x;
    if (l == r) {
        return;
    }
    int m = (l + r) >> 1;
    if (i <= m) update(i, x, ls[pre], lson);
    else update(i, x, rs[pre], rson);
}
int query(int i, int l, int r, int rt) {
    if (l == i) return tree[rt];
    int m = (l + r) >> 1;
    if (i <= m) return query(i, lson) + tree[rs[rt]];
    else return query(i, rson);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    scanf("%d", &q);
    build(1, n, root[0]);
    for (int i = 1; i <= n; i++) {
        if (vis[a[i]]) {
            int tmp;
            update(vis[a[i]], -1, root[i - 1], 1, n, tmp);
            update(i, 1, tmp, 1, n, root[i]);
        }
        else {
            update(i, 1, root[i - 1], 1, n, root[i]);
        }
        vis[a[i]] = i;
    }

    int x, y;
    while (q--) {
        scanf("%d%d", &x, &y);
        printf("%d\n", query(x, 1, n, root[y]));
    }
    return 0;
}
```

### 动态主席树

单点修改，垃圾回收，询问区间前 $k$ 大的前缀和。

```c++
namespace PSegT {
  #define lson l, m, ls[rt]
  #define rson m + 1, r, rs[rt]
  int tot, root[maxn], ls[maxn * 150], rs[maxn * 150];
  ll cnt[maxn * 150];

  vector<int> nodes;
  int node() {
    if (nodes.empty()) return ++tot;
    int r = nodes.back(); nodes.pop_back();
    return r;
  }
  void del(int& x) {
    ls[x] = rs[x] = cnt[x] = 0;
    nodes.push_back(x); x = 0;
  }
  
  void update(int i, int x, int l, int r, int& rt) {
    if (!rt) rt = node();
    cnt[rt] += x;
    if (l == r) {
      if (!cnt[rt]) del(rt), rt = 0;
      return ;
    }
    int m = (l + r) / 2;
    if (i <= m) update(i, x, lson);
    else update(i, x, rson);
    if (!cnt[rt]) del(rt), rt = 0;
  }

  vector<int> L, R;
  ll query(int i, int l, int r, int rt) {
    if (l == r) {
      ll sum = 0;
      for (int x: L) sum -= cnt[x];
      for (int x: R) sum += cnt[x];
      return sum;
    }
    int m = (l + r) / 2;
    if (i <= m) {
      for (int& x: L) x = ls[x];
      for (int& x: R) x = ls[x];
      return query(i, l, m, 1);
    } else {
      ll sum = 0;
      for (int& x: L) sum -= cnt[ls[x]], x = rs[x];
      for (int& x: R) sum += cnt[ls[x]], x = rs[x];
      return sum + query(i, m + 1, r, 1);
    }
  }
  inline void update(int i, int pos, int val) {
    for (; i <= n; i += i & -i) update(pos, val, 1, 2e5, root[i]);
  }
  inline ll query(int l, int r, int k) {
    L.clear(); R.clear();
    for (int i = l - 1; i; i -= i & -i) L.push_back(root[i]);
    for (int i = r; i; i -= i & -i) R.push_back(root[i]);
    return query(k, 1, 2e5, 1);
  }
}
```

## 树状数组

### 区间加减 区间查询

```c++
ll c[maxn], s[maxn];
inline int lowbit(int i) { return i & -i; }
inline void update(int i, int x) {
    ll y = 1ll * i * x;
    for (; i < maxn; i += lowbit(i)) {
        c[i] += x; s[i] += y;
    }
}
inline void update(int l, int r, int x) {
    update(l, x); update(r + 1, -x);
}
inline ll query(ll* a, int i) {
    ll r = 0;
    for (; i; i -= lowbit(i)) r += a[i];
    return r;
}
inline ll query(int l, int r) {
    return (r - l + 1) * query(c, l - 1) + (r + 1) * (query(c, r) - query(c, l - 1)) 
            - query(s, r) + query(s, l - 1);
}
```

### 二分第 $k$ 大

```c++
struct BIT {
    static const int R = 1 << 21;
    int a[R];
    inline int lowbit(int x) { return x & -x; }
    void insert(int i) {
        for (; i < R; i += lowbit(i)) a[i]++;
    }
    int findx(int p, int rk) {
        // if (p > R) return -1;
        if (p & 1) {
            // if (p + (a[p] < rk) > R) return -1;
            return p + (a[p] < rk);
        } else {
            if (rk > a[p]) return findx(p + lowbit(p) / 2, rk - a[p]);
            else return findx(p - lowbit(p) / 2, rk);
        }
    }
    int findx(int rk) {
        return findx(R >> 1, rk);
    }
} f;
```

## Splay

```c++
struct Splay{
    int f[maxn], ch[maxn][2], key[maxn], cnt[maxn], size[maxn], sz = 0, root = 0;
    Splay() {sz = root = 0;}
    void clean(int x) {
        ch[x][0] = ch[x][1] = f[x] = key[x] = cnt[x] = size[x] = 0;
    }
    int get(int x) {
        return ch[f[x]][1] == x;
    }
    void update(int x) {
        if (!x) return;
        size[x] = cnt[x];
        if (ch[x][0]) size[x] += size[ch[x][0]];
        if (ch[x][1]) size[x] += size[ch[x][1]];
    }
    void rot(int x) {
        int old = f[x], oldf = f[old], tp = get(x);
        ch[old][tp] = ch[x][tp ^ 1]; f[ch[old][tp]] = old;
        f[old] = x; ch[x][tp ^ 1] = old;
        f[x] = oldf;
        if (oldf) ch[oldf][ch[oldf][1] == old] = x;
        update(old); update(x);
    }
    void splay(int x) {
        for (int fa; fa = f[x]; rot(x))
            if (f[fa]) rot(get(x) == get(fa) ? fa : x);
        root = x;
    }
    int insert(int v) {
        if (root == 0) {
            sz++; ch[sz][0] = ch[sz][1] = f[sz] = 0;
            key[sz] = v; cnt[sz] = 1; size[sz] = 1;
            root = sz;
            return 1;
        }
        int tot = root, fa = 0;
        while (1) {
            if (key[tot] == v) {
                cnt[tot]++; update(tot); update(fa);
                splay(tot);
                return cnt[tot];
            }
            fa = tot;
            tot = ch[tot][v > key[tot]];
            if (tot == 0) {
                sz++; ch[sz][0] = ch[sz][1] = 0;
                key[sz] = v; cnt[sz] = size[sz] = 1;
                f[sz] = fa; ch[fa][v > key[fa]] = sz;
                update(fa); splay(sz);
                break;
            }
        }
        return 1;
    }
    int find(int v) {
        int ans = 0, tot = root;
        while (1) {
            if (v < key[tot]) tot = ch[tot][0];
            else {
                ans += (ch[tot][0] ? size[ch[tot][0]] : 0);
                if (v == key[tot]) {
                    splay(tot); return ans + 1;
                }
                ans += cnt[tot];
                tot = ch[tot][1];
            }
        }
        return 0;
    }
    int findx(int x) {
        int tot = root;
        while (1) {
            if (ch[tot][0] && x <= size[ch[tot][0]]) tot = ch[tot][0];
            else {
                int t = (ch[tot][0] ? size[ch[tot][0]] : 0) + cnt[tot];
                if (x <= t) return key[tot];
                x -= t; tot = ch[tot][1];
            }
        }
        return -1;
    }
    int prev() {
        int tot = ch[root][0];
        while (ch[tot][1]) tot = ch[tot][1];
        return tot;
    }
    int succ() {
        int tot = ch[root][1];
        while (ch[tot][0]) tot = ch[tot][0];
        return tot;
    }
    void del(int v) {
        find(v);
        if (cnt[root] > 1) {
            cnt[root]--; return;
        }
        if (!ch[root][0] && !ch[root][1]) {
            clean(root); root = 0; return;
        }
        if (!ch[root][0]) {
            int old = root; root = ch[root][1]; f[root] = 0;
            clean(old); return;
        }
        else if (!ch[root][1]) {
            int old = root; root = ch[root][0]; f[root] = 0;
            clean(old); return;
        }
        int lf = prev(), old = root;
        splay(lf); f[ch[old][1]] = root; ch[root][1] = ch[old][1];
        clean(old); update(root);
    }
};
```

### 区间操作

```c++
int a[maxn];
struct Splay{
    int f[maxn], ch[maxn][2], size[maxn], rev[maxn] = {0}, key[maxn], root, sz;
    Splay() {
        root = sz = size[0] = rev[0] = f[0] = 0; key[0] = inf;
    }
    int get(int x) {return ch[f[x]][1] == x;}
    void pushup(int x) {
        size[x] = size[ch[x][0]] + size[ch[x][1]] + 1;
    }
    void pushdown(int x) {
        if (!rev[x]) return;
        std::swap(ch[x][0], ch[x][1]);
        rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1; rev[x] = 0;
    }
    int build(int l, int r, int rt) {
        if (l > r) return 0;
        int m = (l + r) >> 1, tot = ++sz;
        key[tot] = a[m]; f[tot] = rt; rev[tot] = 0;
        ch[tot][0] = build(l, m - 1, tot);
        ch[tot][1] = build(m + 1, r, tot);
        pushup(tot);
        return tot;
    }
    void rot(int x) {
        int old = f[x], oldf = f[old], tp = get(x);
        pushdown(old); pushdown(x);
        ch[old][tp] = ch[x][tp ^ 1]; f[ch[old][tp]] = old;
        ch[x][tp ^ 1] = old; f[old] = x;
        f[x] = oldf;
        if (oldf) ch[oldf][ch[oldf][1] == old] = x;
        pushup(old); pushup(x);
    }
    void splay(int x, int tar) {
        for (int fa; (fa = f[x]) != tar; rot(x))
            if (f[fa] != tar)
                rot(get(fa) == get(x) ? fa : x);
        if (!tar) root = x;
    }
    int find(int k) {
        int tot = root;
        while (1) {
            pushdown(tot);
            if (k <= size[ch[tot][0]]) tot = ch[tot][0];
            else {
                k -= size[ch[tot][0]] + 1;
                if (!k) return tot;
                tot = ch[tot][1];
            }
        }
    }
    void reverse(int l, int r) {
        int a = find(l), b = find(r + 2);
        splay(a, 0); splay(b, a);
        rev[ch[b][0]] ^= 1;
    }
    void print(int p) {
        pushdown(p);
        if (ch[p][0]) print(ch[p][0]);
        if (key[p] != inf) printf("%d ", key[p]);
        if (ch[p][1]) print(ch[p][1]);
    }
}f;

int n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) a[i + 1] = i;
    a[1] = inf; a[n + 2] = inf;
    f.root = f.build(1, n + 2, 0);
    while (m--) {
        int l, r; scanf("%d%d", &l, &r);
        f.reverse(l, r);
    }
    f.print(f.root);
    return 0;
}
```

## Treap

```c++
inline int rand() {
    static int seed = 233;
    return seed = int(seed * 48271LL % 2147483647);
}

struct Treap{
    int ch[maxn][2], key[maxn], size[maxn], rnd[maxn], cnt[maxn], sz, root;
    Treap() {
        root = sz = 0;
    }
    void pushup(int rt) { size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + cnt[rt]; }
    void rot(int& x, int k) {
        int v = ch[x][k ^ 1];
        ch[x][k ^ 1] = ch[v][k];
        ch[v][k] = x;
        x = v;
        pushup(ch[x][k]); pushup(x);
    }
    void insert(int& x, int val) {
        if (!x) {
            x = ++sz;
            ch[x][0] = ch[x][1] = 0;
            key[x] = val; rnd[x] = rand();
            size[x] = cnt[x] = 1;
            return;
        }
        if (key[x] == val) {
            cnt[x]++; pushup(x);
            return;
        }
        int k = val > key[x];
        insert(ch[x][k], val);
        if (rnd[x] < rnd[ch[x][k]]) rot(x, k ^ 1);
        pushup(x);
    }
    void del(int& x, int val) {
        if (!x) return;
        if (key[x] == val) {
            if (cnt[x] > 1) {
                cnt[x]--; pushup(x);
                return;
            }
            if (ch[x][0] || ch[x][1]) {
                if (!ch[x][1] || rnd[ch[x][0]] > rnd[ch[x][1]]) {
                    rot(x, 1); del(ch[x][1], val);
                }
                else {
                    rot(x, 0); del(ch[x][0], val);
                }
                pushup(x);
                return;
            }
            x = 0;
            return;
        }
        del(ch[x][val > key[x]], val);
        pushup(x);
    }
    int find(int x, int val) {
        if (!x) return 0;
        if (val == key[x]) return size[ch[x][0]] + 1;
        else if (val < key[x]) return find(ch[x][0], val);
        else return size[ch[x][0]] + cnt[x] + find(ch[x][1], val);
    }
    int findx(int x, int rank) {
        if (!x) return inf;
        if (rank <= size[ch[x][0]]) return findx(ch[x][0], rank);
        else if (rank <= size[ch[x][0]] + cnt[x]) return key[x];
        else return findx(ch[x][1], rank - size[ch[x][0]] - cnt[x]);
    }
    int prev(int v) {
        int x = root, ans = 0;
        while (x) {
            if (v > key[x]) ans = key[x], x = ch[x][1];
            else x = ch[x][0];
        }
        return ans;
    }
    int succ(int v) {
        int x = root, ans = 0;
        while (x) {
            if (v < key[x]) ans = key[x], x = ch[x][0];
            else x = ch[x][1];
        }
        return ans;
    }
}f;
```

### 无旋Treap

```c++
struct fhqTreap {
    int ch[maxn][2], key[maxn], rnd[maxn], size[maxn], root, tot;
    fhqTreap() { root = tot = 0; }
    void clear() { root = tot = 0; }
    int node(int v) {
        key[++tot] = v; rnd[tot] = rand();
        size[tot] = 1;
        ch[tot][0] = ch[tot][1] = 0;
        return tot;
    }
    void pushup(int x) { size[x] = size[ch[x][0]] + size[ch[x][1]] + 1; }
    void split(int now, int k, int &x, int &y) {
        if (!now) {
            x = y = 0; return;
        }
        if (key[now] <= k) {
            x = now;
            split(ch[now][1], k, ch[now][1], y);
        } else {
            y = now;
            split(ch[now][0], k, x, ch[now][0]);
        }
        pushup(now);
    }
    int merge(int x, int y) {
        if (x == 0 || y == 0) return x + y;
        if (rnd[x] < rnd[y]) {
            ch[x][1] = merge(ch[x][1], y);
            pushup(x); return x;
        } else {
            ch[y][0] = merge(x, ch[y][0]);
            pushup(y); return y;
        }
    }
    void insert(int v) {
        int x = 0, y = 0;
        split(root, v, x, y);
        root = merge(merge(x, node(v)), y);
    }
    void del(int v) {
        int x = 0, y = 0, z = 0;
        split(root, v, x, z);
        split(x, v - 1, x, y);
        y = merge(ch[y][0], ch[y][1]);
        root = merge(merge(x, y), z);
    }
    int find(int v) {
        int x = 0, y = 0;
        split(root, v - 1, x, y);
        int ans = size[x] + 1;
        root = merge(x, y);
        return ans;
    }
    int findx(int now, int rank) {
        while (1) {
            if (size[ch[now][0]] >= rank) now = ch[now][0];
            else if (size[ch[now][0]] + 1 == rank) return key[now];
            else {
                rank -= size[ch[now][0]] + 1;
                now = ch[now][1];
            }
        }
    }
    int prev(int v) {
        int x = 0, y = 0;
        split(root, v - 1, x, y);
        int ans = findx(x, size[x]);
        root = merge(x, y);
        return ans;
    }
    int succ(int v) {
        int x = 0, y = 0;
        split(root, v, x, y);
        int ans = findx(y, 1);
        root = merge(x, y);
        return ans;
    }
} f;
```

### 区间操作

```c++
struct fhqTreap {
    int ch[maxn][2], size[maxn], key[maxn], rnd[maxn], rev[maxn], root, tot;
    fhqTreap() { root = tot = 0; }
    int node(int v, int x) {
        key[++tot] = v; rnd[tot] = rand();
        size[tot] = 1; ch[tot][0] = ch[tot][1] = rev[tot] = 0;
        return tot;
    }
    void pushup(int x) {size[x] = size[ch[x][0]] + size[ch[x][1]] + 1;}
    void pushdown(int x) {
        if (!rev[x]) return;
        swap(ch[x][0], ch[x][1]);
        if (ch[x][0]) rev[ch[x][0]] ^= 1;
        if (ch[x][1]) rev[ch[x][1]] ^= 1;
        rev[x] = 0;
    }
    void split(int now, int k, int &x, int &y) {
        if (!now) {
            x = y = 0; return;
        }
        pushdown(now);
        if (size[ch[now][0]] < k) {
            x = now;
            split(ch[now][1], k - size[ch[now][0]] - 1, ch[now][1], y);
        }
        else {
            y = now;
            split(ch[now][0], k, x, ch[now][0]);
        }
        pushup(now);
    }
    int merge(int x, int y) {
        if (!x || !y) return x + y;
        if (rnd[x] < rnd[y]) {
            pushdown(x);
            ch[x][1] = merge(ch[x][1], y);
            pushup(x); return x;
        }
        else {
            pushdown(y);
            ch[y][0] = merge(x, ch[y][0]);
            pushup(y); return y;
        }
    }
    void reverse(int l, int r) {
        int x, y, z;
        split(root, l - 1, x, y);
        split(y, r - l + 1, y, z);
        rev[y] ^= 1;
        root = merge(x, merge(y, z));
    }
    void print(int x) {
        if (!x) return;
        pushdown(x);
        print(ch[x][0]);
        v.push_back(key[x]);
        print(ch[x][1]);
    }
} f;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) f.root = f.merge(f.root, f.node(i, i));
    while (m--) {
        int l, r; scanf("%d%d", &l, &r);
        f.reverse(l, r);
    }
    f.print(f.root);
    for (int i = 0; i < v.size(); i++) {
        if (i) putchar(' ');
        printf("%d", v[i]);
    }
    return 0;
}
```

## 动态凸包

维护一次函数集合 $\{ f | f(x)=ax+b \}$ 的凸包，询问 $\max f(x)$。

```c++
// Thanks for teapotd: https://codeforces.com/contest/1303/submission/70887832
// MAX of linear functions online
struct LineContainer  {
  static const ll inf = 2e18;
  static bool modeQ; // Toggles operator < mode
 
  struct Line {
    mutable ll a, b, end;
    ll intersect(const Line& r) const {
      if (a == r.a) return b > r.b ? inf : -inf;
      ll u = b - r.b, d = r.a - a;
      return u / d - ((u ^ d) < 0 && u % d);
    }
    bool operator<(const Line& r) const {
      return modeQ ? end < r.end : a < r.a;
    }
  };
 
  multiset<Line> S;
  void clear() { S.clear(); }

  // Updates segment end
  bool update(multiset<Line>::iterator it) {
    auto cur = it++; cur->end = inf;
    if (it == S.end()) return false;
    cur->end = cur->intersect(*it);
    return cur->end >= it->end;
  }

  // Insert f(x) = ax + b, time: O(log n)
  void insert(ll a, ll b) {
    auto it = S.insert({ a, b, inf });
    while (update(it)) it = --S.erase(++it);
    while (it != S.begin() && update(--it)) {
      update(it = --S.erase(++it));
    }
    while (it != S.begin() && update(--it)) {
      update(it = --S.erase(++it));
    }
  }

  // Query max(f(x)), time: O(log n)
  ll query(ll x) {
    assert(!S.empty());
    modeQ = 1;
    auto l = *S.lower_bound({ 0, 0, x });
    modeQ = 0;
    return l.a * x + l.b;
  }
};

bool LineContainer::modeQ = false;
```

## 单调队列

维护均是一个闭区间。

1. 尝试插入一个新的点，维护队尾单调性。
2. 插入队尾。
3. 检查队头。
4. 计算答案。

### 滑动窗口

```c++
int l = 0, r = 0;
for (int i = 1; i < k; i++) {
    while (l <= r && a[q[r]] <= a[i]) r--;
    q[++r] = i;
}
for (int i = k; i <= n; i++) {
    while (l <= r && a[q[r]] <= a[i]) r--;
    q[++r] = i;
    while (i - q[l] >= k) l++;
    ans[i] = a[q[l]];
}
```

### 最长为k的最大连续子段和

```c++
for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + a[i];
int l = 1, r = 0, ansl = 0, ansr = 0; ll ans = -inf;
for (int i = 1; i <= n; i++) {
    while (l <= r && pre[i - 1] < pre[q[r]]) r--;
    q[++r] = i - 1;
    while (i - q[l] > k) l++;
    if (pre[i] - pre[q[l]] > ans) {
        ans = pre[i] - pre[q[l]];
        ansl = q[l] + 1; ansr = i;
    }
}
```

## 并查集

### 可持久化并查集

```c++
int n, m, root[maxn];

int tot, ls[maxn * 40], rs[maxn * 40], pre[maxn * 40], siz[maxn * 40];
void build(int l, int r, int& rt) {
    rt = ++tot;
    if (l == r) {
        pre[rt] = l; return ;
    }
    int m = (l + r) >> 1;
    build(lson); build(rson);
}
void update(int i, int x, int last, int l, int r, int& rt) {
    rt = ++tot; ls[rt] = ls[last]; rs[rt] = rs[last];
    if (l == r) {
        pre[rt] = x; siz[rt] = siz[last]; return ;
    }
    int m = (l + r) >> 1;
    if (i <= m) update(i, x, ls[last], lson);
    else update(i, x, rs[last], rson);
}
void add(int i, int l, int r, int& rt) {
    if (l == r) {
        siz[rt]++; return ;
    }
    int m = (l + r) >> 1;
    if (i <= m) add(i, lson);
    else add(i, rson);
}
int query(int i, int l, int r, int rt) {
    if (l == r) return rt;
    int m = (l + r) >> 1;
    if (i <= m) return query(i, lson);
    else return query(i, rson);
}

int find(int i, int x) {
    int p = query(x, 1, n, root[i]);
    return x == pre[p] ? p : find(i, pre[p]);
}
void join(int i, int x, int y) {
    x = find(i - 1, x); y = find(i - 1, y);
    if (pre[x] == pre[y]) return ;
    if (siz[x] > siz[y]) swap(x, y);
    update(pre[x], pre[y], root[i - 1], 1, n, root[i]);
    if (siz[x] == siz[y]) add(pre[y], 1, n, root[i]);
}

int main() {
    scanf("%d%d", &n, &m);
    build(1, n, root[0]);
    for (int i = 1, op, a, b; i <= m; i++) {
        scanf("%d%d", &op, &a);
        if (op == 1) {
            root[i] = root[i - 1]; // important!
            scanf("%d", &b);
            join(i, a, b);
        } else if (op == 2) {
            root[i] = root[a];
        } else if (op == 3) {
            scanf("%d", &b);
            root[i] = root[i - 1];
            a = find(i, a); b = find(i, b);
            if (pre[a] == pre[b]) puts("1");
            else puts("0");
        }
    }
    return 0;
}
```

### 带撤销并查集

```c++
int pre[maxn], siz[maxn];
int find(int x) {
    while (x != pre[x]) x = pre[x]; return x;
}
vector<PII> sta;
bool join(int x, int y) {
    x = find(x); y = find(y);
    if (x == y) return 0;
    if (siz[x] > siz[y]) swap(x, y);
    pre[x] = y; siz[y] += siz[x];
    sta.push_back({x, y});
    return 1;
}
void undo() {
    PII tp = sta.back(); sta.pop_back();
    int x = tp.first, y = tp.second;
    pre[x] = x; siz[y] -= siz[x];
}
```

## Link-Cut Tree

```c++
int n, m, a[maxn];

struct lct {
    int fa[maxn], ch[maxn][2], rev[maxn], s[maxn];
    int nroot(int x) {return ch[fa[x]][0] == x || ch[fa[x]][1] == x;}
    int get(int x) {return ch[fa[x]][1] == x;}
    void pushup(int x) { s[x] = s[ch[x][0]] ^ s[ch[x][1]] ^ a[x]; }
    void pushrev(int x) {
        swap(ch[x][0], ch[x][1]);
        rev[x] ^= 1;
    }
    void pushdown(int x) {
        if (!rev[x]) return;
        if (ch[x][0]) pushrev(ch[x][0]);
        if (ch[x][1]) pushrev(ch[x][1]);
        rev[x] = 0;
    }
    void rot(int x) {
        int old = fa[x], oldf = fa[old], k = get(x), w = ch[x][k ^ 1];
        if (nroot(old)) ch[oldf][ch[oldf][1] == old] = x;
        ch[x][k ^ 1] = old; ch[old][k] = w;
        if (w) fa[w] = old;
        fa[old] = x; fa[x] = oldf;
        pushup(old);
    }
    int st[maxn];
    void splay(int x) {
        int y = x, t = 0;
        st[++t] = y;
        while (nroot(y)) st[++t] = fa[y], y = fa[y];
        while (t) pushdown(st[t--]);
        while (nroot(x)) {
            y = fa[x];
            if (nroot(y)) rot(get(x) == get(y) ? y : x);
            rot(x);
        }
        pushup(x);
    }
    void access(int x) {
        for (int y = 0; x; y = x, x = fa[x])
            splay(x), ch[x][1] = y, pushup(x);
    }
    void make(int x) {
        access(x); splay(x); pushrev(x);
    }
    int findroot(int x) {
        access(x); splay(x); // findroot 把待检查的元素转上去了
        while (ch[x][0]) pushdown(x), x = ch[x][0];
        // splay(x); // ?
        return x;
    }
    void split(int x, int y) {
        make(x); access(y); splay(y);
    }
    int link(int x, int y) {
        make(x);
        if (findroot(y) == x) return 0;
        fa[x] = y;
        return 1;
    }
    int cut(int x, int y) {
        // split(x, y); fa[x] = ch[y][0] = 0; pushup(y);
        make(x);
        if (findroot(y) != x || fa[x] != y || ch[x][1]) return 0;
        // if (findroot(y) != x || size[y] > 2) return 0;
        fa[x] = ch[y][0] = 0;
        pushup(y);
        return 1;
    }
    int qpath(int l, int r) {split(l, r); return s[r];}
    void upoint(int x, int y) {splay(x); a[x] = y;}
}f;
```

### 子树大小

```c++
struct lct {
    int fa[maxn], ch[maxn][2], rev[maxn], s[maxn], si[maxn];
    int nroot(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }
    int get(int x) { return ch[fa[x]][1] == x; }
    void pushup(int x) {
        s[x] = s[ch[x][0]] + s[ch[x][1]] + si[x] + 1;
    }
    void pushrev(int x) {
        swap(ch[x][0], ch[x][1]);
        rev[x] ^= 1;
    }
    void pushdown(int x) {
        if (!rev[x]) return;
        if (ch[x][0]) pushrev(ch[x][0]);
        if (ch[x][1]) pushrev(ch[x][1]);
        rev[x] = 0;
    }
    void rot(int x) {
        int old = fa[x], oldf = fa[old], k = get(x), w = ch[x][k ^ 1];
        if (nroot(old)) ch[oldf][ch[oldf][1] == old] = x;
        ch[x][k ^ 1] = old; ch[old][k] = w;
        if (w) fa[w] = old;
        fa[old] = x; fa[x] = oldf;
        pushup(old);
    }
    int st[maxn];
    void splay(int x) {
        int y = x, t = 0;
        st[++t] = y;
        while (nroot(y)) st[++t] = fa[y], y = fa[y];
        while (t) pushdown(st[t--]);
        while (nroot(x)) {
            y = fa[x];
            if (nroot(y)) rot(get(x) == get(y) ? y : x);
            rot(x);
        }
        pushup(x);
    }
    void access(int x) {
        for (int y = 0; x; y = x, x = fa[x]) {
            splay(x);
            si[x] += s[ch[x][1]] - s[y];
            ch[x][1] = y;
            pushup(x);
        }
    }
    void make(int x) {
        access(x); splay(x); pushrev(x);
    }
    int findroot(int x) {
        access(x); splay(x);
        while (ch[x][0]) pushdown(x), x = ch[x][0];
        return x;
    }
    int link(int x, int y) {
        make(x); make(y);
        fa[x] = y; si[y] += s[x];
        pushup(y);
        return 1;
    }
    void split(int x, int y) {
        make(x); access(y); splay(y);
    }
} f;
```

## K-D Tree

```c++
namespace kdt{
    int rt, cmpd;
    struct node{
        int d[2], mx[2], mn[2], l, r, id;
        bool operator<(const node& b)const{
            return d[kdt::cmpd] < b.d[kdt::cmpd];
        }
    }tree[maxn];

    inline void pushup(int u, int v) {
        node& a = tree[u], & b = tree[v];
        for (int i = 0; i < 2; i++) {
            a.mx[i] = max(a.mx[i], b.mx[i]);
            a.mn[i] = min(a.mn[i], b.mn[i]);
        }
    }
    inline int build(int l, int r, int k) {
        int m = l + r >> 1; cmpd = k;
        nth_element(tree + l, tree + m, tree + r + 1);
        node& t = tree[m]; t.l = t.r = 0;
        for (int i = 0; i < 2; i++) t.mx[i] = t.mn[i] = t.d[i];
        if (l != m) {
            t.l = build(l, m - 1, k ^ 1);
            pushup(m, t.l);
        }
        if (r != m) {
            t.r = build(m + 1, r, k ^ 1);
            pushup(m, t.r);
        }
        return m;
    }

    inline ll sqr(ll x) {return x * x;}
    inline ll distance(const node& a, ll x, ll y) {
        x -= a.d[0]; y -= a.d[1]; return x * x + y * y;
    }
    inline ll cal(int p, ll x, ll y) { // cut
        ll ans = 0; node& a = tree[p];
        if (x < a.mn[0]) ans += sqr(a.mn[0] - x);
        if (x > a.mx[0]) ans += sqr(a.mx[0] - x);
        if (y < a.mn[1]) ans += sqr(a.mn[1] - y);
        if (y > a.mx[1]) ans += sqr(a.mx[1] - y);
        return ans;
    }

    ll ans, x, y;
    inline void query(int p) {
        node& t = tree[p];
        ll d0 = distance(t, x, y), dl = inf, dr = inf;
        if (x == t.d[0] && y == t.d[1]) d0 = inf; //cut
        ans = min(ans, d0);
        if (t.l) dl = cal(t.l, x, y);
        if (t.r) dr = cal(t.r, x, y);
        if (dl < dr) {
            if (dl < ans) query(t.l);
            if (dr < ans) query(t.r);
        }
        else {
            if (dr < ans) query(t.r);
            if (dl < ans) query(t.l);
        }
    }
    inline int query(int a, int b) {
        x = a; y = b; ans = inf;
        query(rt); return ans;
    }

    inline int insert(int x, int y, int p) {
        node& t = tree[p]; t.l = t.r = 0;
        t.mx[0] = t.mn[0] = t.d[0] = x;
        t.mx[1] = t.mn[1] = t.d[1] = y;
        int now = rt, k = 0;
        while (true) {
            pushup(now, p);
            if (tree[now].d[k] <= tree[p].d[k]) {
                if (!tree[now].l) return tree[now].l = p;
                now = tree[now].l;
            }
            else {
                if (!tree[now].r) return tree[now].r = p;
                now = tree[now].r;
            }
            k ^= 1;
        }
        return 0;
    }
}
```

## 莫队

```c++
const int sz = 700;
const int maxn = 50000 + 5;

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
PII get(ll a, ll b) {
    if (a == 0) return { 0, 1 };
    ll g = gcd(a, b);
    return { a / g, b / g };
}

struct Que {
    int l, r, id;
    bool operator<(const Que& b) const {
        if (l / sz == b.l / sz) {
            if ((l / sz) % 2) return r > b.r;
            else return r < b.r;
        }
        return l < b.l;
    }
} q[maxn];

int n, m, a[maxn];
PII ans[maxn];

ll fz, bag[maxn];
ll cal(ll x) {
    return x * (x - 1) / 2;
}
void update(int x, int t) {
    fz -= cal(bag[x]);
    bag[x] += t;
    fz += cal(bag[x]);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    for (int i = 1; i <= m; i++) scanf("%d%d", &q[i].l, &q[i].r), q[i].id = i;
    sort(q + 1, q + 1 + m);
    int l = 1, r = 0; // important
    for (int i = 1; i <= m; i++) {
        while (r < q[i].r) update(a[++r], 1);
        while (l > q[i].l) update(a[--l], 1);
        while (l < q[i].l) update(a[l++], -1);
        while (r > q[i].r) update(a[r--], -1);
        ans[q[i].id] = get(fz, cal(r - l + 1));
    }
    for (int i = 1; i <= m; i++) {
        printf("%lld/%lld\n", ans[i].first, ans[i].second);
    }
    return 0;
}
```

### 带修莫队

```c++
const int sz = 1500;

struct Que {
    int l, r, c, id, t;
    bool operator<(const Que& b) const {
        if (l / sz == b.l / sz) {
            if (r / sz == b.r / sz) {
                return id < b.id;
            }
            return r / sz < b.r / sz;
        }
        return l / sz < b.l / sz;
    }
} q[maxn];

int n, m, m1, m2, a[maxn], b[maxn], ans[maxn];

int p[maxn], c[maxn], pre[maxn];
int res = 0, bag[maxn];
void add(int x) {
    bag[x]++;
    if (bag[x] == 1) res++;
}
void del(int x) {
    bag[x]--;
    if (bag[x] == 0) res--;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", a + i), b[i] = a[i];
    for (int i = 1; i <= m; i++) {
        char op[3];
        scanf("%s", op);
        if (op[0] == 'Q') {
            m1++;
            q[m1].id = m1; q[m1].t = m2;
            scanf("%d%d", &q[m1].l, &q[m1].r);
        } else {
            m2++;
            scanf("%d%d", p + m2, c + m2);
            pre[m2] = b[p[m2]]; b[p[m2]] = c[m2];
        }
    }
    sort(q + 1, q + 1 + m1);
    int l = 1, r = 0, t = 0;
    for (int i = 1; i <= m1; i++) {
        while (r < q[i].r) add(a[++r]);
        while (r > q[i].r) del(a[r--]);
        while (l > q[i].l) add(a[--l]);
        while (l < q[i].l) del(a[l++]);
        while (t < q[i].t) {
            t++;
            if (l <= p[t] && p[t] <= r) {
                del(a[p[t]]); add(c[t]);
            }
            swap(c[t], a[p[t]]);
        }
        while (t > q[i].t) {
            if (l <= p[t] && p[t] <= r) {
                del(a[p[t]]); add(c[t]);
            }
            swap(c[t], a[p[t]]);
            t--;
        }
        ans[q[i].id] = res;
    }
    for (int i = 1; i <= m1; i++) {
        printf("%d\n", ans[i]);
    }
    return 0;
}
```

### 树上莫队

```c++
const int sz = 300;

int n, m, a[maxn], ans[maxn];
vector<int> edge[maxn];

int dfn[maxn],tot;
int stk[maxn], tp, bcnt, bel[maxn], key[maxn];
int dep[maxn], fa[maxn], siz[maxn], son[maxn], top[maxn];
void dfs(int u, int f) {
    dfn[u] = ++tot;
    siz[u] = 1; dep[u] = dep[f] + 1; fa[u] = f;
    int m = -1, bot = tp;
    for (int& v: edge[u]) {
        if (v == f) continue;
        dfs(v, u);
        siz[u] += siz[v];
        if (siz[v] > m) m = siz[v], son[u] = v;
        if (tp - bot >= sz) {
            bcnt++; key[bcnt] = u;
            while (tp != bot) {
                bel[stk[tp--]] = bcnt;
            }
        }
    }
    stk[++tp] = u;
}
void dfs(int u, int f, int tp) {
    top[u] = tp;
    if (!son[u]) return ;
    dfs(son[u], u, tp);
    for (int& v: edge[u]) {
        if (v == f || v == son[u]) continue;
        dfs(v, u, v);
    }
}
int qlca(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}
void init() {
    dfs(1, 0);
    while (tp) bel[stk[tp--]] = bcnt;
    dfs(1, 0, 1);
}

struct Que {
    int u, v, id;
    bool operator<(const Que& b) const {
        if (bel[u] == bel[b.u]) return dfn[v] < dfn[b.v];
        return bel[u] < bel[b.u];
    }
} q[maxn];

int vis[maxn], bag[maxn], res;
void add(int x) {
    bag[x]++; if (bag[x] == 1) res++;
}
void del(int x) {
    bag[x]--; if (bag[x] == 0) res--;
}
void update(int u) {
    if (!vis[u]) {
        add(a[u]);
    } else {
        del(a[u]);
    }
    vis[u] ^= 1;
}
void move(int u, int v) {
    int g = qlca(u, v);
    for (int tot = u; tot != g; tot = fa[tot]) {
        update(tot);
    }
    for (int tot = v; tot != g; tot = fa[tot]) {
        update(tot);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    vector<int> lsh;
    for (int i = 1; i <= n; i++) scanf("%d", a + i), lsh.push_back(a[i]);
    sort(lsh.begin(), lsh.end());
    lsh.resize(unique(lsh.begin(), lsh.end()) - lsh.begin());
    for (int i = 1; i <= n; i++)
        a[i] = lower_bound(lsh.begin(), lsh.end(), a[i]) - lsh.begin() + 1;
    for (int i = 2, u, v; i <= n; i++) {
        scanf("%d%d", &u, &v);
        edge[u].push_back(v); edge[v].push_back(u);
    }
    init();
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &q[i].u, &q[i].v);
        q[i].id = i;
    }
    sort(q + 1, q + 1 + m);
    int u = 1, v = 1;
    for (int i = 1; i <= m; i++) {
        move(u, q[i].u);
        move(v, q[i].v);
        u = q[i].u; v = q[i].v;
        int g = qlca(u, v);
        update(g);
        ans[q[i].id] = res;
        update(g);
    }
    for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
    return 0;
}
```

## cdq分治

```c++
int tree[maxn], res[maxn], n;
inline int lowbit(int x) {return x & -x;}
inline void update(int i, int x) {
    while (i < maxn) {
        tree[i] += x;
        i += lowbit(i);
    }
}
inline int query(int i) {
    int s = 0;
    while (i > 0) {
        s += tree[i];
        i -= lowbit(i);
    }
    return s;
}

struct node {
    int x, y, z, id;
} a[maxn], b[maxn];
bool cmp1(node a, node b) {
    if (a.x != b.x) return a.x < b.x;
    else if (a.y != b.y) return a.y < b.y;
    return a.z < b.z;
}
bool cmp2(node a, node b) {
    if (a.y == b.y) return a.z < b.z;
    return a.y < b.y;
}

void cdq(int l, int r) {
    if (l >= r) return;
    int m = (l + r) / 2;
    cdq(l, m); cdq(m + 1, r);
    for (int i = l; i <= r; i++) b[i] = a[i];
    sort(b + l, b + m + 1, cmp2); sort(b + m + 1, b + r + 1, cmp2);
    int j = l;
    for (int i = m + 1; i <= r; i++) {
        for (; j <= m && b[j].y <= b[i].y; j++) update(b[j].z, 1);
        res[b[i].id] += query(b[i].z);
    }
    for (j--; j >= l; j--) update(b[j].z, -1);
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        ms(tree, 0); ms(res, 0);
        scanf("%d", &n);
        for (int i = 0; i < n; i++) {
            scanf("%d %d %d", &a[i].x, &a[i].y, &a[i].z);
            a[i].id = i;
        }
        sort(a, a + n, cmp1);
        cdq(0, n - 1);
        for (int i = n - 2; i >= 0; i--) {
            if (a[i].x == a[i + 1].x && a[i].y == a[i + 1].y && a[i].z == a[i + 1].z)
                res[a[i].id] = res[a[i + 1].id];
        }
        for (int i = 0; i < n; i++) printf("%d\n", res[i]);
    }
    return 0;
}
```

## RMQ

### 询问最值

```c++
int dp[20][maxn];
void build(){
    for (int i = 1; i <= n; i++) dp[0][i] = s[i];
    for (int j = 1; j < 20; j++)
        for (int i = 1; i + (1 << j) <= n + 1; i++)
            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);
}
int qmax(int l, int r){
    int k = __lg(r - l + 1);
    return max(dp[k][l], dp[k][r - (1 << k) + 1]);
}
```

### 询问最值下标

```c++
int dp[20][maxn];
void build() {
    for (int i = 1; i <= n; i++) dp[0][i] = i;
    for (int j = 1; j < 20; j++)
        for (int i = 1; i + (1 << j) <= n + 1; i++) {
            int l = dp[j - 1][i];
            int r = dp[j - 1][i + (1 << (j - 1))];
            if (a[l] > a[r]) dp[j][i] = l;
            else dp[j][i] = r;
        }
}
int qmax(int l, int r) {
    int k = __lg(r - l + 1);
    int x = dp[k][l], y = dp[k][r - (1 << k) + 1];
    if (a[x] > a[y]) return x;
    else return y;
}
```

## 树链剖分

```c++
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
using namespace std;
typedef long long ll;
const int maxn = 100000 + 5;

int to[maxn << 1], nxt[maxn << 1], head[maxn], tot = 0;
void add(int x, int y) {
    to[++tot] = y; nxt[tot] = head[x]; head[x] = tot;
}

int n, m, a[maxn];

namespace hld{
    ll wt[maxn], tree[maxn << 2], laz[maxn << 2];
    void pushup(int rt) {tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];}
    void pushdown(int rt, int ln, int rn) {
        if (!laz[rt]) return;
        tree[rt << 1] += 1ll * laz[rt] * ln;
        tree[rt << 1 | 1] += 1ll * laz[rt] * rn;
        laz[rt << 1] += 1ll * laz[rt]; laz[rt << 1 | 1] += 1ll * laz[rt];
        laz[rt] = 0;
    }
    void build(int l, int r, int rt) {
        if (l == r) {
            laz[rt] = 0; tree[rt] = wt[l];
            return;
        }
        int m = (l + r) >> 1;
        build(lson); build(rson);
        pushup(rt);
    }
    void update(int i, int x, int l, int r, int rt) {
        if (l == r) {
            tree[rt] += 1ll * x;
            return;
        }
        int m = (l + r) >> 1; pushdown(rt, m - l + 1, r - m);
        if (i <= m) update(i, x, lson);
        else update(i, x, rson);
        pushup(rt);
    }
    void update(int L, int R, int x, int l, int r, int rt) {
        if (L <= l && r <= R) {
            tree[rt] += 1ll * x * (r - l + 1); laz[rt] += 1ll * x;
            return;
        }
        int m = (l + r) >> 1; pushdown(rt, m - l + 1, r - m);
        if (L <= m) update(L, R, x, lson);
        if (R > m) update(L, R, x, rson);
        pushup(rt);
    }
    ll query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) return tree[rt];
        int m = (l + r) >> 1; pushdown(rt, m - l + 1, r - m);
        ll s = 0;
        if (L <= m) s += query(L, R, lson);
        if (R > m) s += query(L, R, rson);
        return s;
    }

    int siz[maxn], dep[maxn], fa[maxn], son[maxn], top[maxn], id[maxn], cnt = 0;
    void dfs(int p, int d, int old) {
        dep[p] = d; fa[p] = old; siz[p] = 1;
        int m = -1;
        for (int i = head[p]; i; i = nxt[i]) {
            int v = to[i];
            if (v == fa[p]) continue;
            dfs(v, d + 1, p);
            siz[p] += siz[v];
            if (siz[v] > m) son[p] = v, m = siz[v];
        }
    }
    void dfs(int p, int tp) {
        id[p] = ++cnt; top[p] = tp; wt[cnt] = a[p];
        if (!son[p]) return;
        dfs(son[p], tp);
        for (int i = head[p]; i; i = nxt[i]) {
            int v = to[i];
            if (v == fa[p] || v == son[p]) continue;
            dfs(v, v);
        }
    }
    void init() {
        cnt = 0; dfs(1, 1, 0); dfs(1, 1); build(1, n, 1);
    }

    int qpath(int x, int y) {
        int ans = 0;
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) swap(x, y);
            ans = (ans + query(id[top[x]], id[x], 1, n, 1)) % p;
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) swap(x, y);
        ans = (ans + query(id[x], id[y], 1, n, 1)) % p;
        return ans;
    }
    int qson(int x) {
        return query(id[x], id[x] + siz[x] - 1, 1, n, 1);
    }
    void upath(int x, int y, int k) {
        k %= p;
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) swap(x, y);
            update(id[top[x]], id[x], k, 1, n, 1);
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) swap(x, y);
        update(id[x], id[y], k, 1, n, 1);
    }
    void uson(int x, int k) {
        update(id[x], id[x] + siz[x] - 1, k % p, 1, n, 1);
    }
}
```

## HashMap

```c++
template<template T>
struct hashmap {
    static const int maxv = 100005;
    static const int seed = 4000007;
    T a[maxv];
    int head[seed], next[maxv], size;
    void init() {
        memset (head, -1, sizeof head);
        size = 0;
    }
    int find(T val) {
        int tmp = (val % seed + seed) % seed;
        for (int i = head[tmp]; i != -1; i = next[i]) {
            if (val == a[i]) return i;
        }
        return -1;
    }
    void add(T val) {
        int tmp = (val % seed + seed) % seed;
        a[size] = val;
        next[size] = head[tmp];
        head[tmp] = size++;
    }
};
```
