# 数学

## 取模

```c++
inline int add(int& x, int y) {
    return (x += y) >= mod ? x -= mod : x;
}
inline int sub(int& x, int y) {
    return (x -= y) < 0 ? x += mod : x;
}
inline int mul(int& x, int y) {
    return 1ll * x * y % mod;
}
inline int qpow(int x, ll n, int mod = mod) {
    int r = 1;
    while (n > 0) {
        if (n & 1) r = 1ll * r * x % mod;
        n >>= 1; x = 1ll * x * x % mod;
    }
    return r;
}
inline int inv(int x) {
    return qpow(x, mod - 2);
}
```

## 组合数

```c++
namespace Comb {
    const int maxc = 2000000 + 5;
    int f[maxc], inv[maxc], finv[maxc];
    void init() {
        inv[1] = 1;
        for (int i = 2; i < maxc; i++)
            inv[i] = (mod - mod / i) * 1ll * inv[mod % i] % mod;
        f[0] = finv[0] = 1;
        for (int i = 1; i < maxc; i++) {
            f[i] = f[i - 1] * 1ll * i % mod;
            finv[i] = finv[i - 1] * 1ll * inv[i] % mod;
        }
    }
    int C(int n, int m) {
        if (m < 0 || m > n) return 0;
        return f[n] * 1ll * finv[n - m] % mod * finv[m] % mod;
    }
    int S(int n, int m) {
        // x_1 + x_2 + ... + x_n = m, x_i >= 0
        if (n == 0 && m == 0) return 1;
        return C(m + n - 1, n - 1);
    }
}
using Comb::C;
```

## 矩阵

```c++
struct Mat {
    static const int M = 2;
    ll a[M][M];
    Mat() { ms(a, 0); }
    void clear() { ms(a, 0); }
    void eye() { for (int i = 0; i < M; i++) a[i][i] = 1; }
    ll* operator [] (ll x) { return a[x]; }
    const ll* operator [] (ll x) const { return a[x]; }
    Mat operator * (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                for (int k = 0; k < M; k++)
                    r[i][j] = (r[i][j] + a[i][k] * b[k][j]) % mod;
        return r;
    }
    Mat pow(ll n) const {
        Mat a = *this, r; r.eye();
        while (n > 0) {
            if (n & 1)  r = r * a;
            n >>= 1; a = a * a;
        }
        return r;
    }
    Mat operator + (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                r[i][j] = (a[i][j] + b[i][j]) % mod;
        return r;
    }
    void print() const {
        for (int i = 0; i < M; i++) for (int j = 0; j < M; j++)
            printf("%lld%c", (*this)[i][j], " \n"[j == M - 1]);
    }
};
```

## 扩展欧几里得

```c++
void extgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    extgcd(b, a % b, x, y);
    ll t = x;
    x = y, y = t - a / b * y;
}
bool solve(ll a, ll b, ll c, ll &x, ll &y) {
    //smallest positive x
    ll d = __gcd(a,b);
    if (c % d) return 0;
    a /= d, b /= d, c /= d;
    extgcd(a, b, x, y);
    x *= c, y *= c;
    x = (x % b + b) % b;
    if (x == 0) x += b;
    y = (c - a * x) / b;
    return 1;
}
bool mod_inv(ll a, ll m, ll &x) {
    ll y;
    if(solve(a,m,1,x,y)) return 1;
    return 0;
}
```

## 类欧几里得

$$
f(a,b,c,n)=\sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\
g(a,b,c,n)=\sum_{i=0}^n i\lfloor \frac{ai+b}{c} \rfloor \\
h(a,b,c,n)=\sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor^2 \\
$$

```c++
dong likegcd(ll a,ll b,ll c,ll n){
    if (!a){
        gjx.f=gjx.g=gjx.h=0;
        return gjx;
    }
    if (a>=c||b>=c){
        zlt=likegcd(a%c,b%c,c,n);
        gjx.f=((ll)(a/c)*n%mo*(n+1)%mo*ni2%mo+(ll)(b/c)*(n+1)%mo)%mo;
        (gjx.f+=zlt.f)%=mo;
        gjx.g=((ll)(a/c)*n%mo*(n+1)%mo*(2*n+1)%mo*ni6%mo+(ll)(b/c)*(n+1)%mo*n%mo*ni2%mo)%mo;
        (gjx.g+=zlt.g)%=mo;
        gjx.h=(ll)(a/c)*(a/c)%mo*n%mo*(n+1)%mo*(2*n+1)%mo*ni6%mo;
        (gjx.h+=(ll)(b/c)*(b/c)%mo*(n+1)%mo)%=mo;
        (gjx.h+=(ll)(a/c)*(b/c)%mo*n%mo*(n+1)%mo)%=mo;
        (gjx.h+=(ll)2*(a/c)%mo*zlt.g%mo)%=mo;
        (gjx.h+=(ll)2*(b/c)%mo*zlt.f%mo)%=mo;
        (gjx.h+=zlt.h)%=mo;
        return gjx;
    }
    ll m=((ll)a*n+(ll)b)/(ll)c;
    zlt=likegcd(c,c-b-1,a,m-1);
    gjx.f=((ll)n*m%mo-(ll)zlt.f)%mo;
    gjx.g=((ll)(n+1)*n%mo*m%mo-(ll)zlt.f-(ll)zlt.h)%mo;
    gjx.g=(ll)gjx.g*ni2%mo;
    gjx.h=((ll)n*m%mo*(m+1)%mo-(ll)2*zlt.g%mo-(ll)2*zlt.f%mo-(ll)gjx.f)%mo;
    return gjx;
}
```



## 欧拉降幂

```c++
#include<bits/stdc++.h>
#define Mod(a,b) a < b ? a : a % b + b
//this Mod is important
using namespace std;
typedef long long ll;
const int maxn = 100005;

int n, q, mod, a[maxn];
unordered_map<int,int> phi;

ll quick_pow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = Mod(res * a, mod); //Mod
        b >>= 1; a = Mod(a * a, mod);
    }
    return res;
}
int Phi(int n) {
    if (phi[n]) return phi[n];
    int res = n, x = n;
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) {
            while (x % i == 0) x /= i;
            res = res / i * (i - 1);
        }
    }
    if (x != 1) res = res / x * (x - 1);
    return phi[n] = res;
}
ll solve(int l,int r,ll mod) {
    // Mod
    if (l == r || mod == 1) return Mod(a[l], mod);
    return quick_pow(a[l], solve(l + 1, r, Phi(mod)), mod);
}

int main() {
    scanf("%d%d", &n, &mod);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    scanf("%d", &q);
    for (int i = 1, l, r; i <= q; i++) {
        scanf("%d%d", &l, &r);
        printf("%lld\n", solve(l, r, mod) % mod); //need %mod
    }
    return 0;
}
```

## 素数测试

if $n < 2,047$, it is enough to test $a = 2$;
if $n < 1,373,653$, it is enough to test $a = 2,3$;
if $n < 9,080,191$, it is enough to test $a = 31,73$;
if $n < 25,326,001$, it is enough to test $a = 2, 3, 5$;
if $n < 3,215,031,751$, it is enough to test $a = 2, 3, 5, 7$;
if $n < 4,759,123,141$, it is enough to test $a = 2, 7, 61$;  (INT范围)
if $n < 1,122,004,669,633$, it is enough to test $a = 2, 13, 23, 1662803$;
if $n < 2,152,302,898,747$, it is enough to test $a = 2, 3, 5, 7, 11$;
if $n < 3,474,749,660,383$, it is enough to test $a = 2, 3, 5, 7, 11, 13$;
if $n < 341,550,071,728,321$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17$;
if $n < 3,825,123,056,546,413,051$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23$;
if $n < 18,446,744,073,709,551,616$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37$; (LONG LONG范围)
if $n < 318,665,857,834,031,151,167,461$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37$;
if $n < 3,317,044,064,679,887,385,961,981$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,  41$.

```C++
ll facs[70], pfacs;

namespace Pollard_Rho {
	inline ll gcd(ll a, ll b) {
		#define ctz __builtin_ctzll
		int shift = ctz(a | b);
		b >>= ctz(b);
		while (a) {
			a >>= ctz(a);
			if (a < b) swap(a, b);
			a -= b;
		}
		return b << shift;
	}
	inline ll mulmod(ll x, ll y, const ll z) {
    return (x * y - (ll)(((long double)x * y + 0.5) / (long double)z) * z  + z) % z;
  }
	inline ll powmod(ll a, ll b, const ll mo) {
		ll s = 1;
		for (; b; b >>= 1, a = mulmod(a, a, mo)) 
      if (b & 1) s = mulmod(s, a, mo);
		return s;
	}
	bool isPrime(ll p) { // Miller-Rabin
    vector<int> a = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
		const int lena = (int)a.size();
		if (p == 2) return true;
		if (p == 1 || !(p & 1)) return false;
		ll D = p - 1; while (!(D & 1)) D >>= 1;
		for (int i = 0; i < lena && a[i] < p; i++) {
			ll d = D, t = powmod(a[i], d, p); if (t == 1) continue;
			for (; d != p - 1 && t != p - 1; d <<= 1) t = mulmod(t, t, p);
			if (d == p - 1) return false;
		}
		return true;
	}
	
	void reportFactor(ll n) { // 得到一个素因子
		facs[pfacs++] = n;
	}
	
	void getFactor(ll n) { // Pollard-Rho
		if (n == 1) return;
		if (isPrime(n)) { reportFactor(n); return; }
		while (true) {
			ll c = rand() % n, i = 1, x = rand() % n, y = x, k = 2;
			do {
				ll d = gcd(n + y - x, n);
				if(d != 1 && d != n) {getFactor(d); getFactor(n / d); return; }
				if (++i == k) y = x, k <<= 1;
				x = (mulmod(x, x, n) + c) % n;
			} while (y != x);
		}
	}
}

int main(){
	srand(time(0));
	int T; scanf("%d",&t);
	ll n, m;
	while (T--) {
		pfacs = 0;
		scanf("%lld",&n);
		if (Pollard_Rho::isPrime(n))
			printf("Prime\n");
		else {
			Pollard_Rho::getFactor(n);
			sort(facs, facs + pfacs);
			for(int i = 0; i < pfacs; i++)
				printf("%lld%c", facs[i], i == pfacs - 1? '\n' : ' ');
		}
	}
	return 0;
}
```

## 快速傅里叶变换

```c++
struct complex {
    double x, y;
    complex(double a = 0, double b = 0):x(a), y(b) {}
    complex operator+(const complex& b) {return complex{x + b.x, y + b.y};}
    complex operator-(const complex& b) {return complex{x - b.x, y - b.y};}
    complex operator*(const complex& b) {
        return complex{x * b.x - y * b.y, x * b.y + y * b.x};
    }
} a[maxn], b[maxn]; int rev[maxn];
void fft(int n, complex a[], int op = 1) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int i = 1; i < n; i <<= 1) {
        complex t(cos(pi / i), op * sin(pi / i));
        for (int j = 0; j < n; j += (i << 1)) {
            complex w(1, 0);
            for (int k = 0; k < i; k++, w = w * t) {
                complex x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y; a[j + k + i] = x - y;
            }
        }
    } 
    if (op == -1) for (int i = 0; i < n; i++) a[i].x /= n, a[i].y /= n;
}
void mul(int n, complex a[], int m, complex b[], int ans[]) {
    int l = 0, lim = 1; while (lim <= n + m) l++, lim <<= 1; 
    for (int i = 0; i < lim; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    fft(lim, a); fft(lim, b);
    for (int i = 0; i <= lim; i++) a[i] = a[i] * b[i];
    fft(lim, a, -1);
    for (int i = 0; i <= n + m; i++) ans[i] = (int)(a[i].x + 0.5);
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=50005;
const double PI=acos(-1.0);
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r;i=_i;}
    Complex operator +(const Complex &b){return Complex(r+b.r,i+b.i);}
    Complex operator -(const Complex &b){return Complex(r-b.r,i-b.i);}
    Complex operator *(const Complex &b){return Complex(r*b.r-i*b.i,r*b.i+i*b.r);}
};
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)
        {
            j-=k;
            k/=2;
        }
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
```

### 原根 FFT

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=200005;
const double PI=acos(-1.0);
int n,p;
int a[max_n];
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r,i=_i;}
    Complex operator + (Complex &c){return Complex(r+c.r,i+c.i);}
    Complex operator - (Complex &c){return Complex(r-c.r,i-c.i);}
    Complex operator * (Complex &c){return Complex(r*c.r- i*c.i,r*c.i+i*c.r);}
}c[max_n*4];
int ip[max_n];
int pi[max_n];
int g;
int cnt[max_n];
ll ans[max_n];
ll quick_pow(ll a,ll b,ll p)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%p;
        b>>=1;
        a=a*a%p;
    }
    return res;
}
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=y[k+h/2]*w;
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
ll get_root(ll p)
{
	if(p==2)return 1;
    else
    {
        vector<ll> v;
        v.clear();
        int x=p-1;
        for(int i=2;1ll*i*i<=x;i++)
        {
            if(x%i==0)
            {
                v.push_back(i);
                while(x%i==0)x/=i;
            }
        }
        if(x!=1)v.push_back(x);
        ll t;
        bool flag;
        for(int i=2;i<p;i++)
        {
            flag=true;
            for(auto d:v)
            {
                t=(p-1)/d;
                if(quick_pow(i,t,p)==1)
                {
                    flag=false;
                    break;
                }
            }
            if(flag)return i;
        }
    }
    return -1;
}
void init(ll p)
{
    g=get_root(p);
    ip[0]=1;
    pi[1]=0;
    for(int i=1;i<p-1;i++)ip[i]=1ll*ip[i-1]*g%p,pi[ip[i]]=i;
}
```

## 快速数论变换

```c++
const int mod = 998244353;
const int maxn = 200000 + 5;

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        x = x * x % mod; n >>= 1;
    }
    return r;
}
ll inv(ll x) { return qpow(x, mod - 2); }
ll rev[maxn << 2];
int init(int m) {
    int step = 0, n = 1;
    for (; n < m; n <<= 1) ++step;
    for (int i = 1; i < n; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
    return n;  
}
void ntt(vector<ll>& a, int n, int op) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int h = 2; h <= n; h <<= 1) {
        ll wn = qpow(3, (mod - 1) / h);
        if (op == -1) wn = inv(wn);
        for (int i = 0; i < n; i += h) {
            ll w = 1;
            for (int j = i; j < i + h / 2; j++) {
                ll u = a[j], t = a[j + h / 2] * w % mod;
                a[j] = (u + t) % mod;
                a[j + h / 2] = (u - t + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (op == -1) {
        ll rn = inv(n);
        for (int i = 0; i < n; i++) a[i] = a[i] * rn % mod;
    }
}
```

### NTT g = 3

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const ll mod=998244353;
int n;
int w[max_n];
ll x1[max_n*4];
ll x2[max_n*4];
ll inv[max_n];
ll quick_pow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return res;
}
void change(ll y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void ntt(ll y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        ll wn=quick_pow(3,(mod-1)/h);
        if(on==-1)wn=quick_pow(wn,mod-2);
        for(int j=0;j<len;j+=h)
        {
            ll w=1;
            for(int k=j;k<j+h/2;k++)
            {
                ll u=y[k];
                ll t=y[k+h/2]*w%mod;
                y[k]=(u+t)%mod;
                y[k+h/2]=(u-t+mod)%mod;
                w=w*wn%mod;
            }
        }
    }
    if(on==-1)
    {
        ll rlen=quick_pow(len,mod-2);
        for(int i=0;i<len;i++)y[i]=y[i]*rlen%mod;
    }
}
```

### 任意模数

```c++
namespace {
    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}
	  inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}
    inline int Mul(int x,int y) {return 1ll*x*y%mod;}
    inline int Pow(int x,int y=mod-2){int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}
}

int Tonelli_Shanks(int n,ll p)
{
    if(p==2) return (n&1)?1:-1;
    if(Pow(n,p>>1)!=1) return -1;
    if(p&2) return Pow(n,(p+1)>>2);
    int s=__builtin_ctzll(p^1);
    int q=p>>s,z=2;
    for(;Pow(z,p>>1)==1;++z);
    int c=Pow(z,q),r=Pow(n,(q+1)>>1),t=Pow(n,q),tmp;
    for(int m=s,i;t!=1;)
    {
        for(i=0,tmp=t;tmp!=1;++i) tmp=tmp*tmp%p;
        for(;i<--m;) c=c*c%p;
        r=r*c%p;c=c*c%p;t=t*c%p;
    }
    return r;
}


namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;

    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};


namespace poly
{
    int inv(int x) {return Pow(x,mod-2);}
    vector<int> fa,fb,fc,fd;
    vector<int> get_inv(vector<int> &a,int n)
    {
        assert(a[0]!=0);
        if(n==1)
        {
            fa.resize(1);
            fa[0]=inv(a[0]);
            return fa;
        }
        fa=get_inv(a,(n+1)>>1);
        fb=fft::multiply_mod(fa,fa,mod,1);
        fb=fft::multiply_mod(fb,a,mod);
        fa.resize(n);
        for(int i=0;i<n;i++)
        {
            fa[i]=Add(fa[i],fa[i]);
            fa[i]=Sub(fa[i],fb[i]);
        }
        return fa;
    }
    vector<int> get_sqrt(vector<int> &a,int n)
    {
        if(n==1)
        {
            fc.resize(1);
            int x=Tonelli_Shanks(a[0],mod);
            assert(x!=-1);
            fc[0]=x;return fc;
        }
        fd=get_sqrt(a,(n+1)>>1);
        fc=get_inv(fd,(n+1)>>1);
        fd=fft::multiply_mod(fd,fd,mod,1);
        for(int i=0;i<(n+1)/2;i++) fc[i]=1LL*fc[i]*((mod+1)/2)%mod;
        for(int i=0;i<n;i++) fd[i]=Add(fd[i],a[i]);
        fd=fft::multiply_mod(fd,fc,mod);
        fd.resize(n);return fd;
    }
    vector<int> diff(vector<int> &a)
    {
        for(int i=1;i<(int)a.size();i++) a[i-1]=1LL*a[i]*i%mod;
        if(a.size()>=1) a.resize((int)a.size()-1);
        return a;
    }
    vector<int> intg(vector<int> &a)
    {
        int sz=(int)a.size();
        a.resize(sz+1);
        static vector<int> Inv(sz+1);
        Inv[1]=1;
        for(int i=2;i<=sz;i++) Inv[i]=Sub(mod,1LL*Inv[mod%i]*(mod/i)%mod);
        for(int i=sz;i>=1;i--) a[i]=1LL*a[i-1]*Inv[i]%mod;
        a[0]=0;
        return a;
    }
};
```

## 多项式

```c++
inline int add(int& x, int y) {
    return (x += y) >= mod ? x -= mod : x;
}
inline int sub(int& x, int y) {
    return (x -= y) < 0 ? x += mod : x;
}
inline int mul(int& x, int y) {
    return 1ll * x * y % mod;
}
inline int qpow(int x, ll n) {
    int r = 1;
    while (n > 0) {
        if (n & 1) r = 1ll * r * x % mod;
        n >>= 1; x = 1ll * x * x % mod;
    }
    return r;
}
inline int inv(int x) {
    return qpow(x, mod - 2);
}

using Poly = vector<int>;

namespace PolyOpe {
    int rev[maxn << 3];
    inline int build(int m) {
        int step = 0, n = 1;
        for (; n < m; n <<= 1) ++step;
        for (int i = 1; i < n; i++) 
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
        return n;  
    }
    inline void print(const Poly& a) {
        #ifdef XLor
            for (int x: a) printf("%d ", x);
            puts("");
        #endif
    }
    void ntt(int a[], int n, int op = 0) {
        for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int h = 2; h <= n; h <<= 1) {
            int wn = qpow(3, (mod - 1) / h);
            if (op == -1) wn = inv(wn);
            for (int i = 0; i < n; i += h) {
                int w = 1;
                for (int j = i; j < i + h / 2; j++) {
                    int u = a[j], t = 1ll * a[j + h / 2] * w % mod;
                    a[j] = (u + t) % mod;
                    a[j + h / 2] = (u - t + mod) % mod;
                    w = 1ll * w * wn % mod;
                }
            }
        }
        if (op == -1) {
            ll rn = inv(n);
            for (int i = 0; i < n; i++) a[i] = 1ll * a[i] * rn % mod;
        }
    }
    Poly operator * (const Poly& a, const Poly& b) {
        static int aa[maxn << 3], bb[maxn << 3];
        int lim = build((int)a.size() + (int)b.size() - 1);
        for (int i = 0; i < (int)a.size(); i++) aa[i] = a[i];
        for (int i = (int)a.size(); i < lim; i++) aa[i] = 0;
        for (int i = 0; i < (int)b.size(); i++) bb[i] = b[i];
        for (int i = (int)b.size(); i < lim; i++) bb[i] = 0;
        ntt(aa, lim); ntt(bb, lim);
        for (int i = 0; i < lim; i++) aa[i] = 1ll * aa[i] * bb[i] % mod;
        ntt(aa, lim, -1);
        Poly ans;
        for (int i = 0; i < (int)a.size() + (int)b.size() - 1; i++) ans.push_back(aa[i]);
        return ans;
    }
}
using namespace PolyOpe;
```

### 分段多项式

前置：取模操作。

$R$ 值域，注意取模时边界的负数。

$$
f(x) = ps[i](x), x \in [rs[i - 1], rs[i]] \\
rs[-1] = -R
$$

```c++
using Poly = vector<int>;

namespace PolyOpe {
    Poly operator+(const Poly& a, const Poly& b) {
        int n = (int)a.size(), m = (int)b.size();
        Poly ans(max(n, m), 0);
        for (int i = 0; i < max(n, m); i++) {
            if (i < n) ans[i] = add(ans[i], a[i]);
            if (i < m) ans[i] = add(ans[i], b[i]);
        }
        return ans;
    }
    Poly& operator+=(Poly& a, const int x) {
        if (a.empty()) a = (Poly){ x };
        else a[0] = add(a[0], x);
        return a;
    }
    Poly operator-(const Poly& a, const Poly& b) {
        int n = (int)a.size(), m = (int)b.size();
        Poly ans(max(n, m), 0);
        for (int i = 0; i < max(n, m); i++) {
            if (i < n) ans[i] = add(ans[i], a[i]);
            if (i < m) ans[i] = sub(ans[i], b[i]);
        }
        return ans;
    }
    Poly operator*(const Poly& a, const Poly& b) {
        int n = (int)a.size(), m = (int)b.size();
        Poly ans(n + m - 1, 0);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                ans[i + j] = add(ans[i + j], mul(a[i], b[j]));
            }
        }
        return ans;
    }
    Poly Int(const Poly& a) {
        int n = (int)a.size();
        Poly ans(n + 1);
        for (int i = 0; i < n; i++) {
            ans[i + 1] = mul(inv[i + 1], a[i]);
        }
        return ans;
    }
    int eval(const Poly& p, int x) {
        if (x < 0) x += mod;
        int ans = 0, tot = 1;
        for (int y: p) {
            ans = add(ans, mul(y, tot));
            tot = mul(tot, x);
        }
        return ans;
    }
}
using namespace PolyOpe;

struct PDF {
    static const int R = 1e9 + 1;

    // f(x) = ps[i](x) in [rs[i - 1], rs[i]]
    // rs[-1] = -R
    vector<Poly> ps;
    vector<int> rs;
    int n = 0;

    PDF() {  }
    PDF(vector<Poly> p, vector<int> r) {
        ps = p; rs = r;
        n = (int)p.size();
    }

    PDF operator*(const PDF& y) {
        vector<Poly> nps;
        vector<int> nrs;
        int left = -R;
        for (int a = 0, b = 0; a < n && b < y.n; ) {
            nps.push_back(ps[a] * y.ps[b]);
            nrs.push_back(min(rs[a], y.rs[b]));
            left = nrs.back();
            while (a < n && rs[a] == left) a++;
            while (b < y.n && y.rs[b] == left) b++;
        }
        return PDF(nps, nrs);
    }

    PDF Int() {
        vector<Poly> nps(n);
        vector<int> nrs(n);
        int C = 0, left = -R;
        for (int i = 0; i < n; i++) {
            nps[i] = PolyOpe::Int(ps[i]);
            nrs[i] = rs[i];
            nps[i] += sub(C, eval(nps[i], left));
            C = eval(nps[i], nrs[i]); 
            // nrs[i] < 0 !!!
            left = nrs[i];
        }
        return PDF(nps, nrs);
    }
};
```

## 快速沃尔什变换

```c++
const int mod = 998244353;
const int inf = 1 << 30;
const int maxn = 1 << 18;

int n, a[maxn], b[maxn], c[maxn], d[maxn], e[maxn], f[maxn];

void fwtOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j + d] = (a[i + j + d] + a[i + j]) % mod;
                else
                    a[i + j + d] = (a[i + j + d] + mod - a[i + j]) % mod;
            }
}
void fwtAND(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j] = (a[i + j] + a[i + j + d]) % mod;
                else
                    a[i + j] = (a[i + j] + mod - a[i + j + d]) % mod;
            }
}
void fwtXOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                int x = a[i + j], y = a[i + j + d];
                a[i + j] = (x + y) % mod;
                a[i + j + d] = (x + mod - y) % mod;
                if (op != 1) {
                    // inv2 = 499122177
                    a[i + j] = 1ll * a[i + j] * 499122177 % mod;
                    a[i + j + d] = 1ll * a[i + j + d] * 499122177 % mod;
                }
            }
}

int main() {
    scanf("%d", &n);
    int m = 1 << n;
    for (int i = 0; i < m; i++) scanf("%d", a + i), c[i] = a[i], e[i] = a[i];
    for (int i = 0; i < m; i++) scanf("%d", b + i), d[i] = b[i], f[i] = b[i];
    fwtOR(a, 1 << n); fwtOR(b, 1 << n);
    for (int i = 0; i < m; i++) a[i] = 1ll * a[i] * b[i] % mod;
    fwtOR(a, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", a[i], " \n"[i == m - 1]);
    fwtAND(c, 1 << n); fwtAND(d, 1 << n);
    for (int i = 0; i < m; i++) c[i] = 1ll * c[i] * d[i] % mod;
    fwtAND(c, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", c[i], " \n"[i == m - 1]);
    fwtXOR(e, 1 << n); fwtXOR(f, 1 << n);
    for (int i = 0; i < m; i++) e[i] = 1ll * e[i] * f[i] % mod;
    fwtXOR(e, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", e[i], " \n"[i == m - 1]);
    return 0;
}
```

### FWT mod

```c++
int quick_pow(int a,int b)
{
    if(a==0)return 0;
    int res=1;
    while(b)
    {
        if(b&1)res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
void fwt_xor(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                int tmp=a[j+k];
                a[j+k]=(tmp+a[j+k+i])%mod;
                a[j+k+i]=(tmp+mod-a[j+k+i])%mod;
            }
        }
    }
    if(opt==-1)
    {
        int inv=quick_pow(l,mod-2);
        for(int i=0;i<l;i++)a[i]=1ll*a[i]*inv%mod;
    }
}


void fwt_or(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k+i]=(a[j+k+i]+a[j+k])%mod;
                else a[j+k+i]=(a[j+k+i]+mod-a[j+k])%mod;
            }
        }
    }
}
void fwt_and(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k]=(a[j+k]+a[j+k+i])%mod;
                else a[j+k]=(a[j+k]+mod-a[j+k+i])%mod;
            }
        }
    }
}
```

```c++
void fwt_xor(ll* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                ll tmp=a[j+k];
                a[j+k]+=a[j+k+i];
                a[j+k+i]=tmp-a[j+k+i];
                if(opt==-1)a[j+k]/=2,a[j+k+i]/=2;
            }
        }
    }
}
```

## 线性基

```c++
struct LinearBase {
    static const int maxl = 63;
    ll a[maxl + 5];
    int cnt;
    LinearBase() { cnt=0; ms(a, 0); }
    void clear() { cnt=0; ms(a, 0); }
    void insert(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x & (1ll << i)) {
                if (a[i]) x ^= a[i];
                else {
                    for (int k = 0; k < i; k++) 
                        if (x & (1ll << k)) x ^= a[k];
                    for (int k = i + 1; k < maxl; k++) 
                        if (a[k] & (1ll << i)) a[k] ^= x;
                    a[i] = x; cnt++;
                    return ;
                }
            }
        }
    }
    bool check(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x >> i & 1) {
                if (a[i]) x ^= a[i];
                else return false;
            }
        }
        return true;
    }
    ll qmax(int x) {
        ll res = x;
        for(int i = maxl - 1 ; i >= 0; i--) {
            if ((res ^ a[i]) > res) res ^= a[i];
        }
        return res;
    }
    // #define QUERY_KTH
    #ifdef QUERY_KTH
    vector<ll> v;
    void init_kth() {
        v.clear();
        for (int i = 0; i < maxl; i++) if (a[i]) v.push_back(a[i]);
    }
    ll query(ll k) {
        if (v.size() != n) k--;
        if (k >= (1ll << v.size())) return -1;
        ll ans = 0;
        for (int i = 0; i < v.size(); i++) if (k & (1ll << i))
            ans ^= v[i];
        return ans;
    }
    #endif
};
```

### 区间线性基

```c++
struct LinearBase {
    static const int M = 30;
    int a[M + 1], pos[M + 1];
    void clear() {
        ms(a, 0); ms(pos, 0);
    }
    LinearBase() { 
        clear();
    }
    int insert(int x, int id = 0) {
        for (int i = M; i >= 0; i--) {
            if (x >> i & 1) {
                if (a[i]) {
                    if (id > pos[i]) swap(id, pos[i]), swap(x, a[i]);
                    x ^= a[i];
                } else {
                    a[i] = x; pos[i] = id;
                    return true;
                }
            }
        }
        return false;
    }
    int query(int x, int l) {
        int ans = x;
        for (int i = M; i >= 0; i--) {
            if (pos[i] < l) continue;
            if ((ans ^ a[i]) >= ans) ans ^= a[i];
        }
        return ans;
    }
};
```

### 线性基求交

```c++
LinearBase intersect(const LinearBase& A, const LinearBase& B) {
	LinearBase all, C, D;
	for (int i = maxl - 1; i >= 0; i--) {
		all.a[i] = A.a[i];
		D.a[i] = 1ll << i;
	}
	for (int i = maxl - 1; i >= 0; i--) {
		if (B.a[i]) {
			ll v = B.a[i], k = 0;
			bool can = true;
			for (int j = 60; j >= 0; j--) {
				if (v & (1ll << j)) {
					if (all.a[j]) {
						v ^= all.a[j];
						k ^= D.a[j];
					} else {
						can = false;
						all.a[j] = v;
						D.a[j] = k;
						break;
					}
				}
			}

			if (can) {
				ll v = 0;
				for (int j = 60; j >= 0; j--) {
					if (k & (1ll << j)) {
						v ^= A.a[j];
					}
				}
				C.insert(v);
			}
		}
	}
	return C;
}
```

## 线性筛法

```c++
namespace sieve{
    const int maxp = 1000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
        ms(vis, 0);
        for (int i = 2; i < maxp; i++) {
            if (!vis[i]) prime[tot++] = i;
            for (int j = 0; j < tot && prime[j] * i < maxp; j++) {
                vis[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
    }
}
```

### 欧拉函数

```c++
int phi[maxn], prime[maxn], cnt;
bool isntp[maxn];
void getphi() {
    phi[1] = 1;
    for (int i = 2; i < maxn; i++) {
        if (!isntp[i]) prime[++tot] = i, phi[i] = i - 1;
        for (int j = 1; j < cnt; j++) {
            if (1ll * prime[j] * i >= maxn) break;
            isntp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }        
    }
}
```

### 莫比乌斯反演

```c++
int mu[maxn], vis[maxn], prime[maxn], tot;
void getMu() {
    mu[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!vis[i]) prime[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot && i * prime[j] < maxn; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
```

## 高斯消元

### 实数

```c++
namespace Gauss {
    static const double eps = 1e-7;
    double a[maxn][maxn], ans[maxn];
    void init(int n) {
        for (int i = 0; i <= n + 1; i++) {
            ans[i] = 0;
            for (int j = 0; j <= n + 1; j++)
                a[i][j] = 0;
        }
    }
    bool get(int n) {
        for (int i = 1; i <= n; i++) {
            int r = i;
            for (int j = i + 1; j <= n; j++)
                if(abs(a[j][i]) > abs(a[r][i])) r = j;
            if (abs(a[r][i]) < eps) return false;
            swap(a[r], a[i]);
            double inv = a[i][i];
            for (int j = i; j <= n + 1; j++) a[i][j] /= inv;
            for (int j = i + 1; j <= n; j++) {
                double inv = a[j][i];
                for(int k = i; k <= n + 1; k++)
                    a[j][k] -= inv * a[i][k];
            }
        }
        for(int i = n; i >= 1; i--) {
            ans[i] = a[i][n + 1];
            for(int j = i + 1; j <= n; j++)
                ans[i] -= a[i][j] * ans[j];
        }
        return true;
    }
    void print(int n) {
        for (int i = 1; i <= n; i++, puts(""))
            for (int j = 1; j <= n + 1; j++)
                printf("%lf ", a[i][j]);
    }
}
```

### 取模

```c++
int n;
int a[maxn][maxn], ans[maxn];
bool gauss() {
    for (int i = 1; i <= n; i++) {
        int r = i;
        for (int j = i + 1; j <= n; j++) if (a[j][i] > a[r][i]) r = j;
        if (a[r][i] == 0) return false;
        int inv = qpow(a[i][i]);
        for (int j = i; j <= n + 1; j++) a[i][j] = 1ll * a[i][j] * inv % mod;
        for (int j = i + 1; j <= n; j++) {
            int inv = a[j][i];
            for (int k = i; k <= n + 1; k++)
                a[j][k] += mod - 1ll * inv * a[i][k] % mod, a[j][k] %= mod;
        }
    }
    for (int i = n; i >= 1; i--) {
        ans[i] = a[i][n + 1];
        for (int j = i + 1; j <= n; j++)
            ans[i] += mod - 1ll * ans[j] * a[i][j] % mod, ans[i] %= mod;
    }
    return true;
}
```

## 康拓展开

```c++
int f[10];
void init() {
    f[0] = 1; for (int i = 1; i < 10; i++) f[i] = f[i - 1] * i;
}

int cantor(int x[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int temp = 0;
        for (int j = i + 1; j < n; j++)
            if (x[i] > x[j])
                temp++;
        sum += f[n - 1 - i] * temp;
    }
    return sum;
}

int cantor(int t, int x[], int n) {
    int vis[10] = {0};
    for (int i = n - 1; i >= 0; i--) {
        int k = t / f[i]; t = t % f[i];
        int j = 1, s = 0;
        while (s < k || vis[j]) {
            if (!vis[j]) s++;
            j++;
        }
        vis[j] = 1; x[n - 1 - i] = j;
    }
    return 0;
}
```

## 数学公式

### 整除和 $\gcd$ 相关

$(n,i)=1$ ，推出 $ (n,n-i)=1$

$(i+j,i-j) | 2\cdot (i,j)$

$\gcd(a^m-1,a^n-1)=a^{\gcd(m,n)}-1$

$\gcd(a,b)=1,\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(m,n)}-b^{\gcd(m,n)}$

$G=\gcd(C_n^1 ,C_n^2 ,... ,C_n^{n-1})$ ，那么G的值为：

1. $n$ 为质数，$G=n$

2. $n$ 有多个质因子，$G=1$

3. $n$ 只有一个质因子 , $G=p$

$(a,b)=1$，$a,b$ 不能线性表示的最大的数为 $ab-a-b$，不能线性表示的数的个数$\frac{(a-1)(b-1)}{2}$

**杜教筛**: $g(1)S(n)=\sum_{i=1}^n h(i) - \sum_{d=2}^n g(d) \cdot S(\lfloor \frac{n}{d} \rfloor)$,其中 $h(i)=(f*g)(i)$ 

### Fibnacci

$F(n)=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]$

$F(n)=F(m)F(n-m+1)+F(m-1)F(n-m)$

$F(n+m)=F(m-1)F(n)+F(m)F(n+1)$

$F(1)+F(2)+...+F(n)=F(n+2)-1$

$1\cdot F(1)+2\cdot F(2)+\dots+n \cdot F(n)=n\cdot F(n+2)-F(n+3)+2$

$F(1)^2 +F(2)^2 +...+F(n)^2 =F(n)F(n+1)$

$F(1)+F(3)+...+F(2n-1)=F(2n)$

$F(2)+F(4)+...+F(2n)=F(2n+1)-1$

$F(n-1)F(n+1)=F(n)^2 +(-1)^n$

$\gcd(F(n),F(m))=\gcd(F(n-m),F(m))$

$\gcd(F(n),F(m))=F(\gcd(n,m))$

$F(n)|F(m)\Leftrightarrow n|m$

$F(x)=\begin{cases}C_{\frac{x}{2}}^1 +C_{\frac{x}{2}+1}^3 +C_{\frac{x}{2}+2}^5 +...+C_{x-1}^{x-1},&\text{if x is even}\\C_{\frac{x-1}{2}}^0 +C_{\frac{x-1}{2}+1}^2 +C_{\frac{x-1}{2}+2}^4 +...+C_{x-1}^{x-1},&\text{if x is odd}\end{cases}$

### 其他

$[1,n]$ 内 $lowbit(i)=x$ 的数量有$ (x\le n)+(n-x)/(2\cdot x)$

$k$ 进制下数字根 = $(\text{sumdigit}-1)\%(k-1)+1$

## 斐波那契循环节

```c++
const int M = 2;

struct Matrix{
    LL m[M][M];
} A, I = {1, 0, 0, 1};
Matrix multi(Matrix a, Matrix b, LL mod) { // 矩阵乘法
    Matrix c;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < M; j++) {
            c.m[i][j] = 0;
            for (int k = 0; k < M; k++)
                c.m[i][j] = (c.m[i][j] % mod + (a.m[i][k] % mod) * (b.m[k][j] % mod) % mod) % mod;
            c.m[i][j] %= mod;
        }
    }
    return c;
}
Matrix power(Matrix a, LL k, LL mod) { // 矩阵快速幂
    Matrix ans = I, p = a;
    while (k) {
        if (k & 1) ans = multi(ans, p, mod);
        k >>= 1;
        p = multi(p, p, mod);
    }
    return ans;
}
void init() { // 变换矩阵
    A.m[0][0] = A.m[0][1] = A.m[1][0] = 1;
    A.m[1][1] = 0;
}

LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }
LL qpow(LL a, LL b, LL c) {
    LL res = 1; a = a % c;
    while (b) {
        if (b & 1)
            res = res * a % c;
        b >>= 1;
        a = a * a % c;
    }
    return res;
}

LL w[maxn], c;
LL cal(LL p) { // 计算 G(p)
    if (p == 2) return 3;
    if (p == 3) return 8;
    if (p == 5) return 20;
    LL ans = 1, n;
    if (qpow(5, (p - 1) >> 1, p) == 1) n = p - 1;
    else n = 2 * p + 2;
    c = 0;
    for (LL i = 1; i * i <= n; i++)
        if (n % i == 0) {
            LL x = i, y = n / i;
            Matrix t = power(A, x - 1, p);
            LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
            LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
            if (f1 == 1 && f2 == 0) return x;
            if (x != y) w[c++] = y; // 优先按顺序计算，不加这个会超时
        }
    while (c) {
        Matrix t = power(A, w[--c] - 1, p);
        LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
        LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
        if (f1 == 1 && f2 == 0) return w[c];
    }
    return 1;
}

LL findLoop(LL n) { // 整数分解，G(p) 结果合并
    LL x = n, res = 1, l = LL(sqrt(n));
    for (LL i = 2; i * i <= x; i++)
        if (x % i == 0) {
            LL t = 1;
            while (x % i == 0) x /= i, t *= i;
            t = t / i * cal(i);
            res = res / gcd(res, t) * t;
        }
    if (x > 1) { // 防止 x 有余数
        LL t = cal(x);
        res = res / gcd(res, t) * t;
    }
    return res;
}
```

## 拉格朗日插值

```c++
int query(int x) {
    cout << "? " << x << endl;
    cin >> x; return x;
}

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        n >>= 1; x = x * x % mod;
    }
    return r;
}
ll Inv(ll x) {
    return qpow(x, mod - 2);
}

ll fac[maxn], a[20], inv[maxn];
struct Lagrange {
    // 1-based
    ll cc[20]; int n;
    void build(int nn) {
        n = nn;
        for (int i = 1; i <= n; i++) {
            cc[i] = Inv(fac[i - 1] * fac[n - i]) * a[i] % mod;
            if ((n - i) % 2 == 1) cc[i] = (mod - cc[i]) % mod;
        }
    }
    ll get(ll x) {
        if (x <= n) return a[x];
        ll ans = 0, tmp = 1;
        for (int i = 1; i <= n; i++) tmp = tmp * (x - i) % mod;
        for (int i = 1; i <= n; i++) {
            ans += tmp * inv[x - i] % mod * cc[i] % mod;
            if (ans >= mod) ans -= mod;
        }
        return ans;
    }
} f;

int main() {
    fac[0] = 1; 
    for (int i = 1; i < maxn; i++) fac[i] = fac[i - 1] * i % mod, inv[i] = Inv(i);
    for (int i = 0; i <= 15; i++) {
        a[i + 1] = query(i);
    }
    f.build(13);
    for (int i = 0; i < mod; i++) {
        if (!f.get(i + 1)) {
            cout << "! " << i << endl;
            return 0;
        }
    }
    cout << "! -1" << endl;
    return 0;
}
```

```c++
namespace Lagrange {
    int x[max_n],y[max_n],n;
    int inv[max_n];
    int pre[max_n],suf[max_n];
    void init(int* _x,int* _y,int _n)
    {
        n=_n;
        for(int i=1;i<=n;i++)x[i]=_x[i],y[i]=_y[i];
        int res=1;
        for(int i=1;i<=n;i++)res=1ll*res*i%mod;
        inv[n]=Pow(res);
        for(int i=n-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    }
    int cal(int m)//O(n^2)
    {
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1,ty=1;
            for(int j=1;j<=n;j++)
            {
                if(j==i)continue;
                tx=1ll*tx*(m+mod-x[j])%mod;
                ty=1ll*ty*(x[i]+mod-x[j])%mod;
            }
            tx=1ll*tx*Pow(ty)%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
    int qcal(int m)//O(n)
    {
        pre[0]=suf[n+1]=1;
        for(int i=1;i<=n;i++)pre[i]=1ll*pre[i-1]*(m+mod-x[i])%mod;
        for(int i=n;i>=1;i--)suf[i]=1ll*suf[i+1]*(m+mod-x[i])%mod;
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1ll*pre[i-1]*suf[i+1]%mod;
            int ty=1ll*inv[i-1]*inv[n-i]%mod;
            if((n-i)&1)ty=mod-ty;
            tx=1ll*tx*ty%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
}
```

## min_25 筛

### 递归版

```c++
int Sqr;
ll n;
int cnt;
bool p[max_n];
int pri[max_n];
int m;
ll w[max_n*2];
int id1[max_n*2],id2[max_n*2];
ll pre[max_n];
ll g[max_n*2],h[max_n*2],s[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i,pre[cnt]=(pre[cnt-1]+i)%mod;//decided
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
void init()
{
    Sqr=sqrt(n);
    m=0;
    ll i,j;
    for(i=1;i<=n;i=j+1)
    {
        w[++m]=n/i;
        g[m]=(w[m]+1)%mod*(w[m]%mod)%mod;//decided by f(x)
        if(g[m]&1)g[m]+=mod;
        g[m]/=2,g[m]--;
        h[m]=(w[m]-1)%mod;
        j=n/(n/i);
        if(w[m]<=Sqr)id1[w[m]]=m;
        else id2[n/w[m]]=m;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=(w[j]/pri[i]<=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];
            g[j]=g[j]+mod-1ll*pri[i]*(g[k]+mod-pre[i-1])%mod,g[j]%=mod;
            h[j]=h[j]+mod-(h[k]+mod-(i-1)),h[j]%=mod;//decided by f(x)
        }
    }
}
ll S(ll x,ll y)
{
    if(x<=1||x<pri[y])return 0;
    int k=x<=Sqr?id1[x]:id2[n/x];
    ll res=g[k]-pre[y-1]+mod-(h[k]-(y-1));//decided by f(x)
    res%=mod;
    if(y==1)res+=2;//decided by details
    for(int i=y;i<=cnt&&1ll*pri[i]*pri[i]<=x;i++)
    {
        ll t1=pri[i],t2=1ll*pri[i]*pri[i];
        for(int e=1;t2<=x;e++,t1=t2,t2*=pri[i])
        {
            res+=(pri[i]^e)*S(x/t1,i+1)%mod+(pri[i]^(e+1));//decided by f(x)
            res%=mod;
        }
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init();
    printf("%lld\n",(1+S(n,1))%mod);
    return 0;
}
```

### 非递归版

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const int mod=998244353;
ll n;
int Sqr,m;
int ID(ll x){return x<=Sqr?m+1-x:n/x;}

bool p[max_n];
int pri[max_n];
int cnt;
ll w[max_n*2],g[max_n*2],f[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i;
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
ll F(ll e)
{
    if(e==1)return mod-2;
    else if(e==2)return 1;
    else return 0;
}
void init(ll n)
{
    Sqr=sqrt(n);
    m=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        w[++m]=n/l;
        g[m]=(w[m]-1)%mod;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=ID(w[j]/pri[i]);
            g[j]=g[j]+mod-(g[k]+mod-(i-1))%mod,g[j]%=mod;
        }
    }
    for(int i=cnt;i;i--)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            ll t1=pri[i],t2=1ll*pri[i]*pri[i];
            for(int e=1;t2<=w[j];e++,t1=t2,t2*=pri[i])
            {
                if(e>=3)break;
                int k=ID(w[j]/t1);
                f[j]+=F(e)*(f[k]+mod-2*(g[k]+mod-i)%mod)%mod+F(e+1),f[j]%=mod;
            }
        }
    }
    for(int j=1;j<=m;j++)f[j]+=mod-g[j]*2%mod,f[j]%=mod;
}
ll solve(ll n)
{
    ll res=0;
    ll ps=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        int k=ID(r);
        ll ns=f[k]+1;
        ll tmp=n/l%mod;
        tmp=tmp*tmp%mod;
        res+=tmp*(ns+mod-ps)%mod,res%=mod;
        ps=ns;
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init(n);
    printf("%lld\n",solve(n));
}
```

## 扩展 BSGS

```c++
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
const int HashMod=123456;
struct HashTable
{
    struct Line{int u,v,next;}e[100000];
    int h[HashMod],cnt;
    void Add(int u,int v,int w){e[++cnt]=(Line){w,v,h[u]};h[u]=cnt;}
    void clear(){memset(h,0,sizeof(h));cnt=0;}
    void Insert(int x,int i)
    {
        int k=x%HashMod;
        Add(k,i,x);
    }
    int Query(int x)
    {
        for(int i=h[x%HashMod];i;i=e[i].next)
            if(e[i].u==x)return e[i].v;
        return -1;
    }
}Hash;
int fpow(int a,int b,int MOD)
{
    int s=1;
    while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
void NoAnswer(){puts("No Solution");}
void ex_BSGS(int y,int z,int p)
{
    if(z==1){puts("0");return;}
    int k=0,a=1;
    while(233)
    {
        int d=__gcd(y,p);if(d==1)break;
        if(z%d){NoAnswer();return;}
        z/=d;p/=d;++k;a=1ll*a*y/d%p;
        if(z==a){printf("%d\n",k);return;}
    }
    Hash.clear();
    int m=sqrt(p)+1;
    for(int i=0,t=z;i<m;++i,t=1ll*t*y%p)Hash.Insert(t,i);
    for(int i=1,tt=fpow(y,m,p),t=1ll*a*tt%p;i<=m;++i,t=1ll*t*tt%p)
    {
        int B=Hash.Query(t);if(B==-1)continue;
        printf("%d\n",i*m-B+k);return;
    }
    NoAnswer();
}
int main()
{
    int x,z,k;
    while(233)
    {
        x=read();z=read();k=read();
        if(x==0&&z==0&&k==0)break;
        ex_BSGS(x,k,z);
    }
    return 0;
}
```
