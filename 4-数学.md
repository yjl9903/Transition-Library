# 数学

## 取模

```c++
inline int add(int& x, int y) {
    return (x += y) >= mod ? x -= mod : x;
}
inline int sub(int& x, int y) {
    return (x -= y) < 0 ? x += mod : x;
}
inline int mul(int& x, int y) {
    return 1ll * x * y % mod;
}
inline int qpow(int x, ll n) {
    int r = 1;
    while (n > 0) {
        if (n & 1) r = 1ll * r * x % mod;
        n >>= 1; x = 1ll * x * x % mod;
    }
    return r;
}
inline int inv(int x) { 
    return qpow(x, mod - 2);
}
```

## 组合数

```c++
namespace Comb {
    const int maxc = 2000000 + 5;
    int f[maxc], inv[maxc], finv[maxc];
    void init() {
        inv[1] = 1;
        for (int i = 2; i < maxc; i++) 
            inv[i] = (mod - mod / i) * 1ll * inv[mod % i] % mod;
        f[0] = finv[0] = 1; 
        for (int i = 1; i < maxc; i++) {
            f[i] = f[i - 1] * 1ll * i % mod;
            finv[i] = finv[i - 1] * 1ll * inv[i] % mod;
        }
    }
    int C(int n, int m) {
        if (m < 0 || m > n) return 0;
        return f[n] * 1ll * finv[n - m] % mod * finv[m] % mod;
    }
  	int S(int n, int m) {
        // x_1 + x_2 + ... + x_n = m, x_i >= 0
        if (n == 0 && m == 0) return 1;
        return C(m + n - 1, n - 1);
    }
}
using Comb::C;
```

## 矩阵

```c++
struct Mat {
    static const int M = 2;
    ll a[M][M];
    Mat() { ms(a, 0); }
    void clear() { ms(a, 0); }
    void eye() { for (int i = 0; i < M; i++) a[i][i] = 1; }
    ll* operator [] (ll x) { return a[x]; }
    const ll* operator [] (ll x) const { return a[x]; }
    Mat operator * (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                for (int k = 0; k < M; k++)
                    r[i][j] = (r[i][j] + a[i][k] * b[k][j]) % mod;
        return r;
    }
    Mat pow(ll n) const {
        Mat a = *this, r; r.eye();
        while (n > 0) {
            if (n & 1)  r = r * a;
            n >>= 1; a = a * a;
        }
        return r;
    }
    Mat operator + (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                r[i][j] = (a[i][j] + b[i][j]) % mod;
        return r;
    }
    void print() const {
        for (int i = 0; i < M; i++) for (int j = 0; j < M; j++)
            printf("%lld%c", (*this)[i][j], " \n"[j == M - 1]);
    }
};
```

## 扩展欧几里得

```c++
void extgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1, y = 0;
        return;
    }
    extgcd(b, a % b, x, y);
    ll t = x;
    x = y, y = t - a / b * y;
}
bool solve(ll a, ll b, ll c, ll &x, ll &y) {
  	//smallest positive x
    ll d = __gcd(a,b);
    if (c % d) return 0;
    a /= d, b /= d, c /= d;
    extgcd(a, b, x, y);
    x *= c, y *= c;
    x = (x % b + b) % b;
    if (x == 0) x += b;
    y = (c - a * x) / b;
    return 1;
}
bool mod_inv(ll a, ll m, ll &x) {
    ll y;
    if(solve(a,m,1,x,y)) return 1;
    return 0;
}
```

## 欧拉降幂

```c++
#include<bits/stdc++.h>
#define Mod(a,b) a<b?a:a%b+b
//this Mod is important
using namespace std;
typedef long long ll;
const int max_n=100005;
int n,mod;
int a[max_n];
int q;
unordered_map<int,int> phi;
ll quick_pow(ll a,ll b,ll mod)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=Mod(res*a,mod);//Mod
        b>>=1;
        a=Mod(a*a,mod);
    }
    return res;
}
int Phi(int n)
{
    if(phi[n])return phi[n];
    int res=n,x=n;//int x=n is a good haibit
    for(int i=2;i<=sqrt(x);i++)
    {
        if(x%i==0)
        {
            while(x%i==0)x/=i;
            res=res/i*(i-1);
        }
    }
    if(x!=1)res=res/x*(x-1);
    return phi[n]=res;
}
ll solve(int l,int r,ll mod)//Mod
{
    if(l==r||mod==1)return Mod(a[l],mod);
    return quick_pow(a[l],solve(l+1,r,Phi(mod)),mod);
}
int main()
{
    scanf("%d%d",&n,&mod);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    scanf("%d",&q);
    int l,r;
    for(int i=1;i<=q;i++)
    {
        scanf("%d%d",&l,&r);
        printf("%lld\n",solve(l,r,mod)%mod);//need %mod
    }
    return 0;
}
```

## 素数测试

if $n < 2,047$, it is enough to test $a = 2$;
if $n < 1,373,653$, it is enough to test $a = 2,3$;
if $n < 9,080,191$, it is enough to test $a = 31,73$;
if $n < 25,326,001$, it is enough to test $a = 2, 3, 5$;
if $n < 3,215,031,751$, it is enough to test $a = 2, 3, 5, 7$;
if $n < 4,759,123,141$, it is enough to test $a = 2, 7, 61$;  (INT范围)
if $n < 1,122,004,669,633$, it is enough to test $a = 2, 13, 23, 1662803$;
if $n < 2,152,302,898,747$, it is enough to test $a = 2, 3, 5, 7, 11$;
if $n < 3,474,749,660,383$, it is enough to test $a = 2, 3, 5, 7, 11, 13$;
if $n < 341,550,071,728,321$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17$;
if $n < 3,825,123,056,546,413,051$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23$;
if $n < 18,446,744,073,709,551,616$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37$; (LONG LONG范围)
if $n < 318,665,857,834,031,151,167,461$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37$;
if $n < 3,317,044,064,679,887,385,961,981$, it is enough to test $a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,  41$.

```C++
ll facs[70], pfacs;

namespace Pollard_Rho {
	inline ll gcd(ll a, ll b) {
		#define ctz __builtin_ctzll
		int shift = ctz(a | b);
		b >>= ctz(b);
		while (a) {
			a >>= ctz(a);
			if (a < b) swap(a, b);
			a -= b;
		}
		return b << shift;
	}
	inline ll mulmod(ll x, ll y, const ll z) {
    return (x * y - (ll)(((long double)x * y + 0.5) / (long double)z) * z  + z) % z;
  }
	inline ll powmod(ll a, ll b, const ll mo) {
		ll s = 1;
		for (; b; b >>= 1, a = mulmod(a, a, mo)) 
      if (b & 1) s = mulmod(s, a, mo);
		return s;
	}
	bool isPrime(ll p) { // Miller-Rabin
		const int lena = 10, a[lena] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
		if (p == 2) return true;
		if (p == 1 || !(p & 1)) return false;
		ll D = p - 1; while (!(D & 1)) D >>= 1;
		for (int i = 0; i < lena && a[i] < p; i++) {
			ll d = D, t = powmod(a[i], d, p); if (t == 1) continue;
			for (; d != p - 1 && t != p - 1; d <<= 1) t = mulmod(t, t, p);
			if (d == p - 1) return false;
		}
		return true;
	}
	
	void reportFactor(ll n){ // 得到一个素因子
		facs[pfacs++] = n;
	}
	
	void getFactor(ll n) { // Pollard-Rho
		if (n == 1) return;
		if (isPrime(n)) { reportFactor(n); return; }
		while (true) {
			ll c = rand() % n, i = 1, x = rand() % n, y = x, k = 2;
			do {
				ll d = gcd(n + y - x, n);
				if(d != 1 && d != n) {getFactor(d); getFactor(n / d); return; }
				if (++i == k) y = x, k <<= 1;
				x = (mulmod(x, x, n) + c) % n;
			} while (y != x);
		}
	}
}

int main(){
	srand(time(0));
	int T; scanf("%d",&t);
	ll n, m;
	while (T--) {
		pfacs = 0;
		scanf("%lld",&n);
		if (Pollard_Rho::isPrime(n))
			printf("Prime\n");
		else {
			Pollard_Rho::getFactor(n);
			sort(facs, facs + pfacs);
			for(int i = 0; i < pfacs; i++)
				printf("%lld%c", facs[i], i == pfacs - 1? '\n' : ' ');
		}
	}
	return 0;
}
```



## 快速傅里叶变换

```c++
struct complex {
    double x, y;
    complex(double a = 0, double b = 0):x(a), y(b) {}
    complex operator+(const complex& b) {return complex{x + b.x, y + b.y};}
    complex operator-(const complex& b) {return complex{x - b.x, y - b.y};}
    complex operator*(const complex& b) {
        return complex{x * b.x - y * b.y, x * b.y + y * b.x};
    }
} a[maxn], b[maxn]; int rev[maxn];
void fft(int n, complex a[], int op = 1) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int i = 1; i < n; i <<= 1) {
        complex t(cos(pi / i), op * sin(pi / i));
        for (int j = 0; j < n; j += (i << 1)) {
            complex w(1, 0);
            for (int k = 0; k < i; k++, w = w * t) {
                complex x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y; a[j + k + i] = x - y;
            }
        }
    } 
    if (op == -1) for (int i = 0; i < n; i++) a[i].x /= n, a[i].y /= n;
}
void mul(int n, complex a[], int m, complex b[], int ans[]) {
    int l = 0, lim = 1; while (lim <= n + m) l++, lim <<= 1; 
    for (int i = 0; i < lim; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    fft(lim, a); fft(lim, b);
    for (int i = 0; i <= lim; i++) a[i] = a[i] * b[i];
    fft(lim, a, -1);
    for (int i = 0; i <= n + m; i++) ans[i] = (int)(a[i].x + 0.5);
}
```



```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=50005;
const double PI=acos(-1.0);
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r;i=_i;}
    Complex operator +(const Complex &b){return Complex(r+b.r,i+b.i);}
    Complex operator -(const Complex &b){return Complex(r-b.r,i-b.i);}
    Complex operator *(const Complex &b){return Complex(r*b.r-i*b.i,r*b.i+i*b.r);}
};
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)
        {
            j-=k;
            k/=2;
        }
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
```

### 原根 FFT

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=200005;
const double PI=acos(-1.0);
int n,p;
int a[max_n];
struct Complex
{
    double r,i;
    Complex(double _r=0.0,double _i=0.0){r=_r,i=_i;}
    Complex operator + (Complex &c){return Complex(r+c.r,i+c.i);}
    Complex operator - (Complex &c){return Complex(r-c.r,i-c.i);}
    Complex operator * (Complex &c){return Complex(r*c.r- i*c.i,r*c.i+i*c.r);}
}c[max_n*4];
int ip[max_n];
int pi[max_n];
int g;
int cnt[max_n];
ll ans[max_n];
ll quick_pow(ll a,ll b,ll p)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%p;
        b>>=1;
        a=a*a%p;
    }
    return res;
}
void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(on*2*PI/h),sin(on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=y[k+h/2]*w;
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;i++)y[i].r/=len;
}
ll get_root(ll p)
{
	if(p==2)return 1;
    else
    {
        vector<ll> v;
        v.clear();
        int x=p-1;
        for(int i=2;1ll*i*i<=x;i++)
        {
            if(x%i==0)
            {
                v.push_back(i);
                while(x%i==0)x/=i;
            }
        }
        if(x!=1)v.push_back(x);
        ll t;
        bool flag;
        for(int i=2;i<p;i++)
        {
            flag=true;
            for(auto d:v)
            {
                t=(p-1)/d;
                if(quick_pow(i,t,p)==1)
                {
                    flag=false;
                    break;
                }
            }
            if(flag)return i;
        }
    }
    return -1;
}
void init(ll p)
{
    g=get_root(p);
    ip[0]=1;
    pi[1]=0;
    for(int i=1;i<p-1;i++)ip[i]=1ll*ip[i-1]*g%p,pi[ip[i]]=i;
}
```

## 快速数论变换

```c++
const int mod = 998244353;
const int maxn = 200000 + 5;

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        x = x * x % mod; n >>= 1;
    }
    return r;
}
ll inv(ll x) { return qpow(x, mod - 2); }
ll rev[maxn << 2];
int init(int m) {
    int step = 0, n = 1;
    for (; n < m; n <<= 1) ++step;
    for (int i = 1; i < n; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
    return n;  
}
void ntt(vector<ll>& a, int n, int op) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int h = 2; h <= n; h <<= 1) {
        ll wn = qpow(3, (mod - 1) / h);
        if (op == -1) wn = inv(wn);
        for (int i = 0; i < n; i += h) {
            ll w = 1;
            for (int j = i; j < i + h / 2; j++) {
                ll u = a[j], t = a[j + h / 2] * w % mod;
                a[j] = (u + t) % mod;
                a[j + h / 2] = (u - t + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (op == -1) {
        ll rn = inv(n);
        for (int i = 0; i < n; i++) a[i] = a[i] * rn % mod;
    }
}
```

### NTT g = 3

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const ll mod=998244353;
int n;
int w[max_n];
ll x1[max_n*4];
ll x2[max_n*4];
ll inv[max_n];
ll quick_pow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=res*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return res;
}
void change(ll y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j)swap(y[i],y[j]);
        k=len/2;
        while(j>=k)j-=k,k/=2;
        if(j<k)j+=k;
    }
}
void ntt(ll y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        ll wn=quick_pow(3,(mod-1)/h);
        if(on==-1)wn=quick_pow(wn,mod-2);
        for(int j=0;j<len;j+=h)
        {
            ll w=1;
            for(int k=j;k<j+h/2;k++)
            {
                ll u=y[k];
                ll t=y[k+h/2]*w%mod;
                y[k]=(u+t)%mod;
                y[k+h/2]=(u-t+mod)%mod;
                w=w*wn%mod;
            }
        }
    }
    if(on==-1)
    {
        ll rlen=quick_pow(len,mod-2);
        for(int i=0;i<len;i++)y[i]=y[i]*rlen%mod;
    }
}
```

### 任意模数

```c++
namespace {
    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}
	inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}
    inline int Mul(int x,int y) {return 1ll*x*y%mod;}
    inline int Pow(int x,int y=mod-2){int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}
}

int Tonelli_Shanks(int n,ll p)
{
    if(p==2) return (n&1)?1:-1;
    if(Pow(n,p>>1)!=1) return -1;
    if(p&2) return Pow(n,(p+1)>>2);
    int s=__builtin_ctzll(p^1);
    int q=p>>s,z=2;
    for(;Pow(z,p>>1)==1;++z);
    int c=Pow(z,q),r=Pow(n,(q+1)>>1),t=Pow(n,q),tmp;
    for(int m=s,i;t!=1;)
    {
        for(i=0,tmp=t;tmp!=1;++i) tmp=tmp*tmp%p;
        for(;i<--m;) c=c*c%p;
        r=r*c%p;c=c*c%p;t=t*c%p;
    }
    return r;
}


namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;

    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};


namespace poly
{
    int inv(int x) {return Pow(x,mod-2);}
    vector<int> fa,fb,fc,fd;
    vector<int> get_inv(vector<int> &a,int n)
    {
        assert(a[0]!=0);
        if(n==1)
        {
            fa.resize(1);
            fa[0]=inv(a[0]);
            return fa;
        }
        fa=get_inv(a,(n+1)>>1);
        fb=fft::multiply_mod(fa,fa,mod,1);
        fb=fft::multiply_mod(fb,a,mod);
        fa.resize(n);
        for(int i=0;i<n;i++)
        {
            fa[i]=Add(fa[i],fa[i]);
            fa[i]=Sub(fa[i],fb[i]);
        }
        return fa;
    }
    vector<int> get_sqrt(vector<int> &a,int n)
    {
        if(n==1)
        {
            fc.resize(1);
            int x=Tonelli_Shanks(a[0],mod);
            assert(x!=-1);
            fc[0]=x;return fc;
        }
        fd=get_sqrt(a,(n+1)>>1);
        fc=get_inv(fd,(n+1)>>1);
        fd=fft::multiply_mod(fd,fd,mod,1);
        for(int i=0;i<(n+1)/2;i++) fc[i]=1LL*fc[i]*((mod+1)/2)%mod;
        for(int i=0;i<n;i++) fd[i]=Add(fd[i],a[i]);
        fd=fft::multiply_mod(fd,fc,mod);
        fd.resize(n);return fd;
    }
    vector<int> diff(vector<int> &a)
    {
        for(int i=1;i<(int)a.size();i++) a[i-1]=1LL*a[i]*i%mod;
        if(a.size()>=1) a.resize((int)a.size()-1);
        return a;
    }
    vector<int> intg(vector<int> &a)
    {
        int sz=(int)a.size();
        a.resize(sz+1);
        static vector<int> Inv(sz+1);
        Inv[1]=1;
        for(int i=2;i<=sz;i++) Inv[i]=Sub(mod,1LL*Inv[mod%i]*(mod/i)%mod);
        for(int i=sz;i>=1;i--) a[i]=1LL*a[i-1]*Inv[i]%mod;
        a[0]=0;
        return a;
    }
};
```

## 多项式

```c++
inline int add(int& x, int y) {
    return (x += y) >= mod ? x -= mod : x;
}
inline int sub(int& x, int y) {
    return (x -= y) < 0 ? x += mod : x;
}
inline int mul(int& x, int y) {
    return 1ll * x * y % mod;
}
inline int qpow(int x, ll n) {
    int r = 1;
    while (n > 0) {
        if (n & 1) r = 1ll * r * x % mod;
        n >>= 1; x = 1ll * x * x % mod;
    }
    return r;
}
inline int inv(int x) { 
    return qpow(x, mod - 2);
}

using Poly = vector<int>;

namespace PolyOP {
    int rev[maxn << 3];
    inline int build(int m) {
        int step = 0, n = 1;
        for (; n < m; n <<= 1) ++step;
        for (int i = 1; i < n; i++) 
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
        return n;  
    }
    inline void print(const Poly& a) {
        #ifdef XLor
            for (int x: a) printf("%d ", x);
            puts("");
        #endif
    }
    void ntt(int a[], int n, int op = 0) {
        for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int h = 2; h <= n; h <<= 1) {
            int wn = qpow(3, (mod - 1) / h);
            if (op == -1) wn = inv(wn);
            for (int i = 0; i < n; i += h) {
                int w = 1;
                for (int j = i; j < i + h / 2; j++) {
                    int u = a[j], t = 1ll * a[j + h / 2] * w % mod;
                    a[j] = (u + t) % mod;
                    a[j + h / 2] = (u - t + mod) % mod;
                    w = 1ll * w * wn % mod;
                }
            }
        }
        if (op == -1) {
            ll rn = inv(n);
            for (int i = 0; i < n; i++) a[i] = 1ll * a[i] * rn % mod;
        }
    }
    Poly operator * (const Poly& a, const Poly& b) {
        static int aa[maxn << 3], bb[maxn << 3];
        int lim = build((int)a.size() + (int)b.size() - 1);
        for (int i = 0; i < (int)a.size(); i++) aa[i] = a[i];
        for (int i = (int)a.size(); i < lim; i++) aa[i] = 0;
        for (int i = 0; i < (int)b.size(); i++) bb[i] = b[i];
        for (int i = (int)b.size(); i < lim; i++) bb[i] = 0;
        ntt(aa, lim); ntt(bb, lim);
        for (int i = 0; i < lim; i++) aa[i] = 1ll * aa[i] * bb[i] % mod;
        ntt(aa, lim, -1);
        Poly ans;
        for (int i = 0; i < (int)a.size() + (int)b.size() - 1; i++) ans.push_back(aa[i]);
        return ans;
    }
}
using namespace PolyOP;
```



```c++
const int inv2=(mod+1)>>1,mrt=31596;
const int fmaxn=21,Fmaxn=(1<<fmaxn)+5,G=3;
int nxtl[Fmaxn],nxtlim[Fmaxn],inv[Fmaxn];
namespace Solve {
    map<int,int>ins;
    inline int Solve2(int p) {
        static int j,res;
        if(p==0)
            return 0;
        j=1;
        for(int i=0;i<mrt;++i)
            ins[j]=i,j=Mul(j,G);
        res=0,j=Pow(j);
        for(int i=0;i<=mrt;++i) {
            if(ins.count(p)) {
                res=(res+ins[p])%(mod-1);
                if(res&1)
                    return -1;
                res=Pow(G,res/2);
                if(mod-res<res)
                    res=mod-res;
                return res;
            }
            p=Mul(p,j),res=(res+mrt)%(mod-1);
        }
        return -1;
    }
}
namespace Poly {
    static int root[fmaxn][Fmaxn],mx,rev[Fmaxn];
    inline void Rev(int l) {
        rev[0]=0;
        for(int i=1;i<(1<<l);++i)
            rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
    }
    inline void DFT(vector<int>&a,int bit) {
        if(mx<bit) {
            for(int i=mx;i<bit;++i) {
                int len=1<<i,w0=Pow(G,(mod-1)/(len<<1)),w=1;
                for(int j=0;j<len;++j)
                    root[i][j]=w,w=Mul(w,w0);
            }
            mx=bit;
        }
        for(int i=1;i<1<<bit;++i)
            if(i<rev[i])
                swap(a[i],a[rev[i]]);
        for(int i=0,len=1;i<bit;++i,len<<=1)
            for(int j=0;j<(1<<bit);j+=(len<<1))
                for(int k=0;k<len;++k) {
                    int x=a[j+k],y=Mul(a[j+k+len],root[i][k]);
                    a[j+k]=Add(x,y),a[j+k+len]=Sub(x,y);
                }
    }
    inline void IDFT(vector<int>&a,int bit) {
        int len=(1<<bit),inv=Pow(len);
        reverse(a.begin()+1,a.end());
        DFT(a,bit);
        for(int i=0;i<len;++i)
            a[i]=Mul(a[i],inv);
    }
    inline void FFT(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=la+lb-1,l=nxtl[lc],lim=nxtlim[lc];
        a.resize(lim),b.resize(lim),c.resize(lim);
        Rev(l),DFT(a,l),DFT(b,l);
        for(int i=0;i<lim;++i)
            c[i]=Mul(a[i],b[i]);
        IDFT(c,l);
        c.resize(lc);
        while(!c.back())
        	c.pop_back();
    }
    inline void AddPoly(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=max(la,lb);
        c.resize(lc);
        for(int i=0;i<lc;++i) {
            if(i<la)
                c[i]=Add(c[i],a[i]);
            if(i<lb)
                c[i]=Add(c[i],b[i]);
        }
    }
    inline void SubPoly(vector<int>a,vector<int>b,vector<int>&c) {
        c.clear();
        int la=a.size(),lb=b.size(),lc=max(la,lb);
        c.resize(lc);
        for(int i=0;i<lc;++i) {
            if(i<la)
                c[i]=Add(c[i],a[i]);
            if(i<lb)
                c[i]=Sub(c[i],b[i]);
        }
    }
    inline void Inv(vector<int>f,vector<int>&g,int len) {
        g.clear();
        int lim=nxtlim[len];
        f.resize(lim),g.resize(lim);
        g[0]=Pow(f[0]);
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i<<1),l(i<<1),o(i<<1);
            for(int j=0;j<i;++j)
                h[j]=f[j];
            for(int j=0;j<i>>1;++j)
                l[j]=g[j];
            Rev(p+1),DFT(h,p+1),DFT(l,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(h[j],Mul(l[j],l[j]));
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=Sub(Mul(2,g[j]),o[j]);
        }
        g.resize(len);
    }
    inline void Ln(vector<int>f,vector<int>&g,int len) {
        g.clear();
        vector<int>h(len,0);
        for(int i=1;i<len;++i)
            h[i-1]=Mul(f[i],i);
        h[len-1]=0;
        Inv(f,g,len);
        FFT(g,h,g);
        for(int i=len-1;i;--i)
            g[i]=Mul(g[i-1],::inv[i]);
        g[0]=0;
        g.resize(len);
    }
    inline void Exp(vector<int>f,vector<int>&g,int len,int init) {
        int lim=nxtlim[len];
        if(init)
           g.clear(),g.push_back(1);
        f.resize(lim),g.resize(lim);
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i<<1),l,o(i<<1,0);
            for(int j=0;j<i>>1;++j)
                h[j]=g[j];
            Ln(h,l,i);
            for(int j=0;j<i;++j)
                l[j]=Sub(f[j]+(!j),l[j]),l.push_back(0);
            Rev(p+1),DFT(h,p+1),DFT(l,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(h[j],l[j]);
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=o[j];
        }
        g.resize(len);
    }
    inline void Pow(vector<int>f,vector<int>&g,int len,ll k) {
        g.clear();
        vector<int>h;
        Ln(f,h,len);
        int o=k%mod;
        for(int i=0;i<len;++i)
            h[i]=Mul(h[i],o);
        g.push_back(::Pow(f[0],(int)(k%(mod-1))));
        Exp(h,g,len,0);
    }
    inline void Sqrt(vector<int>f,vector<int>&g,int len) {
        g.clear();
        g.push_back(Solve::Solve2(f[0]));
        int lim=nxtlim[len];
        for(int i=2,p=1;i<=lim;i<<=1,++p) {
            vector<int>h(i),l,o(i<<1,0);
            g.resize(i<<1);
            for(int j=0;j<i;++j)
                h[j]=g[j];
            Inv(h,l,i);
            l.resize(i<<1);
            for(int j=0;j<min(i,(int)f.size());++j)
                o[j]=f[j];
            Rev(p+1),DFT(g,p+1),DFT(l,p+1),DFT(o,p+1);
            for(int j=0;j<i<<1;++j)
                o[j]=Mul(Add(g[j],Mul(l[j],o[j])),inv2);
            IDFT(o,p+1);
            for(int j=0;j<i;++j)
                g[j]=o[j];
            g.resize(i);
        }
        g.resize(len);
    }
}
void init()
{
    nxtl[1]=0,nxtlim[1]=1,inv[1]=1;
    for(int i=1;i<Fmaxn-1;++i) {
        nxtl[i+1]=nxtl[i],nxtlim[i+1]=nxtlim[i];
        if(i==(i&-i))
            ++nxtl[i+1],nxtlim[i+1]<<=1;
    }
    for(int i=2;i<Fmaxn;++i)
        inv[i]=Mul(inv[mod%i],(mod-mod/i));
}
```

## 快速沃尔什变换

```c++
const int mod = 998244353;
const int inf = 1 << 30;
const int maxn = 1 << 18;

int n, a[maxn], b[maxn], c[maxn], d[maxn], e[maxn], f[maxn];

void fwtOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j + d] = (a[i + j + d] + a[i + j]) % mod;
                else
                    a[i + j + d] = (a[i + j + d] + mod - a[i + j]) % mod;
            }
}
void fwtAND(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j] = (a[i + j] + a[i + j + d]) % mod;
                else
                    a[i + j] = (a[i + j] + mod - a[i + j + d]) % mod;
            }
}
void fwtXOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                int x = a[i + j], y = a[i + j + d];
                a[i + j] = (x + y) % mod;
                a[i + j + d] = (x + mod - y) % mod;
                if (op != 1) {
                    // inv2 = 499122177
                    a[i + j] = 1ll * a[i + j] * 499122177 % mod;
                    a[i + j + d] = 1ll * a[i + j + d] * 499122177 % mod;
                }
            }
}

int main() {
    scanf("%d", &n);
    int m = 1 << n;
    for (int i = 0; i < m; i++) scanf("%d", a + i), c[i] = a[i], e[i] = a[i];
    for (int i = 0; i < m; i++) scanf("%d", b + i), d[i] = b[i], f[i] = b[i];
    fwtOR(a, 1 << n); fwtOR(b, 1 << n);
    for (int i = 0; i < m; i++) a[i] = 1ll * a[i] * b[i] % mod;
    fwtOR(a, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", a[i], " \n"[i == m - 1]);
    fwtAND(c, 1 << n); fwtAND(d, 1 << n);
    for (int i = 0; i < m; i++) c[i] = 1ll * c[i] * d[i] % mod;
    fwtAND(c, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", c[i], " \n"[i == m - 1]);
    fwtXOR(e, 1 << n); fwtXOR(f, 1 << n);
    for (int i = 0; i < m; i++) e[i] = 1ll * e[i] * f[i] % mod;
    fwtXOR(e, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", e[i], " \n"[i == m - 1]);
    return 0;
}
```

### FWT mod

```c++
int quick_pow(int a,int b)
{
    if(a==0)return 0;
    int res=1;
    while(b)
    {
        if(b&1)res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
void fwt_xor(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                int tmp=a[j+k];
                a[j+k]=(tmp+a[j+k+i])%mod;
                a[j+k+i]=(tmp+mod-a[j+k+i])%mod;
            }
        }
    }
    if(opt==-1)
    {
        int inv=quick_pow(l,mod-2);
        for(int i=0;i<l;i++)a[i]=1ll*a[i]*inv%mod;
    }
}


void fwt_or(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k+i]=(a[j+k+i]+a[j+k])%mod;
                else a[j+k+i]=(a[j+k+i]+mod-a[j+k])%mod;
            }
        }
    }
}
void fwt_and(int* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                if(opt==1)a[j+k]=(a[j+k]+a[j+k+i])%mod;
                else a[j+k]=(a[j+k]+mod-a[j+k+i])%mod;
            }
        }
    }
}
```

```c++
void fwt_xor(ll* a,int l,int opt)
{
    for(int i=1;i<l;i<<=1)
    {
        for(int j=0;j<l;j+=(i<<1))
        {
            for(int k=0;k<i;k++)
            {
                ll tmp=a[j+k];
                a[j+k]+=a[j+k+i];
                a[j+k+i]=tmp-a[j+k+i];
                if(opt==-1)a[j+k]/=2,a[j+k+i]/=2;
            }
        }
    }
}
```

## 线性基

```c++
struct LinearBase {
    static const int maxl = 63;
    ll a[maxl + 5];
    int cnt;
    LinearBase() { cnt=0; ms(a, 0); }
    void clear() { cnt=0; ms(a, 0); }
    void insert(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x & (1ll << i)) {
                if (a[i]) x ^= a[i];
                else {
                    for (int k = 0; k < i; k++) 
                        if (x & (1ll << k)) x ^= a[k];
                    for (int k = i + 1; k < maxl; k++) 
                        if (a[k] & (1ll << i)) a[k] ^= x;
                    a[i] = x; cnt++;
                    return ;
                }
            }
        }
    }
    bool check(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x >> i & 1) {
                if (a[i]) x ^= a[i];
                else return false;
            }
        }
        return true;
    }
    ll qmax(int x) {
        ll res = x;
        for(int i = maxl - 1 ; i >= 0; i--) {
            if ((res ^ a[i]) > res) res ^= a[i];
        }
        return res;
    }
    // #define QUERY_KTH
    #ifdef QUERY_KTH
    vector<ll> v;
    void init_kth() {
        v.clear();
        for (int i = 0; i < maxl; i++) if (a[i]) v.push_back(a[i]);
    }
    ll query(ll k) {
        if (v.size() != n) k--;
        if (k >= (1ll << v.size())) return -1;
        ll ans = 0;
        for (int i = 0; i < v.size(); i++) if (k & (1ll << i))
            ans ^= v[i];
        return ans;
    }
    #endif
};
```

### 区间线性基

```c++
struct LinearBase {
    static const int M = 30;
    int a[M + 1], pos[M + 1];
    void clear() {
        ms(a, 0); ms(pos, 0);
    }
    LinearBase() { 
        clear();
    }
    int insert(int x, int id = 0) {
        for (int i = M; i >= 0; i--) {
            if (x >> i & 1) {
                if (a[i]) {
                    if (id > pos[i]) swap(id, pos[i]), swap(x, a[i]);
                    x ^= a[i];
                } else {
                    a[i] = x; pos[i] = id;
                    return true;
                }
            }
        }
        return false;
    }
    int query(int x, int l) {
        int ans = x;
        for (int i = M; i >= 0; i--) {
            if (pos[i] < l) continue;
            if ((ans ^ a[i]) >= ans) ans ^= a[i];
        }
        return ans;
    }
};
```

### 线性基求交

```c++
LinearBase intersect(const LinearBase& A, const LinearBase& B) {
	LinearBase all, C, D;
	for (int i = maxl - 1; i >= 0; i--) {
		all.a[i] = A.a[i];
		D.a[i] = 1ll << i;
	}
	for (int i = maxl - 1; i >= 0; i--) {
		if (B.a[i]) {
			ll v = B.a[i], k = 0;
			bool can = true;
			for (int j = 60; j >= 0; j--) {
				if (v & (1ll << j)) {
					if (all.a[j]) {
						v ^= all.a[j];
						k ^= D.a[j];
					} else {
						can = false;
						all.a[j] = v;
						D.a[j] = k;
						break;
					}
				}
			}

			if (can) {
				ll v = 0;
				for (int j = 60; j >= 0; j--) {
					if (k & (1ll << j)) {
						v ^= A.a[j];
					}
				}
				C.insert(v);
			}
		}
	}
	return C;
}
```

## 线性筛法

```c++
namespace sieve{
    const int maxp = 1000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
        ms(vis, 0);
        for (int i = 2; i < maxp; i++) {
            if (!vis[i]) prime[tot++] = i;
            for (int j = 0; j < tot && prime[j] * i < maxp; j++) {
                vis[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
    }
}
```

### 欧拉函数

```c++
int phi[maxn], prime[maxn], cnt;
bool isntp[maxn];
void getphi() {
    phi[1] = 1;
    for (int i = 2; i < maxn; i++) {
        if (!isntp[i]) prime[++tot] = i, phi[i] = i - 1;
        for (int j = 1; j < cnt; j++) {
            if (1ll * prime[j] * i >= maxn) break;
            isntp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }        
    }
}
```

### 莫比乌斯反演

```c++
int mu[maxn], vis[maxn], prime[maxn], tot;
void getMu() {
    mu[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!vis[i]) prime[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot && i * prime[j] < maxn; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
```

## 高斯消元

### 实数版

```c++
namespace Gauss {
    static const double eps = 1e-7;
    double a[maxn][maxn], ans[maxn];
    void init(int n) {
        for (int i = 0; i <= n + 1; i++) {
            ans[i] = 0;
            for (int j = 0; j <= n + 1; j++)
                a[i][j] = 0;
        }
    }
    bool get(int n) {
        for (int i = 1; i <= n; i++) {
            int r = i;
            for (int j = i + 1; j <= n; j++)
                if(abs(a[j][i]) > abs(a[r][i])) r = j;
            if (abs(a[r][i]) < eps) return false;
            swap(a[r], a[i]);
            double inv = a[i][i];
            for (int j = i; j <= n + 1; j++) a[i][j] /= inv;
            for (int j = i + 1; j <= n; j++) {
                double inv = a[j][i];
                for(int k = i; k <= n + 1; k++)
                    a[j][k] -= inv * a[i][k];
            }
        }
        for(int i = n; i >= 1; i--) {
            ans[i] = a[i][n + 1];
            for(int j = i + 1; j <= n; j++)
                ans[i] -= a[i][j] * ans[j];
        }
        return true;
    }
    void print(int n) {
        for (int i = 1; i <= n; i++, puts(""))
            for (int j = 1; j <= n + 1; j++)
                printf("%lf ", a[i][j]);
    }
}
```

### 取模版

```c++
int n;
int a[max_n][max_n],ans[max_n];
bool gauss()
{
    for(int i=1;i<=n;i++)
    {
        int r=i;
        for(int j=i+1;j<=n;j++)if(a[j][i]>a[r][i])r=j;
        if(a[r][i]==0)return false;
        int inv=Pow(a[i][i]);
        for(int j=i;j<=n+1;j++)a[i][j]=1ll*a[i][j]*inv%mod;
        for(int j=i+1;j<=n;j++)
        {
            int inv=a[j][i];
            for(int k=i;k<=n+1;k++)a[j][k]+=mod-1ll*inv*a[i][k]%mod,a[j][k]%=mod;
        }
    }
    for(int i=n;i>=1;i--)
    {
        ans[i]=a[i][n+1];
        for(int j=i+1;j<=n;j++)ans[i]+=mod-1ll*ans[j]*a[i][j]%mod,ans[i]%=mod;
    }
    return true;
}
```



## 康拓展开

```c++
int f[10];
void init() {
    f[0] = 1; for (int i = 1; i < 10; i++) f[i] = f[i - 1] * i;
}

int cantor(int x[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int temp = 0;
        for (int j = i + 1; j < n; j++)
            if (x[i] > x[j])
                temp++;
        sum += f[n - 1 - i] * temp;
    }
    return sum;
}

int cantor(int t, int x[], int n) {
    int vis[10] = {0};
    for (int i = n - 1; i >= 0; i--) {
        int k = t / f[i]; t = t % f[i];
        int j = 1, s = 0;
        while (s < k || vis[j]) {
            if (!vis[j]) s++;
            j++;
        }
        vis[j] = 1; x[n - 1 - i] = j;
    }
    return 0;
}
```

## 数学公式

### 整除 gcd lcm相关

$(n,i)=1  ->   (n,n-i)=1$

$(i+j,i-j) | 2*(i,j)$

$\gcd(a^m-1,a^n-1)=a^{gcd(m,n)}-1$

$\gcd(a,b)=1,\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(m,n)}-b^{\gcd(m,n)}$

$G=\gcd(C_n^1 ,C_n^2 ,... ,C_n^{n-1})$ ,那么G的值为：

(1) n  is  prime ,$G=n$

(2)n有多个质因子，$G=1$

(3)n只有一个质因子 , $G=p$

$(a,b)=1$,a,b不能线性表示的最大的数为$a*b-a-b$,不能线性表示的数的个数$\frac{(a-1)(b-1)}{2}$

**杜教筛**: $g(1)S(n)=\sum_{i=1}^n h(i) - \sum_{d=2}^n g(d) \cdot S(\lfloor \frac{n}{d} \rfloor)$,其中 $h(i)=(f*g)(i)$ 

### Fibnacci

$F(n)=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]$

$F(n)=F(m)F(n-m+1)+F(m-1)F(n-m)$

$F(n+m)=F(m-1)F(n)+F(m)F(n+1)$

$F(1)+F(2)+...+F(n)=F(n+2)-1$

$1\cdot F(1)+2\cdot F(2)+\dots+n \cdot F(n)=n\cdot F(n+2)-F(n+3)+2$

$F(1)^2 +F(2)^2 +...+F(n)^2 =F(n)F(n+1)$

$F(1)+F(3)+...+F(2n-1)=F(2n)$

$F(2)+F(4)+...+F(2n)=F(2n+1)-1$

$F(n-1)F(n+1)=F(n)^2 +(-1)^n$

$gcd(F(n),F(m))=gcd(F(n-m),F(m))$

$gcd(F(n),F(m))=F(gcd(n,m))$

$F(n)|F(m)\Leftrightarrow n|m$

$F(x)=\begin{cases}C_{\frac{x}{2}}^1 +C_{\frac{x}{2}+1}^3 +C_{\frac{x}{2}+2}^5 +...+C_{x-1}^{x-1},&\text{if x is even}\\C_{\frac{x-1}{2}}^0 +C_{\frac{x-1}{2}+1}^2 +C_{\frac{x-1}{2}+2}^4 +...+C_{x-1}^{x-1},&\text{if x is odd}\end{cases}$

### 其他

$[1,n]$ 内$lowbit(i)==x$的数量有$ (x<=n)+(n-x)/(2*x)$

$k$ 进制下数字根 = $(sumdigit-1)\%(k-1)+1$

## 斐波那契循环节

```c++
const int M = 2;

struct Matrix{
    LL m[M][M];
} A, I = {1, 0, 0, 1};
Matrix multi(Matrix a, Matrix b, LL mod) { // 矩阵乘法
    Matrix c;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < M; j++) {
            c.m[i][j] = 0;
            for (int k = 0; k < M; k++)
                c.m[i][j] = (c.m[i][j] % mod + (a.m[i][k] % mod) * (b.m[k][j] % mod) % mod) % mod;
            c.m[i][j] %= mod;
        }
    }
    return c;
}
Matrix power(Matrix a, LL k, LL mod) { // 矩阵快速幂
    Matrix ans = I, p = a;
    while (k) {
        if (k & 1) ans = multi(ans, p, mod);
        k >>= 1;
        p = multi(p, p, mod);
    }
    return ans;
}
void init() { // 变换矩阵
    A.m[0][0] = A.m[0][1] = A.m[1][0] = 1;
    A.m[1][1] = 0;
}

LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }
LL qpow(LL a, LL b, LL c) {
    LL res = 1; a = a % c;
    while (b) {
        if (b & 1)
            res = res * a % c;
        b >>= 1;
        a = a * a % c;
    }
    return res;
}

LL w[maxn], c;
LL cal(LL p) { // 计算 G(p)
    if (p == 2) return 3;
    if (p == 3) return 8;
    if (p == 5) return 20;
    LL ans = 1, n;
    if (qpow(5, (p - 1) >> 1, p) == 1) n = p - 1;
    else n = 2 * p + 2;
    c = 0;
    for (LL i = 1; i * i <= n; i++)
        if (n % i == 0) {
            LL x = i, y = n / i;
            Matrix t = power(A, x - 1, p);
            LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
            LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
            if (f1 == 1 && f2 == 0) return x;
            if (x != y) w[c++] = y; // 优先按顺序计算，不加这个会超时
        }
    while (c) {
        Matrix t = power(A, w[--c] - 1, p);
        LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
        LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
        if (f1 == 1 && f2 == 0) return w[c];
    }
    return 1;
}

LL findLoop(LL n) { // 整数分解，G(p) 结果合并
    LL x = n, res = 1, l = LL(sqrt(n));
    for (LL i = 2; i * i <= x; i++)
        if (x % i == 0) {
            LL t = 1;
            while (x % i == 0) x /= i, t *= i;
            t = t / i * cal(i);
            res = res / gcd(res, t) * t;
        }
    if (x > 1) { // 防止 x 有余数
        LL t = cal(x);
        res = res / gcd(res, t) * t;
    }
    return res;
}
```

## 拉格朗日插值

```c++
int query(int x) {
    cout << "? " << x << endl;
    cin >> x; return x;
}

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        n >>= 1; x = x * x % mod;
    }
    return r;
}
ll Inv(ll x) {
    return qpow(x, mod - 2);
}

ll fac[maxn], a[20], inv[maxn];
struct Lagrange {
    // 1-based
    ll cc[20]; int n;
    void build(int nn) {
        n = nn;
        for (int i = 1; i <= n; i++) {
            cc[i] = Inv(fac[i - 1] * fac[n - i]) * a[i] % mod;
            if ((n - i) % 2 == 1) cc[i] = (mod - cc[i]) % mod;
        }
    }
    ll get(ll x) {
        if (x <= n) return a[x];
        ll ans = 0, tmp = 1;
        for (int i = 1; i <= n; i++) tmp = tmp * (x - i) % mod;
        for (int i = 1; i <= n; i++) {
            ans += tmp * inv[x - i] % mod * cc[i] % mod;
            if (ans >= mod) ans -= mod;
        }
        return ans;
    }
} f;

int main() {
    fac[0] = 1; 
    for (int i = 1; i < maxn; i++) fac[i] = fac[i - 1] * i % mod, inv[i] = Inv(i);
    for (int i = 0; i <= 15; i++) {
        a[i + 1] = query(i);
    }
    f.build(13);
    for (int i = 0; i < mod; i++) {
        if (!f.get(i + 1)) {
            cout << "! " << i << endl;
            return 0;
        }
    }
    cout << "! -1" << endl;
    return 0;
}
```

```c++
namespace Lagrange {
    int x[max_n],y[max_n],n;
    int inv[max_n];
    int pre[max_n],suf[max_n];
    void init(int* _x,int* _y,int _n)
    {
        n=_n;
        for(int i=1;i<=n;i++)x[i]=_x[i],y[i]=_y[i];
        int res=1;
        for(int i=1;i<=n;i++)res=1ll*res*i%mod;
        inv[n]=Pow(res);
        for(int i=n-1;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    }
    int cal(int m)//O(n^2)
    {
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1,ty=1;
            for(int j=1;j<=n;j++)
            {
                if(j==i)continue;
                tx=1ll*tx*(m+mod-x[j])%mod;
                ty=1ll*ty*(x[i]+mod-x[j])%mod;
            }
            tx=1ll*tx*Pow(ty)%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
    int qcal(int m)//O(n)
    {
        pre[0]=suf[n+1]=1;
        for(int i=1;i<=n;i++)pre[i]=1ll*pre[i-1]*(m+mod-x[i])%mod;
        for(int i=n;i>=1;i--)suf[i]=1ll*suf[i+1]*(m+mod-x[i])%mod;
        int res=0;
        for(int i=1;i<=n;i++)
        {
            int tx=1ll*pre[i-1]*suf[i+1]%mod;
            int ty=1ll*inv[i-1]*inv[n-i]%mod;
            if((n-i)&1)ty=mod-ty;
            tx=1ll*tx*ty%mod;tx=1ll*tx*y[i]%mod;
            res+=tx;res%=mod;
        }
        return res;
    }
}
```

## min_25 筛

### 递归版

```c++
int Sqr;
ll n;
int cnt;
bool p[max_n];
int pri[max_n];
int m;
ll w[max_n*2];
int id1[max_n*2],id2[max_n*2];
ll pre[max_n];
ll g[max_n*2],h[max_n*2],s[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i,pre[cnt]=(pre[cnt-1]+i)%mod;//decided
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
void init()
{
    Sqr=sqrt(n);
    m=0;
    ll i,j;
    for(i=1;i<=n;i=j+1)
    {
        w[++m]=n/i;
        g[m]=(w[m]+1)%mod*(w[m]%mod)%mod;//decided by f(x)
        if(g[m]&1)g[m]+=mod;
        g[m]/=2,g[m]--;
        h[m]=(w[m]-1)%mod;
        j=n/(n/i);
        if(w[m]<=Sqr)id1[w[m]]=m;
        else id2[n/w[m]]=m;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=(w[j]/pri[i]<=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];
            g[j]=g[j]+mod-1ll*pri[i]*(g[k]+mod-pre[i-1])%mod,g[j]%=mod;
            h[j]=h[j]+mod-(h[k]+mod-(i-1)),h[j]%=mod;//decided by f(x)
        }
    }
}
ll S(ll x,ll y)
{
    if(x<=1||x<pri[y])return 0;
    int k=x<=Sqr?id1[x]:id2[n/x];
    ll res=g[k]-pre[y-1]+mod-(h[k]-(y-1));//decided by f(x)
    res%=mod;
    if(y==1)res+=2;//decided by details
    for(int i=y;i<=cnt&&1ll*pri[i]*pri[i]<=x;i++)
    {
        ll t1=pri[i],t2=1ll*pri[i]*pri[i];
        for(int e=1;t2<=x;e++,t1=t2,t2*=pri[i])
        {
            res+=(pri[i]^e)*S(x/t1,i+1)%mod+(pri[i]^(e+1));//decided by f(x)
            res%=mod;
        }
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init();
    printf("%lld\n",(1+S(n,1))%mod);
    return 0;
}
```

### 非递归版

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int max_n=100005;
const int mod=998244353;
ll n;
int Sqr,m;
int ID(ll x){return x<=Sqr?m+1-x:n/x;}

bool p[max_n];
int pri[max_n];
int cnt;
ll w[max_n*2],g[max_n*2],f[max_n*2];
void sieve(int n)
{
    p[0]=p[1]=true;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])pri[++cnt]=i;
        for(int j=1;j<=cnt&&1ll*pri[j]*i<=n;j++)
        {
            p[i*pri[j]]=true;
            if(i%pri[j]==0)break;
        }
    }
}
ll F(ll e)
{
    if(e==1)return mod-2;
    else if(e==2)return 1;
    else return 0;
}
void init(ll n)
{
    Sqr=sqrt(n);
    m=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        w[++m]=n/l;
        g[m]=(w[m]-1)%mod;
    }
    for(int i=1;i<=cnt;i++)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            int k=ID(w[j]/pri[i]);
            g[j]=g[j]+mod-(g[k]+mod-(i-1))%mod,g[j]%=mod;
        }
    }
    for(int i=cnt;i;i--)
    {
        for(int j=1;j<=m&&1ll*pri[i]*pri[i]<=w[j];j++)
        {
            ll t1=pri[i],t2=1ll*pri[i]*pri[i];
            for(int e=1;t2<=w[j];e++,t1=t2,t2*=pri[i])
            {
                if(e>=3)break;
                int k=ID(w[j]/t1);
                f[j]+=F(e)*(f[k]+mod-2*(g[k]+mod-i)%mod)%mod+F(e+1),f[j]%=mod;
            }
        }
    }
    for(int j=1;j<=m;j++)f[j]+=mod-g[j]*2%mod,f[j]%=mod;
}
ll solve(ll n)
{
    ll res=0;
    ll ps=0;
    for(ll l=1,r;l<=n;l=r+1)
    {
        r=n/(n/l);
        int k=ID(r);
        ll ns=f[k]+1;
        ll tmp=n/l%mod;
        tmp=tmp*tmp%mod;
        res+=tmp*(ns+mod-ps)%mod,res%=mod;
        ps=ns;
    }
    return res;
}
int main()
{
    sieve(max_n-1);
    scanf("%lld",&n);
    init(n);
    printf("%lld\n",solve(n));
}
```

## Pollard Rho

```c++
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <stdio.h>
#include <algorithm>
#include <math.h>
#include <stdlib.h>

#include<time.h>
#define ll long long

#define INF 0x3f3f3f3f
#define maxn 10000+10
#define cle(a) memset(a,0,sizeof(a))
const double eps=1e-5;
using namespace std;

const int S=20;//随机算法判定次数，S越大，判错概率越小
//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的
//  a,b,c <2^63
int mult_mod(int a,int b,int c)
{
    return 1ll*a*b%c;
}
int pow_mod(int x,int n,int mod)
{
    if(n==1)return x%mod;
    x%=mod;
    int tmp=x;
    int ret=1;
    while(n)
    {
        if(n&1) ret=mult_mod(ret,tmp,mod);
        tmp=mult_mod(tmp,tmp,mod);
        n>>=1;
    }
    return ret;
}
//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数
//一定是合数返回true,不一定返回false
bool check(int a,int n,int x,int t)
{
    int ret=pow_mod(a,x,n);
    int last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=mult_mod(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1) return true;//合数
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}
// Miller_Rabin()算法素数判定
//是素数返回true.(可能是伪素数，但概率极小)
//合数返回false;
bool Miller_Rabin(int n)
{
    if(n<2)return false;
    if(n==2)return true;
    if((n&1)==0) return false;//偶数
    int x=n-1;
    int t=0;
    while((x&1)==0){x>>=1;t++;}
    for(int i=0;i<S;i++)
    {
        int a=rand()%(n-1)+1;//rand()需要stdlib.h头文件
        if(check(a,n,x,t))
            return false;//合数
    }
    return true;
}
int factor[100];//质因数分解结果（刚返回时是无序的）
int tol;//质因数的个数。数组小标从0开始
int gcd(int a,int b)
{
    if(a==0)return 1;//???????
    if(a<0) return gcd(-a,b);
    while(b)
    {
        ll t=a%b;
        a=b;
        b=t;
    }
    return a;
}
int Pollard_rho(int x,int c)
{
    int i=1,k=2;
    int x0=rand()%x;
    int y=x0;
    while(1)
    {
        i++;
        x0=(mult_mod(x0,x0,x)+c)%x;
        int d=gcd(y-x0,x);
        if(d!=1&&d!=x) return d;
        if(y==x0) return x;
        if(i==k){y=x0;k+=k;}
    }
}
//对n进行素因子分解
void findfac(int n)
{
    if(Miller_Rabin(n))//素数
    {
        factor[tol++]=n;
        return;
    }
    int p=n;
    while(p>=n)p=Pollard_rho(p,rand()%(n-1)+1);
    findfac(p);
    findfac(n/p);
}
```

## 扩展 BSGS

```c++
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
const int HashMod=123456;
struct HashTable
{
    struct Line{int u,v,next;}e[100000];
    int h[HashMod],cnt;
    void Add(int u,int v,int w){e[++cnt]=(Line){w,v,h[u]};h[u]=cnt;}
    void clear(){memset(h,0,sizeof(h));cnt=0;}
    void Insert(int x,int i)
    {
        int k=x%HashMod;
        Add(k,i,x);
    }
    int Query(int x)
    {
        for(int i=h[x%HashMod];i;i=e[i].next)
            if(e[i].u==x)return e[i].v;
        return -1;
    }
}Hash;
int fpow(int a,int b,int MOD)
{
    int s=1;
    while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
void NoAnswer(){puts("No Solution");}
void ex_BSGS(int y,int z,int p)
{
    if(z==1){puts("0");return;}
    int k=0,a=1;
    while(233)
    {
        int d=__gcd(y,p);if(d==1)break;
        if(z%d){NoAnswer();return;}
        z/=d;p/=d;++k;a=1ll*a*y/d%p;
        if(z==a){printf("%d\n",k);return;}
    }
    Hash.clear();
    int m=sqrt(p)+1;
    for(int i=0,t=z;i<m;++i,t=1ll*t*y%p)Hash.Insert(t,i);
    for(int i=1,tt=fpow(y,m,p),t=1ll*a*tt%p;i<=m;++i,t=1ll*t*tt%p)
    {
        int B=Hash.Query(t);if(B==-1)continue;
        printf("%d\n",i*m-B+k);return;
    }
    NoAnswer();
}
int main()
{
    int x,z,k;
    while(233)
    {
        x=read();z=read();k=read();
        if(x==0&&z==0&&k==0)break;
        ex_BSGS(x,k,z);
    }
    return 0;
}
```

