# 数学

## 扩展欧几里得

```c++
void exgcd(ll a, ll b, ll& x, ll& y) {
    if (!b) x = 1, y = 0;
    else {
        exgcd(b, a % b, y, x);
        y -= a / b * x;
    }
}
```

## 矩阵

```c++
struct Mat {
    static const int M = 2;
    ll a[M][M];
    Mat() { ms(a, 0); }
    void clear() { ms(a, 0); }
    void eye() { for (int i = 0; i < M; i++) a[i][i] = 1; }
    ll* operator [] (ll x) { return a[x]; }
    const ll* operator [] (ll x) const { return a[x]; }
    Mat operator * (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                for (int k = 0; k < M; k++)
                    r[i][j] = (r[i][j] + a[i][k] * b[k][j]) % mod;
        return r;
    }
    Mat pow(ll n) const {
        Mat a = *this, r; r.eye();
        while (n > 0) {
            if (n & 1)  r = r * a;
            n >>= 1; a = a * a;
        }
        return r;
    }
    Mat operator + (const Mat& b) {
        const Mat& a = *this; Mat r;
        for (int i = 0; i < M; i++)
            for (int j = 0; j < M; j++)
                r[i][j] = (a[i][j] + b[i][j]) % mod;
        return r;
    }
    void print() const {
        for (int i = 0; i < M; i++) for (int j = 0; j < M; j++)
            printf("%lld%c", (*this)[i][j], " \n"[j == M - 1]);
    }
};
```

## 快速傅里叶变换

```c++
struct complex {
    double x, y;
    complex(double a = 0, double b = 0):x(a), y(b) {}
    complex operator+(const complex& b) {return complex{x + b.x, y + b.y};}
    complex operator-(const complex& b) {return complex{x - b.x, y - b.y};}
    complex operator*(const complex& b) {
        return complex{x * b.x - y * b.y, x * b.y + y * b.x};
    }
} a[maxn], b[maxn]; int rev[maxn];
void fft(int n, complex a[], int op = 1) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int i = 1; i < n; i <<= 1) {
        complex t(cos(pi / i), op * sin(pi / i));
        for (int j = 0; j < n; j += (i << 1)) {
            complex w(1, 0);
            for (int k = 0; k < i; k++, w = w * t) {
                complex x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y; a[j + k + i] = x - y;
            }
        }
    } 
    if (op == -1) for (int i = 0; i < n; i++) a[i].x /= n, a[i].y /= n;
}
void mul(int n, complex a[], int m, complex b[], int ans[]) {
    int l = 0, lim = 1; while (lim <= n + m) l++, lim <<= 1; 
    for (int i = 0; i < lim; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    fft(lim, a); fft(lim, b);
    for (int i = 0; i <= lim; i++) a[i] = a[i] * b[i];
    fft(lim, a, -1);
    for (int i = 0; i <= n + m; i++) ans[i] = (int)(a[i].x + 0.5);
}
```

## 快速数论变换

```c++
const int mod = 998244353;
const int maxn = 200000 + 5;

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        x = x * x % mod; n >>= 1;
    }
    return r;
}
ll inv(ll x) { return qpow(x, mod - 2); }
ll rev[maxn << 2];
int init(int m) {
    int step = 0, n = 1;
    for (; n < m; n <<= 1) ++step;
    for (int i = 1; i < n; i++) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (step - 1));
    return n;  
}
void ntt(vector<ll>& a, int n, int op) {
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int h = 2; h <= n; h <<= 1) {
        ll wn = qpow(3, (mod - 1) / h);
        if (op == -1) wn = inv(wn);
        for (int i = 0; i < n; i += h) {
            ll w = 1;
            for (int j = i; j < i + h / 2; j++) {
                ll u = a[j], t = a[j + h / 2] * w % mod;
                a[j] = (u + t) % mod;
                a[j + h / 2] = (u - t + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (op == -1) {
        ll rn = inv(n);
        for (int i = 0; i < n; i++) a[i] = a[i] * rn % mod;
    }
}
```

## 快速沃尔什变换

```c++
const int mod = 998244353;
const int inf = 1 << 30;
const int maxn = 1 << 18;

int n, a[maxn], b[maxn], c[maxn], d[maxn], e[maxn], f[maxn];

void fwtOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j + d] = (a[i + j + d] + a[i + j]) % mod;
                else
                    a[i + j + d] = (a[i + j + d] + mod - a[i + j]) % mod;
            }
}
void fwtAND(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                if (op == 1)
                    a[i + j] = (a[i + j] + a[i + j + d]) % mod;
                else
                    a[i + j] = (a[i + j] + mod - a[i + j + d]) % mod;
            }
}
void fwtXOR(int a[], int n, int op = 1) {
    for (int d = 1; d < n; d <<= 1)
        for (int i = 0, t = d << 1; i < n; i += t)
            for (int j = 0; j < d; j++) {
                int x = a[i + j], y = a[i + j + d];
                a[i + j] = (x + y) % mod;
                a[i + j + d] = (x + mod - y) % mod;
                if (op != 1) {
                    // inv2 = 499122177
                    a[i + j] = 1ll * a[i + j] * 499122177 % mod;
                    a[i + j + d] = 1ll * a[i + j + d] * 499122177 % mod;
                }
            }
}

int main() {
    scanf("%d", &n);
    int m = 1 << n;
    for (int i = 0; i < m; i++) scanf("%d", a + i), c[i] = a[i], e[i] = a[i];
    for (int i = 0; i < m; i++) scanf("%d", b + i), d[i] = b[i], f[i] = b[i];
    fwtOR(a, 1 << n); fwtOR(b, 1 << n);
    for (int i = 0; i < m; i++) a[i] = 1ll * a[i] * b[i] % mod;
    fwtOR(a, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", a[i], " \n"[i == m - 1]);
    fwtAND(c, 1 << n); fwtAND(d, 1 << n);
    for (int i = 0; i < m; i++) c[i] = 1ll * c[i] * d[i] % mod;
    fwtAND(c, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", c[i], " \n"[i == m - 1]);
    fwtXOR(e, 1 << n); fwtXOR(f, 1 << n);
    for (int i = 0; i < m; i++) e[i] = 1ll * e[i] * f[i] % mod;
    fwtXOR(e, 1 << n, -1);
    for (int i = 0; i < m; i++) printf("%d%c", e[i], " \n"[i == m - 1]);
    return 0;
}
```

## 线性基

```c++
struct LinearBase {
    static const int maxl = 63;
    ll a[maxl + 5];
    int cnt;
    LinearBase() { cnt=0; ms(a, 0); }
    void clear() { cnt=0; ms(a, 0); }
    void insert(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x & (1ll << i)) {
                if (a[i]) x ^= a[i];
                else {
                    for (int k = 0; k < i; k++) 
                        if (x & (1ll << k)) x ^= a[k];
                    for (int k = i + 1; k < maxl; k++) 
                        if (a[k] & (1ll << i)) a[k] ^= x;
                    a[i] = x; cnt++;
                    return ;
                }
            }
        }
    }
    bool check(ll x) {
        for (int i = maxl - 1; i >= 0; i--) {
            if (x >> i & 1) {
                if (a[i]) x ^= a[i];
                else return false;
            }
        }
        return true;
    }
    ll qmax(int x) {
        ll res = x;
        for(int i = maxl - 1 ; i >= 0; i--) {
            if ((res ^ a[i]) > res) res ^= a[i];
        }
        return res;
    }
    // #define QUERY_KTH
    #ifdef QUERY_KTH
    vector<ll> v;
    void init_kth() {
        v.clear();
        for (int i = 0; i < maxl; i++) if (a[i]) v.push_back(a[i]);
    }
    ll query(ll k) {
        if (v.size() != n) k--;
        if (k >= (1ll << v.size())) return -1;
        ll ans = 0;
        for (int i = 0; i < v.size(); i++) if (k & (1ll << i))
            ans ^= v[i];
        return ans;
    }
    #endif
};
```

## 线性筛法

```c++
namespace sieve{
    const int maxp = 1000000 + 5;
    int vis[maxp], prime[maxp], tot;
    void init() {
        ms(vis, 0);
        for (int i = 2; i < maxp; i++) {
            if (!vis[i]) prime[tot++] = i;
            for (int j = 0; j < tot && prime[j] * i < maxp; j++) {
                vis[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
    }
}
```

### 欧拉函数

```c++
int phi[maxn], prime[maxn], cnt;
bool isntp[maxn];
void getphi() {
    phi[1]=1;
	for(int i=2; i<maxn; i++){
        if(!isntp[i]) prime[++tot] = i, phi[i]=i-1;
        for(int j=1; j<cnt; j++){
            if(1ll*prime[j]*i>=maxn) break;
            isntp[i*prime[j]]=1;
            if(i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }        
    }
}
```

### 莫比乌斯反演

```c++
int mu[maxn], vis[maxn], prime[maxn], tot;
void getMu() {
    mu[1] = 1;
    for (int i = 2; i < maxn; ++i) {
        if (!vis[i]) prime[++tot] = i, mu[i] = -1;
        for (int j = 1; j <= tot && i * prime[j] < maxn; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
```

## 组合数

```c++
int f[maxn], inv[maxn], finv[maxn];
void init() {
    inv[1] = 1;
    for (int i = 2; i < mod; i++) 
    		inv[i] = (mod - mod / i) * 1ll * inv[mod % i] % mod;
    f[0] = finv[0] = 1; 
    for (int i = 1; i < mod; i++) {
        f[i] = f[i - 1] * 1ll * i % mod;
        finv[i] = finv[i - 1] * 1ll * inv[i] % mod;
    }
}
int C(int n, int m) {
    if (m < 0 || m > n) return 0;
    return f[n] * 1ll * finv[n - m] % mod * finv[m] % mod;
}
```

## 康拓展开

```c++
int f[10];
void init() {
    f[0] = 1; for (int i = 1; i < 10; i++) f[i] = f[i - 1] * i;
}

int cantor(int x[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int temp = 0;
        for (int j = i + 1; j < n; j++)
            if (x[i] > x[j])
                temp++;
        sum += f[n - 1 - i] * temp;
    }
    return sum;
}

int cantor(int t, int x[], int n) {
    int vis[10] = {0};
    for (int i = n - 1; i >= 0; i--) {
        int k = t / f[i]; t = t % f[i];
        int j = 1, s = 0;
        while (s < k || vis[j]) {
            if (!vis[j]) s++;
            j++;
        }
        vis[j] = 1; x[n - 1 - i] = j;
    }
    return 0;
}
```

## 数学公式

### 整除 gcd lcm相关

$(n,i)=1  ->   (n,n-i)=1$

$(i+j,i-j) | 2*(i,j)$

$\gcd(a^m-1,a^n-1)=a^{gcd(m,n)}-1$

$\gcd(a,b)=1,\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(m,n)}-b^{\gcd(m,n)}$

$G=\gcd(C_n^1 ,C_n^2 ,... ,C_n^{n-1})$ ,那么G的值为：

(1) n  is  prime ,$G=n$

(2)n有多个质因子，$G=1$

(3)n只有一个质因子 , $G=p$

$(a,b)=1$,a,b不能线性表示的最大的数为$a*b-a-b$,不能线性表示的数的个数$\frac{(a-1)(b-1)}{2}$

**杜教筛**: $g(1)S(n)=\sum_{i=1}^n h(i) - \sum_{d=2}^n g(d) \cdot S(\lfloor \frac{n}{d} \rfloor)$,其中 $h(i)=(f*g)(i)$ 

### Fibnacci

$F(n)=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]$

$F(n)=F(m)F(n-m+1)+F(m-1)F(n-m)$

$F(1)+F(2)+...+F(n)=F(n+2)-1$

$F(1)^2 +F(2)^2 +...+F(n)^2 =F(n)F(n+1)$

$F(1)+F(3)+...+F(2n-1)=F(2n)$

$F(2)+F(4)+...+F(2n)=F(2n+1)-1$

$F(n-1)F(n+1)=F(n)^2 +(-1)^n$

$gcd(F(n),F(m))=gcd(F(n-m),F(m))$

$gcd(F(n),F(m))=F(gcd(n,m))$

$F(n)|F(m)\Leftrightarrow n|m$

$F(x)=\begin{cases}C_{\frac{x}{2}}^1 +C_{\frac{x}{2}+1}^3 +C_{\frac{x}{2}+2}^5 +...+C_{x-1}^{x-1},&\text{if x is even}\\C_{\frac{x-1}{2}}^0 +C_{\frac{x-1}{2}+1}^2 +C_{\frac{x-1}{2}+2}^4 +...+C_{x-1}^{x-1},&\text{if x is odd}\end{cases}$

### 其他

$[1,n]$ 内$lowbit(i)==x$的数量有$ (x<=n)+(n-x)/(2*x)$

$k$ 进制下数字根 = $(sumdigit-1)\%(k-1)+1$

## 斐波那契循环节

```c++
const int M = 2;

struct Matrix{
    LL m[M][M];
} A, I = {1, 0, 0, 1};
Matrix multi(Matrix a, Matrix b, LL mod) { // 矩阵乘法
    Matrix c;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < M; j++) {
            c.m[i][j] = 0;
            for (int k = 0; k < M; k++)
                c.m[i][j] = (c.m[i][j] % mod + (a.m[i][k] % mod) * (b.m[k][j] % mod) % mod) % mod;
            c.m[i][j] %= mod;
        }
    }
    return c;
}
Matrix power(Matrix a, LL k, LL mod) { // 矩阵快速幂
    Matrix ans = I, p = a;
    while (k) {
        if (k & 1) ans = multi(ans, p, mod);
        k >>= 1;
        p = multi(p, p, mod);
    }
    return ans;
}
void init() { // 变换矩阵
    A.m[0][0] = A.m[0][1] = A.m[1][0] = 1;
    A.m[1][1] = 0;
}

LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }
LL qpow(LL a, LL b, LL c) {
    LL res = 1; a = a % c;
    while (b) {
        if (b & 1)
            res = res * a % c;
        b >>= 1;
        a = a * a % c;
    }
    return res;
}

LL w[maxn], c;
LL cal(LL p) { // 计算 G(p)
    if (p == 2) return 3;
    if (p == 3) return 8;
    if (p == 5) return 20;
    LL ans = 1, n;
    if (qpow(5, (p - 1) >> 1, p) == 1) n = p - 1;
    else n = 2 * p + 2;
    c = 0;
    for (LL i = 1; i * i <= n; i++)
        if (n % i == 0) {
            LL x = i, y = n / i;
            Matrix t = power(A, x - 1, p);
            LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
            LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
            if (f1 == 1 && f2 == 0) return x;
            if (x != y) w[c++] = y; // 优先按顺序计算，不加这个会超时
        }
    while (c) {
        Matrix t = power(A, w[--c] - 1, p);
        LL f1 = (t.m[0][0] % p + t.m[0][1] % p) % p;
        LL f2 = (t.m[1][0] % p + t.m[1][1] % p) % p;
        if (f1 == 1 && f2 == 0) return w[c];
    }
    return 1;
}

LL findLoop(LL n) { // 整数分解，G(p) 结果合并
    LL x = n, res = 1, l = LL(sqrt(n));
    for (LL i = 2; i * i <= x; i++)
        if (x % i == 0) {
            LL t = 1;
            while (x % i == 0) x /= i, t *= i;
            t = t / i * cal(i);
            res = res / gcd(res, t) * t;
        }
    if (x > 1) { // 防止 x 有余数
        LL t = cal(x);
        res = res / gcd(res, t) * t;
    }
    return res;
}
```

## 拉格朗日插值

```c++
int query(int x) {
    cout << "? " << x << endl;
    cin >> x; return x;
}

ll qpow(ll x, ll n) {
    ll r = 1;
    while (n > 0) {
        if (n & 1) r = r * x % mod;
        n >>= 1; x = x * x % mod;
    }
    return r;
}
ll Inv(ll x) {
    return qpow(x, mod - 2);
}

ll fac[maxn], a[20], inv[maxn];
struct Lagrange {
    // 1-based
    ll cc[20]; int n;
    void build(int nn) {
        n = nn;
        for (int i = 1; i <= n; i++) {
            cc[i] = Inv(fac[i - 1] * fac[n - i]) * a[i] % mod;
            if ((n - i) % 2 == 1) cc[i] = (mod - cc[i]) % mod;
        }
    }
    ll get(ll x) {
        if (x <= n) return a[x];
        ll ans = 0, tmp = 1;
        for (int i = 1; i <= n; i++) tmp = tmp * (x - i) % mod;
        for (int i = 1; i <= n; i++) {
            ans += tmp * inv[x - i] % mod * cc[i] % mod;
            if (ans >= mod) ans -= mod;
        }
        return ans;
    }
} f;

int main() {
    fac[0] = 1; 
    for (int i = 1; i < maxn; i++) fac[i] = fac[i - 1] * i % mod, inv[i] = Inv(i);
    for (int i = 0; i <= 15; i++) {
        a[i + 1] = query(i);
    }
    f.build(13);
    for (int i = 0; i < mod; i++) {
        if (!f.get(i + 1)) {
            cout << "! " << i << endl;
            return 0;
        }
    }
    cout << "! -1" << endl;
    return 0;
}
```

